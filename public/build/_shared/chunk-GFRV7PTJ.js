import {
  require_react_dom
} from "/build/_shared/chunk-ABUHE4LZ.js";
import {
  require_shim,
  require_with_selector
} from "/build/_shared/chunk-65R6ZMAR.js";
import {
  require_react
} from "/build/_shared/chunk-6NJTHYWJ.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS
} from "/build/_shared/chunk-DPSM2F2X.js";

// node_modules/@tanstack/query-sync-storage-persister/build/lib/index.js
var require_lib = __commonJS({
  "node_modules/@tanstack/query-sync-storage-persister/build/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function createSyncStoragePersister({
      storage,
      key = "REACT_QUERY_OFFLINE_CACHE",
      throttleTime = 1e3,
      serialize = JSON.stringify,
      deserialize = JSON.parse,
      retry
    }) {
      if (storage) {
        const trySave = (persistedClient) => {
          try {
            storage.setItem(key, serialize(persistedClient));
            return;
          } catch (error) {
            return error;
          }
        };
        return {
          persistClient: throttle((persistedClient) => {
            let client = persistedClient;
            let error = trySave(client);
            let errorCount = 0;
            while (error && client) {
              errorCount++;
              client = retry == null ? void 0 : retry({
                persistedClient: client,
                error,
                errorCount
              });
              if (client) {
                error = trySave(client);
              }
            }
          }, throttleTime),
          restoreClient: () => {
            const cacheString = storage.getItem(key);
            if (!cacheString) {
              return;
            }
            return deserialize(cacheString);
          },
          removeClient: () => {
            storage.removeItem(key);
          }
        };
      }
      return {
        persistClient: noop,
        restoreClient: () => void 0,
        removeClient: noop
      };
    }
    function throttle(func, wait = 100) {
      let timer = null;
      let params;
      return function(...args) {
        params = args;
        if (timer === null) {
          timer = setTimeout(() => {
            func(...params);
            timer = null;
          }, wait);
        }
      };
    }
    function noop() {
    }
    exports.createSyncStoragePersister = createSyncStoragePersister;
  }
});

// node_modules/@tanstack/query-core/build/lib/subscribable.js
var require_subscribable = __commonJS({
  "node_modules/@tanstack/query-core/build/lib/subscribable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Subscribable = class {
      constructor() {
        this.listeners = /* @__PURE__ */ new Set();
        this.subscribe = this.subscribe.bind(this);
      }
      subscribe(listener) {
        const identity = {
          listener
        };
        this.listeners.add(identity);
        this.onSubscribe();
        return () => {
          this.listeners.delete(identity);
          this.onUnsubscribe();
        };
      }
      hasListeners() {
        return this.listeners.size > 0;
      }
      onSubscribe() {
      }
      onUnsubscribe() {
      }
    };
    exports.Subscribable = Subscribable;
  }
});

// node_modules/@tanstack/query-core/build/lib/utils.js
var require_utils = __commonJS({
  "node_modules/@tanstack/query-core/build/lib/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var isServer = typeof window === "undefined" || "Deno" in window;
    function noop() {
      return void 0;
    }
    function functionalUpdate(updater, input) {
      return typeof updater === "function" ? updater(input) : updater;
    }
    function isValidTimeout(value) {
      return typeof value === "number" && value >= 0 && value !== Infinity;
    }
    function difference(array1, array2) {
      return array1.filter((x) => !array2.includes(x));
    }
    function replaceAt(array, index, value) {
      const copy = array.slice(0);
      copy[index] = value;
      return copy;
    }
    function timeUntilStale(updatedAt, staleTime) {
      return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);
    }
    function parseQueryArgs(arg1, arg2, arg3) {
      if (!isQueryKey(arg1)) {
        return arg1;
      }
      if (typeof arg2 === "function") {
        return {
          ...arg3,
          queryKey: arg1,
          queryFn: arg2
        };
      }
      return {
        ...arg2,
        queryKey: arg1
      };
    }
    function parseMutationArgs(arg1, arg2, arg3) {
      if (isQueryKey(arg1)) {
        if (typeof arg2 === "function") {
          return {
            ...arg3,
            mutationKey: arg1,
            mutationFn: arg2
          };
        }
        return {
          ...arg2,
          mutationKey: arg1
        };
      }
      if (typeof arg1 === "function") {
        return {
          ...arg2,
          mutationFn: arg1
        };
      }
      return {
        ...arg1
      };
    }
    function parseFilterArgs(arg1, arg2, arg3) {
      return isQueryKey(arg1) ? [{
        ...arg2,
        queryKey: arg1
      }, arg3] : [arg1 || {}, arg2];
    }
    function parseMutationFilterArgs(arg1, arg2, arg3) {
      return isQueryKey(arg1) ? [{
        ...arg2,
        mutationKey: arg1
      }, arg3] : [arg1 || {}, arg2];
    }
    function matchQuery(filters, query) {
      const {
        type = "all",
        exact,
        fetchStatus,
        predicate,
        queryKey,
        stale
      } = filters;
      if (isQueryKey(queryKey)) {
        if (exact) {
          if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {
            return false;
          }
        } else if (!partialMatchKey(query.queryKey, queryKey)) {
          return false;
        }
      }
      if (type !== "all") {
        const isActive = query.isActive();
        if (type === "active" && !isActive) {
          return false;
        }
        if (type === "inactive" && isActive) {
          return false;
        }
      }
      if (typeof stale === "boolean" && query.isStale() !== stale) {
        return false;
      }
      if (typeof fetchStatus !== "undefined" && fetchStatus !== query.state.fetchStatus) {
        return false;
      }
      if (predicate && !predicate(query)) {
        return false;
      }
      return true;
    }
    function matchMutation(filters, mutation) {
      const {
        exact,
        fetching,
        predicate,
        mutationKey
      } = filters;
      if (isQueryKey(mutationKey)) {
        if (!mutation.options.mutationKey) {
          return false;
        }
        if (exact) {
          if (hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)) {
            return false;
          }
        } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {
          return false;
        }
      }
      if (typeof fetching === "boolean" && mutation.state.status === "loading" !== fetching) {
        return false;
      }
      if (predicate && !predicate(mutation)) {
        return false;
      }
      return true;
    }
    function hashQueryKeyByOptions(queryKey, options) {
      const hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashQueryKey;
      return hashFn(queryKey);
    }
    function hashQueryKey(queryKey) {
      return JSON.stringify(queryKey, (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {
        result[key] = val[key];
        return result;
      }, {}) : val);
    }
    function partialMatchKey(a, b) {
      return partialDeepEqual(a, b);
    }
    function partialDeepEqual(a, b) {
      if (a === b) {
        return true;
      }
      if (typeof a !== typeof b) {
        return false;
      }
      if (a && b && typeof a === "object" && typeof b === "object") {
        return !Object.keys(b).some((key) => !partialDeepEqual(a[key], b[key]));
      }
      return false;
    }
    function replaceEqualDeep(a, b) {
      if (a === b) {
        return a;
      }
      const array = isPlainArray(a) && isPlainArray(b);
      if (array || isPlainObject(a) && isPlainObject(b)) {
        const aSize = array ? a.length : Object.keys(a).length;
        const bItems = array ? b : Object.keys(b);
        const bSize = bItems.length;
        const copy = array ? [] : {};
        let equalItems = 0;
        for (let i = 0; i < bSize; i++) {
          const key = array ? i : bItems[i];
          copy[key] = replaceEqualDeep(a[key], b[key]);
          if (copy[key] === a[key]) {
            equalItems++;
          }
        }
        return aSize === bSize && equalItems === aSize ? a : copy;
      }
      return b;
    }
    function shallowEqualObjects(a, b) {
      if (a && !b || b && !a) {
        return false;
      }
      for (const key in a) {
        if (a[key] !== b[key]) {
          return false;
        }
      }
      return true;
    }
    function isPlainArray(value) {
      return Array.isArray(value) && value.length === Object.keys(value).length;
    }
    function isPlainObject(o) {
      if (!hasObjectPrototype(o)) {
        return false;
      }
      const ctor = o.constructor;
      if (typeof ctor === "undefined") {
        return true;
      }
      const prot = ctor.prototype;
      if (!hasObjectPrototype(prot)) {
        return false;
      }
      if (!prot.hasOwnProperty("isPrototypeOf")) {
        return false;
      }
      return true;
    }
    function hasObjectPrototype(o) {
      return Object.prototype.toString.call(o) === "[object Object]";
    }
    function isQueryKey(value) {
      return Array.isArray(value);
    }
    function isError(value) {
      return value instanceof Error;
    }
    function sleep(timeout) {
      return new Promise((resolve) => {
        setTimeout(resolve, timeout);
      });
    }
    function scheduleMicrotask(callback) {
      sleep(0).then(callback);
    }
    function getAbortController() {
      if (typeof AbortController === "function") {
        return new AbortController();
      }
      return;
    }
    function replaceData(prevData, data, options) {
      if (options.isDataEqual != null && options.isDataEqual(prevData, data)) {
        return prevData;
      } else if (typeof options.structuralSharing === "function") {
        return options.structuralSharing(prevData, data);
      } else if (options.structuralSharing !== false) {
        return replaceEqualDeep(prevData, data);
      }
      return data;
    }
    exports.difference = difference;
    exports.functionalUpdate = functionalUpdate;
    exports.getAbortController = getAbortController;
    exports.hashQueryKey = hashQueryKey;
    exports.hashQueryKeyByOptions = hashQueryKeyByOptions;
    exports.isError = isError;
    exports.isPlainArray = isPlainArray;
    exports.isPlainObject = isPlainObject;
    exports.isQueryKey = isQueryKey;
    exports.isServer = isServer;
    exports.isValidTimeout = isValidTimeout;
    exports.matchMutation = matchMutation;
    exports.matchQuery = matchQuery;
    exports.noop = noop;
    exports.parseFilterArgs = parseFilterArgs;
    exports.parseMutationArgs = parseMutationArgs;
    exports.parseMutationFilterArgs = parseMutationFilterArgs;
    exports.parseQueryArgs = parseQueryArgs;
    exports.partialDeepEqual = partialDeepEqual;
    exports.partialMatchKey = partialMatchKey;
    exports.replaceAt = replaceAt;
    exports.replaceData = replaceData;
    exports.replaceEqualDeep = replaceEqualDeep;
    exports.scheduleMicrotask = scheduleMicrotask;
    exports.shallowEqualObjects = shallowEqualObjects;
    exports.sleep = sleep;
    exports.timeUntilStale = timeUntilStale;
  }
});

// node_modules/@tanstack/query-core/build/lib/focusManager.js
var require_focusManager = __commonJS({
  "node_modules/@tanstack/query-core/build/lib/focusManager.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var subscribable = require_subscribable();
    var utils = require_utils();
    var FocusManager = class extends subscribable.Subscribable {
      constructor() {
        super();
        this.setup = (onFocus) => {
          if (!utils.isServer && window.addEventListener) {
            const listener = () => onFocus();
            window.addEventListener("visibilitychange", listener, false);
            window.addEventListener("focus", listener, false);
            return () => {
              window.removeEventListener("visibilitychange", listener);
              window.removeEventListener("focus", listener);
            };
          }
          return;
        };
      }
      onSubscribe() {
        if (!this.cleanup) {
          this.setEventListener(this.setup);
        }
      }
      onUnsubscribe() {
        if (!this.hasListeners()) {
          var _this$cleanup;
          (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);
          this.cleanup = void 0;
        }
      }
      setEventListener(setup) {
        var _this$cleanup2;
        this.setup = setup;
        (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);
        this.cleanup = setup((focused) => {
          if (typeof focused === "boolean") {
            this.setFocused(focused);
          } else {
            this.onFocus();
          }
        });
      }
      setFocused(focused) {
        const changed = this.focused !== focused;
        if (changed) {
          this.focused = focused;
          this.onFocus();
        }
      }
      onFocus() {
        this.listeners.forEach(({
          listener
        }) => {
          listener();
        });
      }
      isFocused() {
        if (typeof this.focused === "boolean") {
          return this.focused;
        }
        if (typeof document === "undefined") {
          return true;
        }
        return [void 0, "visible", "prerender"].includes(document.visibilityState);
      }
    };
    var focusManager = new FocusManager();
    exports.FocusManager = FocusManager;
    exports.focusManager = focusManager;
  }
});

// node_modules/@tanstack/query-core/build/lib/onlineManager.js
var require_onlineManager = __commonJS({
  "node_modules/@tanstack/query-core/build/lib/onlineManager.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var subscribable = require_subscribable();
    var utils = require_utils();
    var onlineEvents = ["online", "offline"];
    var OnlineManager = class extends subscribable.Subscribable {
      constructor() {
        super();
        this.setup = (onOnline) => {
          if (!utils.isServer && window.addEventListener) {
            const listener = () => onOnline();
            onlineEvents.forEach((event) => {
              window.addEventListener(event, listener, false);
            });
            return () => {
              onlineEvents.forEach((event) => {
                window.removeEventListener(event, listener);
              });
            };
          }
          return;
        };
      }
      onSubscribe() {
        if (!this.cleanup) {
          this.setEventListener(this.setup);
        }
      }
      onUnsubscribe() {
        if (!this.hasListeners()) {
          var _this$cleanup;
          (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);
          this.cleanup = void 0;
        }
      }
      setEventListener(setup) {
        var _this$cleanup2;
        this.setup = setup;
        (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);
        this.cleanup = setup((online) => {
          if (typeof online === "boolean") {
            this.setOnline(online);
          } else {
            this.onOnline();
          }
        });
      }
      setOnline(online) {
        const changed = this.online !== online;
        if (changed) {
          this.online = online;
          this.onOnline();
        }
      }
      onOnline() {
        this.listeners.forEach(({
          listener
        }) => {
          listener();
        });
      }
      isOnline() {
        if (typeof this.online === "boolean") {
          return this.online;
        }
        if (typeof navigator === "undefined" || typeof navigator.onLine === "undefined") {
          return true;
        }
        return navigator.onLine;
      }
    };
    var onlineManager = new OnlineManager();
    exports.OnlineManager = OnlineManager;
    exports.onlineManager = onlineManager;
  }
});

// node_modules/@tanstack/query-core/build/lib/retryer.js
var require_retryer = __commonJS({
  "node_modules/@tanstack/query-core/build/lib/retryer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var focusManager = require_focusManager();
    var onlineManager = require_onlineManager();
    var utils = require_utils();
    function defaultRetryDelay(failureCount) {
      return Math.min(1e3 * 2 ** failureCount, 3e4);
    }
    function canFetch(networkMode) {
      return (networkMode != null ? networkMode : "online") === "online" ? onlineManager.onlineManager.isOnline() : true;
    }
    var CancelledError = class {
      constructor(options) {
        this.revert = options == null ? void 0 : options.revert;
        this.silent = options == null ? void 0 : options.silent;
      }
    };
    function isCancelledError(value) {
      return value instanceof CancelledError;
    }
    function createRetryer(config) {
      let isRetryCancelled = false;
      let failureCount = 0;
      let isResolved = false;
      let continueFn;
      let promiseResolve;
      let promiseReject;
      const promise = new Promise((outerResolve, outerReject) => {
        promiseResolve = outerResolve;
        promiseReject = outerReject;
      });
      const cancel = (cancelOptions) => {
        if (!isResolved) {
          reject(new CancelledError(cancelOptions));
          config.abort == null ? void 0 : config.abort();
        }
      };
      const cancelRetry = () => {
        isRetryCancelled = true;
      };
      const continueRetry = () => {
        isRetryCancelled = false;
      };
      const shouldPause = () => !focusManager.focusManager.isFocused() || config.networkMode !== "always" && !onlineManager.onlineManager.isOnline();
      const resolve = (value) => {
        if (!isResolved) {
          isResolved = true;
          config.onSuccess == null ? void 0 : config.onSuccess(value);
          continueFn == null ? void 0 : continueFn();
          promiseResolve(value);
        }
      };
      const reject = (value) => {
        if (!isResolved) {
          isResolved = true;
          config.onError == null ? void 0 : config.onError(value);
          continueFn == null ? void 0 : continueFn();
          promiseReject(value);
        }
      };
      const pause = () => {
        return new Promise((continueResolve) => {
          continueFn = (value) => {
            const canContinue = isResolved || !shouldPause();
            if (canContinue) {
              continueResolve(value);
            }
            return canContinue;
          };
          config.onPause == null ? void 0 : config.onPause();
        }).then(() => {
          continueFn = void 0;
          if (!isResolved) {
            config.onContinue == null ? void 0 : config.onContinue();
          }
        });
      };
      const run = () => {
        if (isResolved) {
          return;
        }
        let promiseOrValue;
        try {
          promiseOrValue = config.fn();
        } catch (error) {
          promiseOrValue = Promise.reject(error);
        }
        Promise.resolve(promiseOrValue).then(resolve).catch((error) => {
          var _config$retry, _config$retryDelay;
          if (isResolved) {
            return;
          }
          const retry = (_config$retry = config.retry) != null ? _config$retry : 3;
          const retryDelay = (_config$retryDelay = config.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;
          const delay = typeof retryDelay === "function" ? retryDelay(failureCount, error) : retryDelay;
          const shouldRetry = retry === true || typeof retry === "number" && failureCount < retry || typeof retry === "function" && retry(failureCount, error);
          if (isRetryCancelled || !shouldRetry) {
            reject(error);
            return;
          }
          failureCount++;
          config.onFail == null ? void 0 : config.onFail(failureCount, error);
          utils.sleep(delay).then(() => {
            if (shouldPause()) {
              return pause();
            }
            return;
          }).then(() => {
            if (isRetryCancelled) {
              reject(error);
            } else {
              run();
            }
          });
        });
      };
      if (canFetch(config.networkMode)) {
        run();
      } else {
        pause().then(run);
      }
      return {
        promise,
        cancel,
        continue: () => {
          const didContinue = continueFn == null ? void 0 : continueFn();
          return didContinue ? promise : Promise.resolve();
        },
        cancelRetry,
        continueRetry
      };
    }
    exports.CancelledError = CancelledError;
    exports.canFetch = canFetch;
    exports.createRetryer = createRetryer;
    exports.isCancelledError = isCancelledError;
  }
});

// node_modules/@tanstack/query-core/build/lib/logger.js
var require_logger = __commonJS({
  "node_modules/@tanstack/query-core/build/lib/logger.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var defaultLogger = console;
    exports.defaultLogger = defaultLogger;
  }
});

// node_modules/@tanstack/query-core/build/lib/notifyManager.js
var require_notifyManager = __commonJS({
  "node_modules/@tanstack/query-core/build/lib/notifyManager.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_utils();
    function createNotifyManager() {
      let queue = [];
      let transactions = 0;
      let notifyFn = (callback) => {
        callback();
      };
      let batchNotifyFn = (callback) => {
        callback();
      };
      const batch = (callback) => {
        let result;
        transactions++;
        try {
          result = callback();
        } finally {
          transactions--;
          if (!transactions) {
            flush();
          }
        }
        return result;
      };
      const schedule = (callback) => {
        if (transactions) {
          queue.push(callback);
        } else {
          utils.scheduleMicrotask(() => {
            notifyFn(callback);
          });
        }
      };
      const batchCalls = (callback) => {
        return (...args) => {
          schedule(() => {
            callback(...args);
          });
        };
      };
      const flush = () => {
        const originalQueue = queue;
        queue = [];
        if (originalQueue.length) {
          utils.scheduleMicrotask(() => {
            batchNotifyFn(() => {
              originalQueue.forEach((callback) => {
                notifyFn(callback);
              });
            });
          });
        }
      };
      const setNotifyFunction = (fn) => {
        notifyFn = fn;
      };
      const setBatchNotifyFunction = (fn) => {
        batchNotifyFn = fn;
      };
      return {
        batch,
        batchCalls,
        schedule,
        setNotifyFunction,
        setBatchNotifyFunction
      };
    }
    var notifyManager = createNotifyManager();
    exports.createNotifyManager = createNotifyManager;
    exports.notifyManager = notifyManager;
  }
});

// node_modules/@tanstack/query-core/build/lib/removable.js
var require_removable = __commonJS({
  "node_modules/@tanstack/query-core/build/lib/removable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_utils();
    var Removable = class {
      destroy() {
        this.clearGcTimeout();
      }
      scheduleGc() {
        this.clearGcTimeout();
        if (utils.isValidTimeout(this.cacheTime)) {
          this.gcTimeout = setTimeout(() => {
            this.optionalRemove();
          }, this.cacheTime);
        }
      }
      updateCacheTime(newCacheTime) {
        this.cacheTime = Math.max(this.cacheTime || 0, newCacheTime != null ? newCacheTime : utils.isServer ? Infinity : 5 * 60 * 1e3);
      }
      clearGcTimeout() {
        if (this.gcTimeout) {
          clearTimeout(this.gcTimeout);
          this.gcTimeout = void 0;
        }
      }
    };
    exports.Removable = Removable;
  }
});

// node_modules/@tanstack/query-core/build/lib/query.js
var require_query = __commonJS({
  "node_modules/@tanstack/query-core/build/lib/query.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_utils();
    var logger = require_logger();
    var notifyManager = require_notifyManager();
    var retryer = require_retryer();
    var removable = require_removable();
    var Query = class extends removable.Removable {
      constructor(config) {
        super();
        this.abortSignalConsumed = false;
        this.defaultOptions = config.defaultOptions;
        this.setOptions(config.options);
        this.observers = [];
        this.cache = config.cache;
        this.logger = config.logger || logger.defaultLogger;
        this.queryKey = config.queryKey;
        this.queryHash = config.queryHash;
        this.initialState = config.state || getDefaultState(this.options);
        this.state = this.initialState;
        this.scheduleGc();
      }
      get meta() {
        return this.options.meta;
      }
      setOptions(options) {
        this.options = {
          ...this.defaultOptions,
          ...options
        };
        this.updateCacheTime(this.options.cacheTime);
      }
      optionalRemove() {
        if (!this.observers.length && this.state.fetchStatus === "idle") {
          this.cache.remove(this);
        }
      }
      setData(newData, options) {
        const data = utils.replaceData(this.state.data, newData, this.options);
        this.dispatch({
          data,
          type: "success",
          dataUpdatedAt: options == null ? void 0 : options.updatedAt,
          manual: options == null ? void 0 : options.manual
        });
        return data;
      }
      setState(state, setStateOptions) {
        this.dispatch({
          type: "setState",
          state,
          setStateOptions
        });
      }
      cancel(options) {
        var _this$retryer;
        const promise = this.promise;
        (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.cancel(options);
        return promise ? promise.then(utils.noop).catch(utils.noop) : Promise.resolve();
      }
      destroy() {
        super.destroy();
        this.cancel({
          silent: true
        });
      }
      reset() {
        this.destroy();
        this.setState(this.initialState);
      }
      isActive() {
        return this.observers.some((observer) => observer.options.enabled !== false);
      }
      isDisabled() {
        return this.getObserversCount() > 0 && !this.isActive();
      }
      isStale() {
        return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some((observer) => observer.getCurrentResult().isStale);
      }
      isStaleByTime(staleTime = 0) {
        return this.state.isInvalidated || !this.state.dataUpdatedAt || !utils.timeUntilStale(this.state.dataUpdatedAt, staleTime);
      }
      onFocus() {
        var _this$retryer2;
        const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus());
        if (observer) {
          observer.refetch({
            cancelRefetch: false
          });
        }
        (_this$retryer2 = this.retryer) == null ? void 0 : _this$retryer2.continue();
      }
      onOnline() {
        var _this$retryer3;
        const observer = this.observers.find((x) => x.shouldFetchOnReconnect());
        if (observer) {
          observer.refetch({
            cancelRefetch: false
          });
        }
        (_this$retryer3 = this.retryer) == null ? void 0 : _this$retryer3.continue();
      }
      addObserver(observer) {
        if (!this.observers.includes(observer)) {
          this.observers.push(observer);
          this.clearGcTimeout();
          this.cache.notify({
            type: "observerAdded",
            query: this,
            observer
          });
        }
      }
      removeObserver(observer) {
        if (this.observers.includes(observer)) {
          this.observers = this.observers.filter((x) => x !== observer);
          if (!this.observers.length) {
            if (this.retryer) {
              if (this.abortSignalConsumed) {
                this.retryer.cancel({
                  revert: true
                });
              } else {
                this.retryer.cancelRetry();
              }
            }
            this.scheduleGc();
          }
          this.cache.notify({
            type: "observerRemoved",
            query: this,
            observer
          });
        }
      }
      getObserversCount() {
        return this.observers.length;
      }
      invalidate() {
        if (!this.state.isInvalidated) {
          this.dispatch({
            type: "invalidate"
          });
        }
      }
      fetch(options, fetchOptions) {
        var _this$options$behavio, _context$fetchOptions;
        if (this.state.fetchStatus !== "idle") {
          if (this.state.dataUpdatedAt && fetchOptions != null && fetchOptions.cancelRefetch) {
            this.cancel({
              silent: true
            });
          } else if (this.promise) {
            var _this$retryer4;
            (_this$retryer4 = this.retryer) == null ? void 0 : _this$retryer4.continueRetry();
            return this.promise;
          }
        }
        if (options) {
          this.setOptions(options);
        }
        if (!this.options.queryFn) {
          const observer = this.observers.find((x) => x.options.queryFn);
          if (observer) {
            this.setOptions(observer.options);
          }
        }
        if (true) {
          if (!Array.isArray(this.options.queryKey)) {
            this.logger.error("As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']");
          }
        }
        const abortController = utils.getAbortController();
        const queryFnContext = {
          queryKey: this.queryKey,
          pageParam: void 0,
          meta: this.meta
        };
        const addSignalProperty = (object) => {
          Object.defineProperty(object, "signal", {
            enumerable: true,
            get: () => {
              if (abortController) {
                this.abortSignalConsumed = true;
                return abortController.signal;
              }
              return void 0;
            }
          });
        };
        addSignalProperty(queryFnContext);
        const fetchFn = () => {
          if (!this.options.queryFn) {
            return Promise.reject("Missing queryFn for queryKey '" + this.options.queryHash + "'");
          }
          this.abortSignalConsumed = false;
          return this.options.queryFn(queryFnContext);
        };
        const context = {
          fetchOptions,
          options: this.options,
          queryKey: this.queryKey,
          state: this.state,
          fetchFn
        };
        addSignalProperty(context);
        (_this$options$behavio = this.options.behavior) == null ? void 0 : _this$options$behavio.onFetch(context);
        this.revertState = this.state;
        if (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((_context$fetchOptions = context.fetchOptions) == null ? void 0 : _context$fetchOptions.meta)) {
          var _context$fetchOptions2;
          this.dispatch({
            type: "fetch",
            meta: (_context$fetchOptions2 = context.fetchOptions) == null ? void 0 : _context$fetchOptions2.meta
          });
        }
        const onError = (error) => {
          if (!(retryer.isCancelledError(error) && error.silent)) {
            this.dispatch({
              type: "error",
              error
            });
          }
          if (!retryer.isCancelledError(error)) {
            var _this$cache$config$on, _this$cache$config, _this$cache$config$on2, _this$cache$config2;
            (_this$cache$config$on = (_this$cache$config = this.cache.config).onError) == null ? void 0 : _this$cache$config$on.call(_this$cache$config, error, this);
            (_this$cache$config$on2 = (_this$cache$config2 = this.cache.config).onSettled) == null ? void 0 : _this$cache$config$on2.call(_this$cache$config2, this.state.data, error, this);
            if (true) {
              this.logger.error(error);
            }
          }
          if (!this.isFetchingOptimistic) {
            this.scheduleGc();
          }
          this.isFetchingOptimistic = false;
        };
        this.retryer = retryer.createRetryer({
          fn: context.fetchFn,
          abort: abortController == null ? void 0 : abortController.abort.bind(abortController),
          onSuccess: (data) => {
            var _this$cache$config$on3, _this$cache$config3, _this$cache$config$on4, _this$cache$config4;
            if (typeof data === "undefined") {
              if (true) {
                this.logger.error("Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: " + this.queryHash);
              }
              onError(new Error(this.queryHash + " data is undefined"));
              return;
            }
            this.setData(data);
            (_this$cache$config$on3 = (_this$cache$config3 = this.cache.config).onSuccess) == null ? void 0 : _this$cache$config$on3.call(_this$cache$config3, data, this);
            (_this$cache$config$on4 = (_this$cache$config4 = this.cache.config).onSettled) == null ? void 0 : _this$cache$config$on4.call(_this$cache$config4, data, this.state.error, this);
            if (!this.isFetchingOptimistic) {
              this.scheduleGc();
            }
            this.isFetchingOptimistic = false;
          },
          onError,
          onFail: (failureCount, error) => {
            this.dispatch({
              type: "failed",
              failureCount,
              error
            });
          },
          onPause: () => {
            this.dispatch({
              type: "pause"
            });
          },
          onContinue: () => {
            this.dispatch({
              type: "continue"
            });
          },
          retry: context.options.retry,
          retryDelay: context.options.retryDelay,
          networkMode: context.options.networkMode
        });
        this.promise = this.retryer.promise;
        return this.promise;
      }
      dispatch(action) {
        const reducer = (state) => {
          var _action$meta, _action$dataUpdatedAt;
          switch (action.type) {
            case "failed":
              return {
                ...state,
                fetchFailureCount: action.failureCount,
                fetchFailureReason: action.error
              };
            case "pause":
              return {
                ...state,
                fetchStatus: "paused"
              };
            case "continue":
              return {
                ...state,
                fetchStatus: "fetching"
              };
            case "fetch":
              return {
                ...state,
                fetchFailureCount: 0,
                fetchFailureReason: null,
                fetchMeta: (_action$meta = action.meta) != null ? _action$meta : null,
                fetchStatus: retryer.canFetch(this.options.networkMode) ? "fetching" : "paused",
                ...!state.dataUpdatedAt && {
                  error: null,
                  status: "loading"
                }
              };
            case "success":
              return {
                ...state,
                data: action.data,
                dataUpdateCount: state.dataUpdateCount + 1,
                dataUpdatedAt: (_action$dataUpdatedAt = action.dataUpdatedAt) != null ? _action$dataUpdatedAt : Date.now(),
                error: null,
                isInvalidated: false,
                status: "success",
                ...!action.manual && {
                  fetchStatus: "idle",
                  fetchFailureCount: 0,
                  fetchFailureReason: null
                }
              };
            case "error":
              const error = action.error;
              if (retryer.isCancelledError(error) && error.revert && this.revertState) {
                return {
                  ...this.revertState,
                  fetchStatus: "idle"
                };
              }
              return {
                ...state,
                error,
                errorUpdateCount: state.errorUpdateCount + 1,
                errorUpdatedAt: Date.now(),
                fetchFailureCount: state.fetchFailureCount + 1,
                fetchFailureReason: error,
                fetchStatus: "idle",
                status: "error"
              };
            case "invalidate":
              return {
                ...state,
                isInvalidated: true
              };
            case "setState":
              return {
                ...state,
                ...action.state
              };
          }
        };
        this.state = reducer(this.state);
        notifyManager.notifyManager.batch(() => {
          this.observers.forEach((observer) => {
            observer.onQueryUpdate(action);
          });
          this.cache.notify({
            query: this,
            type: "updated",
            action
          });
        });
      }
    };
    function getDefaultState(options) {
      const data = typeof options.initialData === "function" ? options.initialData() : options.initialData;
      const hasData = typeof data !== "undefined";
      const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === "function" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;
      return {
        data,
        dataUpdateCount: 0,
        dataUpdatedAt: hasData ? initialDataUpdatedAt != null ? initialDataUpdatedAt : Date.now() : 0,
        error: null,
        errorUpdateCount: 0,
        errorUpdatedAt: 0,
        fetchFailureCount: 0,
        fetchFailureReason: null,
        fetchMeta: null,
        isInvalidated: false,
        status: hasData ? "success" : "loading",
        fetchStatus: "idle"
      };
    }
    exports.Query = Query;
  }
});

// node_modules/@tanstack/query-core/build/lib/queryCache.js
var require_queryCache = __commonJS({
  "node_modules/@tanstack/query-core/build/lib/queryCache.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_utils();
    var query = require_query();
    var notifyManager = require_notifyManager();
    var subscribable = require_subscribable();
    var QueryCache = class extends subscribable.Subscribable {
      constructor(config) {
        super();
        this.config = config || {};
        this.queries = [];
        this.queriesMap = {};
      }
      build(client, options, state) {
        var _options$queryHash;
        const queryKey = options.queryKey;
        const queryHash = (_options$queryHash = options.queryHash) != null ? _options$queryHash : utils.hashQueryKeyByOptions(queryKey, options);
        let query$1 = this.get(queryHash);
        if (!query$1) {
          query$1 = new query.Query({
            cache: this,
            logger: client.getLogger(),
            queryKey,
            queryHash,
            options: client.defaultQueryOptions(options),
            state,
            defaultOptions: client.getQueryDefaults(queryKey)
          });
          this.add(query$1);
        }
        return query$1;
      }
      add(query2) {
        if (!this.queriesMap[query2.queryHash]) {
          this.queriesMap[query2.queryHash] = query2;
          this.queries.push(query2);
          this.notify({
            type: "added",
            query: query2
          });
        }
      }
      remove(query2) {
        const queryInMap = this.queriesMap[query2.queryHash];
        if (queryInMap) {
          query2.destroy();
          this.queries = this.queries.filter((x) => x !== query2);
          if (queryInMap === query2) {
            delete this.queriesMap[query2.queryHash];
          }
          this.notify({
            type: "removed",
            query: query2
          });
        }
      }
      clear() {
        notifyManager.notifyManager.batch(() => {
          this.queries.forEach((query2) => {
            this.remove(query2);
          });
        });
      }
      get(queryHash) {
        return this.queriesMap[queryHash];
      }
      getAll() {
        return this.queries;
      }
      find(arg1, arg2) {
        const [filters] = utils.parseFilterArgs(arg1, arg2);
        if (typeof filters.exact === "undefined") {
          filters.exact = true;
        }
        return this.queries.find((query2) => utils.matchQuery(filters, query2));
      }
      findAll(arg1, arg2) {
        const [filters] = utils.parseFilterArgs(arg1, arg2);
        return Object.keys(filters).length > 0 ? this.queries.filter((query2) => utils.matchQuery(filters, query2)) : this.queries;
      }
      notify(event) {
        notifyManager.notifyManager.batch(() => {
          this.listeners.forEach(({
            listener
          }) => {
            listener(event);
          });
        });
      }
      onFocus() {
        notifyManager.notifyManager.batch(() => {
          this.queries.forEach((query2) => {
            query2.onFocus();
          });
        });
      }
      onOnline() {
        notifyManager.notifyManager.batch(() => {
          this.queries.forEach((query2) => {
            query2.onOnline();
          });
        });
      }
    };
    exports.QueryCache = QueryCache;
  }
});

// node_modules/@tanstack/query-core/build/lib/mutation.js
var require_mutation = __commonJS({
  "node_modules/@tanstack/query-core/build/lib/mutation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var logger = require_logger();
    var notifyManager = require_notifyManager();
    var removable = require_removable();
    var retryer = require_retryer();
    var Mutation = class extends removable.Removable {
      constructor(config) {
        super();
        this.defaultOptions = config.defaultOptions;
        this.mutationId = config.mutationId;
        this.mutationCache = config.mutationCache;
        this.logger = config.logger || logger.defaultLogger;
        this.observers = [];
        this.state = config.state || getDefaultState();
        this.setOptions(config.options);
        this.scheduleGc();
      }
      setOptions(options) {
        this.options = {
          ...this.defaultOptions,
          ...options
        };
        this.updateCacheTime(this.options.cacheTime);
      }
      get meta() {
        return this.options.meta;
      }
      setState(state) {
        this.dispatch({
          type: "setState",
          state
        });
      }
      addObserver(observer) {
        if (!this.observers.includes(observer)) {
          this.observers.push(observer);
          this.clearGcTimeout();
          this.mutationCache.notify({
            type: "observerAdded",
            mutation: this,
            observer
          });
        }
      }
      removeObserver(observer) {
        this.observers = this.observers.filter((x) => x !== observer);
        this.scheduleGc();
        this.mutationCache.notify({
          type: "observerRemoved",
          mutation: this,
          observer
        });
      }
      optionalRemove() {
        if (!this.observers.length) {
          if (this.state.status === "loading") {
            this.scheduleGc();
          } else {
            this.mutationCache.remove(this);
          }
        }
      }
      continue() {
        var _this$retryer$continu, _this$retryer;
        return (_this$retryer$continu = (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.continue()) != null ? _this$retryer$continu : this.execute();
      }
      async execute() {
        const executeMutation = () => {
          var _this$options$retry;
          this.retryer = retryer.createRetryer({
            fn: () => {
              if (!this.options.mutationFn) {
                return Promise.reject("No mutationFn found");
              }
              return this.options.mutationFn(this.state.variables);
            },
            onFail: (failureCount, error) => {
              this.dispatch({
                type: "failed",
                failureCount,
                error
              });
            },
            onPause: () => {
              this.dispatch({
                type: "pause"
              });
            },
            onContinue: () => {
              this.dispatch({
                type: "continue"
              });
            },
            retry: (_this$options$retry = this.options.retry) != null ? _this$options$retry : 0,
            retryDelay: this.options.retryDelay,
            networkMode: this.options.networkMode
          });
          return this.retryer.promise;
        };
        const restored = this.state.status === "loading";
        try {
          var _this$mutationCache$c3, _this$mutationCache$c4, _this$options$onSucce, _this$options2, _this$mutationCache$c5, _this$mutationCache$c6, _this$options$onSettl, _this$options3;
          if (!restored) {
            var _this$mutationCache$c, _this$mutationCache$c2, _this$options$onMutat, _this$options;
            this.dispatch({
              type: "loading",
              variables: this.options.variables
            });
            await ((_this$mutationCache$c = (_this$mutationCache$c2 = this.mutationCache.config).onMutate) == null ? void 0 : _this$mutationCache$c.call(_this$mutationCache$c2, this.state.variables, this));
            const context = await ((_this$options$onMutat = (_this$options = this.options).onMutate) == null ? void 0 : _this$options$onMutat.call(_this$options, this.state.variables));
            if (context !== this.state.context) {
              this.dispatch({
                type: "loading",
                context,
                variables: this.state.variables
              });
            }
          }
          const data = await executeMutation();
          await ((_this$mutationCache$c3 = (_this$mutationCache$c4 = this.mutationCache.config).onSuccess) == null ? void 0 : _this$mutationCache$c3.call(_this$mutationCache$c4, data, this.state.variables, this.state.context, this));
          await ((_this$options$onSucce = (_this$options2 = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options2, data, this.state.variables, this.state.context));
          await ((_this$mutationCache$c5 = (_this$mutationCache$c6 = this.mutationCache.config).onSettled) == null ? void 0 : _this$mutationCache$c5.call(_this$mutationCache$c6, data, null, this.state.variables, this.state.context, this));
          await ((_this$options$onSettl = (_this$options3 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options3, data, null, this.state.variables, this.state.context));
          this.dispatch({
            type: "success",
            data
          });
          return data;
        } catch (error) {
          try {
            var _this$mutationCache$c7, _this$mutationCache$c8, _this$options$onError, _this$options4, _this$mutationCache$c9, _this$mutationCache$c10, _this$options$onSettl2, _this$options5;
            await ((_this$mutationCache$c7 = (_this$mutationCache$c8 = this.mutationCache.config).onError) == null ? void 0 : _this$mutationCache$c7.call(_this$mutationCache$c8, error, this.state.variables, this.state.context, this));
            if (true) {
              this.logger.error(error);
            }
            await ((_this$options$onError = (_this$options4 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options4, error, this.state.variables, this.state.context));
            await ((_this$mutationCache$c9 = (_this$mutationCache$c10 = this.mutationCache.config).onSettled) == null ? void 0 : _this$mutationCache$c9.call(_this$mutationCache$c10, void 0, error, this.state.variables, this.state.context, this));
            await ((_this$options$onSettl2 = (_this$options5 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options5, void 0, error, this.state.variables, this.state.context));
            throw error;
          } finally {
            this.dispatch({
              type: "error",
              error
            });
          }
        }
      }
      dispatch(action) {
        const reducer = (state) => {
          switch (action.type) {
            case "failed":
              return {
                ...state,
                failureCount: action.failureCount,
                failureReason: action.error
              };
            case "pause":
              return {
                ...state,
                isPaused: true
              };
            case "continue":
              return {
                ...state,
                isPaused: false
              };
            case "loading":
              return {
                ...state,
                context: action.context,
                data: void 0,
                failureCount: 0,
                failureReason: null,
                error: null,
                isPaused: !retryer.canFetch(this.options.networkMode),
                status: "loading",
                variables: action.variables
              };
            case "success":
              return {
                ...state,
                data: action.data,
                failureCount: 0,
                failureReason: null,
                error: null,
                status: "success",
                isPaused: false
              };
            case "error":
              return {
                ...state,
                data: void 0,
                error: action.error,
                failureCount: state.failureCount + 1,
                failureReason: action.error,
                isPaused: false,
                status: "error"
              };
            case "setState":
              return {
                ...state,
                ...action.state
              };
          }
        };
        this.state = reducer(this.state);
        notifyManager.notifyManager.batch(() => {
          this.observers.forEach((observer) => {
            observer.onMutationUpdate(action);
          });
          this.mutationCache.notify({
            mutation: this,
            type: "updated",
            action
          });
        });
      }
    };
    function getDefaultState() {
      return {
        context: void 0,
        data: void 0,
        error: null,
        failureCount: 0,
        failureReason: null,
        isPaused: false,
        status: "idle",
        variables: void 0
      };
    }
    exports.Mutation = Mutation;
    exports.getDefaultState = getDefaultState;
  }
});

// node_modules/@tanstack/query-core/build/lib/mutationCache.js
var require_mutationCache = __commonJS({
  "node_modules/@tanstack/query-core/build/lib/mutationCache.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var notifyManager = require_notifyManager();
    var mutation = require_mutation();
    var utils = require_utils();
    var subscribable = require_subscribable();
    var MutationCache = class extends subscribable.Subscribable {
      constructor(config) {
        super();
        this.config = config || {};
        this.mutations = [];
        this.mutationId = 0;
      }
      build(client, options, state) {
        const mutation$1 = new mutation.Mutation({
          mutationCache: this,
          logger: client.getLogger(),
          mutationId: ++this.mutationId,
          options: client.defaultMutationOptions(options),
          state,
          defaultOptions: options.mutationKey ? client.getMutationDefaults(options.mutationKey) : void 0
        });
        this.add(mutation$1);
        return mutation$1;
      }
      add(mutation2) {
        this.mutations.push(mutation2);
        this.notify({
          type: "added",
          mutation: mutation2
        });
      }
      remove(mutation2) {
        this.mutations = this.mutations.filter((x) => x !== mutation2);
        this.notify({
          type: "removed",
          mutation: mutation2
        });
      }
      clear() {
        notifyManager.notifyManager.batch(() => {
          this.mutations.forEach((mutation2) => {
            this.remove(mutation2);
          });
        });
      }
      getAll() {
        return this.mutations;
      }
      find(filters) {
        if (typeof filters.exact === "undefined") {
          filters.exact = true;
        }
        return this.mutations.find((mutation2) => utils.matchMutation(filters, mutation2));
      }
      findAll(filters) {
        return this.mutations.filter((mutation2) => utils.matchMutation(filters, mutation2));
      }
      notify(event) {
        notifyManager.notifyManager.batch(() => {
          this.listeners.forEach(({
            listener
          }) => {
            listener(event);
          });
        });
      }
      resumePausedMutations() {
        var _this$resuming;
        this.resuming = ((_this$resuming = this.resuming) != null ? _this$resuming : Promise.resolve()).then(() => {
          const pausedMutations = this.mutations.filter((x) => x.state.isPaused);
          return notifyManager.notifyManager.batch(() => pausedMutations.reduce((promise, mutation2) => promise.then(() => mutation2.continue().catch(utils.noop)), Promise.resolve()));
        }).then(() => {
          this.resuming = void 0;
        });
        return this.resuming;
      }
    };
    exports.MutationCache = MutationCache;
  }
});

// node_modules/@tanstack/query-core/build/lib/infiniteQueryBehavior.js
var require_infiniteQueryBehavior = __commonJS({
  "node_modules/@tanstack/query-core/build/lib/infiniteQueryBehavior.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function infiniteQueryBehavior() {
      return {
        onFetch: (context) => {
          context.fetchFn = () => {
            var _context$fetchOptions, _context$fetchOptions2, _context$fetchOptions3, _context$fetchOptions4, _context$state$data, _context$state$data2;
            const refetchPage = (_context$fetchOptions = context.fetchOptions) == null ? void 0 : (_context$fetchOptions2 = _context$fetchOptions.meta) == null ? void 0 : _context$fetchOptions2.refetchPage;
            const fetchMore = (_context$fetchOptions3 = context.fetchOptions) == null ? void 0 : (_context$fetchOptions4 = _context$fetchOptions3.meta) == null ? void 0 : _context$fetchOptions4.fetchMore;
            const pageParam = fetchMore == null ? void 0 : fetchMore.pageParam;
            const isFetchingNextPage = (fetchMore == null ? void 0 : fetchMore.direction) === "forward";
            const isFetchingPreviousPage = (fetchMore == null ? void 0 : fetchMore.direction) === "backward";
            const oldPages = ((_context$state$data = context.state.data) == null ? void 0 : _context$state$data.pages) || [];
            const oldPageParams = ((_context$state$data2 = context.state.data) == null ? void 0 : _context$state$data2.pageParams) || [];
            let newPageParams = oldPageParams;
            let cancelled = false;
            const addSignalProperty = (object) => {
              Object.defineProperty(object, "signal", {
                enumerable: true,
                get: () => {
                  var _context$signal;
                  if ((_context$signal = context.signal) != null && _context$signal.aborted) {
                    cancelled = true;
                  } else {
                    var _context$signal2;
                    (_context$signal2 = context.signal) == null ? void 0 : _context$signal2.addEventListener("abort", () => {
                      cancelled = true;
                    });
                  }
                  return context.signal;
                }
              });
            };
            const queryFn = context.options.queryFn || (() => Promise.reject("Missing queryFn for queryKey '" + context.options.queryHash + "'"));
            const buildNewPages = (pages, param, page, previous) => {
              newPageParams = previous ? [param, ...newPageParams] : [...newPageParams, param];
              return previous ? [page, ...pages] : [...pages, page];
            };
            const fetchPage = (pages, manual, param, previous) => {
              if (cancelled) {
                return Promise.reject("Cancelled");
              }
              if (typeof param === "undefined" && !manual && pages.length) {
                return Promise.resolve(pages);
              }
              const queryFnContext = {
                queryKey: context.queryKey,
                pageParam: param,
                meta: context.options.meta
              };
              addSignalProperty(queryFnContext);
              const queryFnResult = queryFn(queryFnContext);
              const promise2 = Promise.resolve(queryFnResult).then((page) => buildNewPages(pages, param, page, previous));
              return promise2;
            };
            let promise;
            if (!oldPages.length) {
              promise = fetchPage([]);
            } else if (isFetchingNextPage) {
              const manual = typeof pageParam !== "undefined";
              const param = manual ? pageParam : getNextPageParam(context.options, oldPages);
              promise = fetchPage(oldPages, manual, param);
            } else if (isFetchingPreviousPage) {
              const manual = typeof pageParam !== "undefined";
              const param = manual ? pageParam : getPreviousPageParam(context.options, oldPages);
              promise = fetchPage(oldPages, manual, param, true);
            } else {
              newPageParams = [];
              const manual = typeof context.options.getNextPageParam === "undefined";
              const shouldFetchFirstPage = refetchPage && oldPages[0] ? refetchPage(oldPages[0], 0, oldPages) : true;
              promise = shouldFetchFirstPage ? fetchPage([], manual, oldPageParams[0]) : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0]));
              for (let i = 1; i < oldPages.length; i++) {
                promise = promise.then((pages) => {
                  const shouldFetchNextPage = refetchPage && oldPages[i] ? refetchPage(oldPages[i], i, oldPages) : true;
                  if (shouldFetchNextPage) {
                    const param = manual ? oldPageParams[i] : getNextPageParam(context.options, pages);
                    return fetchPage(pages, manual, param);
                  }
                  return Promise.resolve(buildNewPages(pages, oldPageParams[i], oldPages[i]));
                });
              }
            }
            const finalPromise = promise.then((pages) => ({
              pages,
              pageParams: newPageParams
            }));
            return finalPromise;
          };
        }
      };
    }
    function getNextPageParam(options, pages) {
      return options.getNextPageParam == null ? void 0 : options.getNextPageParam(pages[pages.length - 1], pages);
    }
    function getPreviousPageParam(options, pages) {
      return options.getPreviousPageParam == null ? void 0 : options.getPreviousPageParam(pages[0], pages);
    }
    function hasNextPage(options, pages) {
      if (options.getNextPageParam && Array.isArray(pages)) {
        const nextPageParam = getNextPageParam(options, pages);
        return typeof nextPageParam !== "undefined" && nextPageParam !== null && nextPageParam !== false;
      }
      return;
    }
    function hasPreviousPage(options, pages) {
      if (options.getPreviousPageParam && Array.isArray(pages)) {
        const previousPageParam = getPreviousPageParam(options, pages);
        return typeof previousPageParam !== "undefined" && previousPageParam !== null && previousPageParam !== false;
      }
      return;
    }
    exports.getNextPageParam = getNextPageParam;
    exports.getPreviousPageParam = getPreviousPageParam;
    exports.hasNextPage = hasNextPage;
    exports.hasPreviousPage = hasPreviousPage;
    exports.infiniteQueryBehavior = infiniteQueryBehavior;
  }
});

// node_modules/@tanstack/query-core/build/lib/queryClient.js
var require_queryClient = __commonJS({
  "node_modules/@tanstack/query-core/build/lib/queryClient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_utils();
    var queryCache = require_queryCache();
    var mutationCache = require_mutationCache();
    var focusManager = require_focusManager();
    var onlineManager = require_onlineManager();
    var notifyManager = require_notifyManager();
    var infiniteQueryBehavior = require_infiniteQueryBehavior();
    var logger = require_logger();
    var QueryClient = class {
      constructor(config = {}) {
        this.queryCache = config.queryCache || new queryCache.QueryCache();
        this.mutationCache = config.mutationCache || new mutationCache.MutationCache();
        this.logger = config.logger || logger.defaultLogger;
        this.defaultOptions = config.defaultOptions || {};
        this.queryDefaults = [];
        this.mutationDefaults = [];
        this.mountCount = 0;
        if (config.logger) {
          this.logger.error("Passing a custom logger has been deprecated and will be removed in the next major version.");
        }
      }
      mount() {
        this.mountCount++;
        if (this.mountCount !== 1)
          return;
        this.unsubscribeFocus = focusManager.focusManager.subscribe(() => {
          if (focusManager.focusManager.isFocused()) {
            this.resumePausedMutations();
            this.queryCache.onFocus();
          }
        });
        this.unsubscribeOnline = onlineManager.onlineManager.subscribe(() => {
          if (onlineManager.onlineManager.isOnline()) {
            this.resumePausedMutations();
            this.queryCache.onOnline();
          }
        });
      }
      unmount() {
        var _this$unsubscribeFocu, _this$unsubscribeOnli;
        this.mountCount--;
        if (this.mountCount !== 0)
          return;
        (_this$unsubscribeFocu = this.unsubscribeFocus) == null ? void 0 : _this$unsubscribeFocu.call(this);
        this.unsubscribeFocus = void 0;
        (_this$unsubscribeOnli = this.unsubscribeOnline) == null ? void 0 : _this$unsubscribeOnli.call(this);
        this.unsubscribeOnline = void 0;
      }
      isFetching(arg1, arg2) {
        const [filters] = utils.parseFilterArgs(arg1, arg2);
        filters.fetchStatus = "fetching";
        return this.queryCache.findAll(filters).length;
      }
      isMutating(filters) {
        return this.mutationCache.findAll({
          ...filters,
          fetching: true
        }).length;
      }
      getQueryData(queryKey, filters) {
        var _this$queryCache$find;
        return (_this$queryCache$find = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find.state.data;
      }
      ensureQueryData(arg1, arg2, arg3) {
        const parsedOptions = utils.parseQueryArgs(arg1, arg2, arg3);
        const cachedData = this.getQueryData(parsedOptions.queryKey);
        return cachedData ? Promise.resolve(cachedData) : this.fetchQuery(parsedOptions);
      }
      getQueriesData(queryKeyOrFilters) {
        return this.getQueryCache().findAll(queryKeyOrFilters).map(({
          queryKey,
          state
        }) => {
          const data = state.data;
          return [queryKey, data];
        });
      }
      setQueryData(queryKey, updater, options) {
        const query = this.queryCache.find(queryKey);
        const prevData = query == null ? void 0 : query.state.data;
        const data = utils.functionalUpdate(updater, prevData);
        if (typeof data === "undefined") {
          return void 0;
        }
        const parsedOptions = utils.parseQueryArgs(queryKey);
        const defaultedOptions = this.defaultQueryOptions(parsedOptions);
        return this.queryCache.build(this, defaultedOptions).setData(data, {
          ...options,
          manual: true
        });
      }
      setQueriesData(queryKeyOrFilters, updater, options) {
        return notifyManager.notifyManager.batch(() => this.getQueryCache().findAll(queryKeyOrFilters).map(({
          queryKey
        }) => [queryKey, this.setQueryData(queryKey, updater, options)]));
      }
      getQueryState(queryKey, filters) {
        var _this$queryCache$find2;
        return (_this$queryCache$find2 = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find2.state;
      }
      removeQueries(arg1, arg2) {
        const [filters] = utils.parseFilterArgs(arg1, arg2);
        const queryCache2 = this.queryCache;
        notifyManager.notifyManager.batch(() => {
          queryCache2.findAll(filters).forEach((query) => {
            queryCache2.remove(query);
          });
        });
      }
      resetQueries(arg1, arg2, arg3) {
        const [filters, options] = utils.parseFilterArgs(arg1, arg2, arg3);
        const queryCache2 = this.queryCache;
        const refetchFilters = {
          type: "active",
          ...filters
        };
        return notifyManager.notifyManager.batch(() => {
          queryCache2.findAll(filters).forEach((query) => {
            query.reset();
          });
          return this.refetchQueries(refetchFilters, options);
        });
      }
      cancelQueries(arg1, arg2, arg3) {
        const [filters, cancelOptions = {}] = utils.parseFilterArgs(arg1, arg2, arg3);
        if (typeof cancelOptions.revert === "undefined") {
          cancelOptions.revert = true;
        }
        const promises = notifyManager.notifyManager.batch(() => this.queryCache.findAll(filters).map((query) => query.cancel(cancelOptions)));
        return Promise.all(promises).then(utils.noop).catch(utils.noop);
      }
      invalidateQueries(arg1, arg2, arg3) {
        const [filters, options] = utils.parseFilterArgs(arg1, arg2, arg3);
        return notifyManager.notifyManager.batch(() => {
          var _ref, _filters$refetchType;
          this.queryCache.findAll(filters).forEach((query) => {
            query.invalidate();
          });
          if (filters.refetchType === "none") {
            return Promise.resolve();
          }
          const refetchFilters = {
            ...filters,
            type: (_ref = (_filters$refetchType = filters.refetchType) != null ? _filters$refetchType : filters.type) != null ? _ref : "active"
          };
          return this.refetchQueries(refetchFilters, options);
        });
      }
      refetchQueries(arg1, arg2, arg3) {
        const [filters, options] = utils.parseFilterArgs(arg1, arg2, arg3);
        const promises = notifyManager.notifyManager.batch(() => this.queryCache.findAll(filters).filter((query) => !query.isDisabled()).map((query) => {
          var _options$cancelRefetc;
          return query.fetch(void 0, {
            ...options,
            cancelRefetch: (_options$cancelRefetc = options == null ? void 0 : options.cancelRefetch) != null ? _options$cancelRefetc : true,
            meta: {
              refetchPage: filters.refetchPage
            }
          });
        }));
        let promise = Promise.all(promises).then(utils.noop);
        if (!(options != null && options.throwOnError)) {
          promise = promise.catch(utils.noop);
        }
        return promise;
      }
      fetchQuery(arg1, arg2, arg3) {
        const parsedOptions = utils.parseQueryArgs(arg1, arg2, arg3);
        const defaultedOptions = this.defaultQueryOptions(parsedOptions);
        if (typeof defaultedOptions.retry === "undefined") {
          defaultedOptions.retry = false;
        }
        const query = this.queryCache.build(this, defaultedOptions);
        return query.isStaleByTime(defaultedOptions.staleTime) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);
      }
      prefetchQuery(arg1, arg2, arg3) {
        return this.fetchQuery(arg1, arg2, arg3).then(utils.noop).catch(utils.noop);
      }
      fetchInfiniteQuery(arg1, arg2, arg3) {
        const parsedOptions = utils.parseQueryArgs(arg1, arg2, arg3);
        parsedOptions.behavior = infiniteQueryBehavior.infiniteQueryBehavior();
        return this.fetchQuery(parsedOptions);
      }
      prefetchInfiniteQuery(arg1, arg2, arg3) {
        return this.fetchInfiniteQuery(arg1, arg2, arg3).then(utils.noop).catch(utils.noop);
      }
      resumePausedMutations() {
        return this.mutationCache.resumePausedMutations();
      }
      getQueryCache() {
        return this.queryCache;
      }
      getMutationCache() {
        return this.mutationCache;
      }
      getLogger() {
        return this.logger;
      }
      getDefaultOptions() {
        return this.defaultOptions;
      }
      setDefaultOptions(options) {
        this.defaultOptions = options;
      }
      setQueryDefaults(queryKey, options) {
        const result = this.queryDefaults.find((x) => utils.hashQueryKey(queryKey) === utils.hashQueryKey(x.queryKey));
        if (result) {
          result.defaultOptions = options;
        } else {
          this.queryDefaults.push({
            queryKey,
            defaultOptions: options
          });
        }
      }
      getQueryDefaults(queryKey) {
        if (!queryKey) {
          return void 0;
        }
        const firstMatchingDefaults = this.queryDefaults.find((x) => utils.partialMatchKey(queryKey, x.queryKey));
        if (true) {
          const matchingDefaults = this.queryDefaults.filter((x) => utils.partialMatchKey(queryKey, x.queryKey));
          if (matchingDefaults.length > 1) {
            this.logger.error("[QueryClient] Several query defaults match with key '" + JSON.stringify(queryKey) + "'. The first matching query defaults are used. Please check how query defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetquerydefaults.");
          }
        }
        return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;
      }
      setMutationDefaults(mutationKey, options) {
        const result = this.mutationDefaults.find((x) => utils.hashQueryKey(mutationKey) === utils.hashQueryKey(x.mutationKey));
        if (result) {
          result.defaultOptions = options;
        } else {
          this.mutationDefaults.push({
            mutationKey,
            defaultOptions: options
          });
        }
      }
      getMutationDefaults(mutationKey) {
        if (!mutationKey) {
          return void 0;
        }
        const firstMatchingDefaults = this.mutationDefaults.find((x) => utils.partialMatchKey(mutationKey, x.mutationKey));
        if (true) {
          const matchingDefaults = this.mutationDefaults.filter((x) => utils.partialMatchKey(mutationKey, x.mutationKey));
          if (matchingDefaults.length > 1) {
            this.logger.error("[QueryClient] Several mutation defaults match with key '" + JSON.stringify(mutationKey) + "'. The first matching mutation defaults are used. Please check how mutation defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetmutationdefaults.");
          }
        }
        return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;
      }
      defaultQueryOptions(options) {
        if (options != null && options._defaulted) {
          return options;
        }
        const defaultedOptions = {
          ...this.defaultOptions.queries,
          ...this.getQueryDefaults(options == null ? void 0 : options.queryKey),
          ...options,
          _defaulted: true
        };
        if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {
          defaultedOptions.queryHash = utils.hashQueryKeyByOptions(defaultedOptions.queryKey, defaultedOptions);
        }
        if (typeof defaultedOptions.refetchOnReconnect === "undefined") {
          defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== "always";
        }
        if (typeof defaultedOptions.useErrorBoundary === "undefined") {
          defaultedOptions.useErrorBoundary = !!defaultedOptions.suspense;
        }
        return defaultedOptions;
      }
      defaultMutationOptions(options) {
        if (options != null && options._defaulted) {
          return options;
        }
        return {
          ...this.defaultOptions.mutations,
          ...this.getMutationDefaults(options == null ? void 0 : options.mutationKey),
          ...options,
          _defaulted: true
        };
      }
      clear() {
        this.queryCache.clear();
        this.mutationCache.clear();
      }
    };
    exports.QueryClient = QueryClient;
  }
});

// node_modules/@tanstack/query-core/build/lib/queryObserver.js
var require_queryObserver = __commonJS({
  "node_modules/@tanstack/query-core/build/lib/queryObserver.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_utils();
    var notifyManager = require_notifyManager();
    var focusManager = require_focusManager();
    var subscribable = require_subscribable();
    var retryer = require_retryer();
    var QueryObserver = class extends subscribable.Subscribable {
      constructor(client, options) {
        super();
        this.client = client;
        this.options = options;
        this.trackedProps = /* @__PURE__ */ new Set();
        this.selectError = null;
        this.bindMethods();
        this.setOptions(options);
      }
      bindMethods() {
        this.remove = this.remove.bind(this);
        this.refetch = this.refetch.bind(this);
      }
      onSubscribe() {
        if (this.listeners.size === 1) {
          this.currentQuery.addObserver(this);
          if (shouldFetchOnMount(this.currentQuery, this.options)) {
            this.executeFetch();
          }
          this.updateTimers();
        }
      }
      onUnsubscribe() {
        if (!this.hasListeners()) {
          this.destroy();
        }
      }
      shouldFetchOnReconnect() {
        return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnReconnect);
      }
      shouldFetchOnWindowFocus() {
        return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnWindowFocus);
      }
      destroy() {
        this.listeners = /* @__PURE__ */ new Set();
        this.clearStaleTimeout();
        this.clearRefetchInterval();
        this.currentQuery.removeObserver(this);
      }
      setOptions(options, notifyOptions) {
        const prevOptions = this.options;
        const prevQuery = this.currentQuery;
        this.options = this.client.defaultQueryOptions(options);
        if (typeof (options == null ? void 0 : options.isDataEqual) !== "undefined") {
          this.client.getLogger().error("The isDataEqual option has been deprecated and will be removed in the next major version. You can achieve the same functionality by passing a function as the structuralSharing option");
        }
        if (!utils.shallowEqualObjects(prevOptions, this.options)) {
          this.client.getQueryCache().notify({
            type: "observerOptionsUpdated",
            query: this.currentQuery,
            observer: this
          });
        }
        if (typeof this.options.enabled !== "undefined" && typeof this.options.enabled !== "boolean") {
          throw new Error("Expected enabled to be a boolean");
        }
        if (!this.options.queryKey) {
          this.options.queryKey = prevOptions.queryKey;
        }
        this.updateQuery();
        const mounted = this.hasListeners();
        if (mounted && shouldFetchOptionally(this.currentQuery, prevQuery, this.options, prevOptions)) {
          this.executeFetch();
        }
        this.updateResult(notifyOptions);
        if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime)) {
          this.updateStaleTimeout();
        }
        const nextRefetchInterval = this.computeRefetchInterval();
        if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || nextRefetchInterval !== this.currentRefetchInterval)) {
          this.updateRefetchInterval(nextRefetchInterval);
        }
      }
      getOptimisticResult(options) {
        const query = this.client.getQueryCache().build(this.client, options);
        const result = this.createResult(query, options);
        if (shouldAssignObserverCurrentProperties(this, result, options)) {
          this.currentResult = result;
          this.currentResultOptions = this.options;
          this.currentResultState = this.currentQuery.state;
        }
        return result;
      }
      getCurrentResult() {
        return this.currentResult;
      }
      trackResult(result) {
        const trackedResult = {};
        Object.keys(result).forEach((key) => {
          Object.defineProperty(trackedResult, key, {
            configurable: false,
            enumerable: true,
            get: () => {
              this.trackedProps.add(key);
              return result[key];
            }
          });
        });
        return trackedResult;
      }
      getCurrentQuery() {
        return this.currentQuery;
      }
      remove() {
        this.client.getQueryCache().remove(this.currentQuery);
      }
      refetch({
        refetchPage,
        ...options
      } = {}) {
        return this.fetch({
          ...options,
          meta: {
            refetchPage
          }
        });
      }
      fetchOptimistic(options) {
        const defaultedOptions = this.client.defaultQueryOptions(options);
        const query = this.client.getQueryCache().build(this.client, defaultedOptions);
        query.isFetchingOptimistic = true;
        return query.fetch().then(() => this.createResult(query, defaultedOptions));
      }
      fetch(fetchOptions) {
        var _fetchOptions$cancelR;
        return this.executeFetch({
          ...fetchOptions,
          cancelRefetch: (_fetchOptions$cancelR = fetchOptions.cancelRefetch) != null ? _fetchOptions$cancelR : true
        }).then(() => {
          this.updateResult();
          return this.currentResult;
        });
      }
      executeFetch(fetchOptions) {
        this.updateQuery();
        let promise = this.currentQuery.fetch(this.options, fetchOptions);
        if (!(fetchOptions != null && fetchOptions.throwOnError)) {
          promise = promise.catch(utils.noop);
        }
        return promise;
      }
      updateStaleTimeout() {
        this.clearStaleTimeout();
        if (utils.isServer || this.currentResult.isStale || !utils.isValidTimeout(this.options.staleTime)) {
          return;
        }
        const time = utils.timeUntilStale(this.currentResult.dataUpdatedAt, this.options.staleTime);
        const timeout = time + 1;
        this.staleTimeoutId = setTimeout(() => {
          if (!this.currentResult.isStale) {
            this.updateResult();
          }
        }, timeout);
      }
      computeRefetchInterval() {
        var _this$options$refetch;
        return typeof this.options.refetchInterval === "function" ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : (_this$options$refetch = this.options.refetchInterval) != null ? _this$options$refetch : false;
      }
      updateRefetchInterval(nextInterval) {
        this.clearRefetchInterval();
        this.currentRefetchInterval = nextInterval;
        if (utils.isServer || this.options.enabled === false || !utils.isValidTimeout(this.currentRefetchInterval) || this.currentRefetchInterval === 0) {
          return;
        }
        this.refetchIntervalId = setInterval(() => {
          if (this.options.refetchIntervalInBackground || focusManager.focusManager.isFocused()) {
            this.executeFetch();
          }
        }, this.currentRefetchInterval);
      }
      updateTimers() {
        this.updateStaleTimeout();
        this.updateRefetchInterval(this.computeRefetchInterval());
      }
      clearStaleTimeout() {
        if (this.staleTimeoutId) {
          clearTimeout(this.staleTimeoutId);
          this.staleTimeoutId = void 0;
        }
      }
      clearRefetchInterval() {
        if (this.refetchIntervalId) {
          clearInterval(this.refetchIntervalId);
          this.refetchIntervalId = void 0;
        }
      }
      createResult(query, options) {
        const prevQuery = this.currentQuery;
        const prevOptions = this.options;
        const prevResult = this.currentResult;
        const prevResultState = this.currentResultState;
        const prevResultOptions = this.currentResultOptions;
        const queryChange = query !== prevQuery;
        const queryInitialState = queryChange ? query.state : this.currentQueryInitialState;
        const prevQueryResult = queryChange ? this.currentResult : this.previousQueryResult;
        const {
          state
        } = query;
        let {
          dataUpdatedAt,
          error,
          errorUpdatedAt,
          fetchStatus,
          status
        } = state;
        let isPreviousData = false;
        let isPlaceholderData = false;
        let data;
        if (options._optimisticResults) {
          const mounted = this.hasListeners();
          const fetchOnMount = !mounted && shouldFetchOnMount(query, options);
          const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);
          if (fetchOnMount || fetchOptionally) {
            fetchStatus = retryer.canFetch(query.options.networkMode) ? "fetching" : "paused";
            if (!dataUpdatedAt) {
              status = "loading";
            }
          }
          if (options._optimisticResults === "isRestoring") {
            fetchStatus = "idle";
          }
        }
        if (options.keepPreviousData && !state.dataUpdatedAt && prevQueryResult != null && prevQueryResult.isSuccess && status !== "error") {
          data = prevQueryResult.data;
          dataUpdatedAt = prevQueryResult.dataUpdatedAt;
          status = prevQueryResult.status;
          isPreviousData = true;
        } else if (options.select && typeof state.data !== "undefined") {
          if (prevResult && state.data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === this.selectFn) {
            data = this.selectResult;
          } else {
            try {
              this.selectFn = options.select;
              data = options.select(state.data);
              data = utils.replaceData(prevResult == null ? void 0 : prevResult.data, data, options);
              this.selectResult = data;
              this.selectError = null;
            } catch (selectError) {
              if (true) {
                this.client.getLogger().error(selectError);
              }
              this.selectError = selectError;
            }
          }
        } else {
          data = state.data;
        }
        if (typeof options.placeholderData !== "undefined" && typeof data === "undefined" && status === "loading") {
          let placeholderData;
          if (prevResult != null && prevResult.isPlaceholderData && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {
            placeholderData = prevResult.data;
          } else {
            placeholderData = typeof options.placeholderData === "function" ? options.placeholderData() : options.placeholderData;
            if (options.select && typeof placeholderData !== "undefined") {
              try {
                placeholderData = options.select(placeholderData);
                this.selectError = null;
              } catch (selectError) {
                if (true) {
                  this.client.getLogger().error(selectError);
                }
                this.selectError = selectError;
              }
            }
          }
          if (typeof placeholderData !== "undefined") {
            status = "success";
            data = utils.replaceData(prevResult == null ? void 0 : prevResult.data, placeholderData, options);
            isPlaceholderData = true;
          }
        }
        if (this.selectError) {
          error = this.selectError;
          data = this.selectResult;
          errorUpdatedAt = Date.now();
          status = "error";
        }
        const isFetching = fetchStatus === "fetching";
        const isLoading = status === "loading";
        const isError = status === "error";
        const result = {
          status,
          fetchStatus,
          isLoading,
          isSuccess: status === "success",
          isError,
          isInitialLoading: isLoading && isFetching,
          data,
          dataUpdatedAt,
          error,
          errorUpdatedAt,
          failureCount: state.fetchFailureCount,
          failureReason: state.fetchFailureReason,
          errorUpdateCount: state.errorUpdateCount,
          isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,
          isFetchedAfterMount: state.dataUpdateCount > queryInitialState.dataUpdateCount || state.errorUpdateCount > queryInitialState.errorUpdateCount,
          isFetching,
          isRefetching: isFetching && !isLoading,
          isLoadingError: isError && state.dataUpdatedAt === 0,
          isPaused: fetchStatus === "paused",
          isPlaceholderData,
          isPreviousData,
          isRefetchError: isError && state.dataUpdatedAt !== 0,
          isStale: isStale(query, options),
          refetch: this.refetch,
          remove: this.remove
        };
        return result;
      }
      updateResult(notifyOptions) {
        const prevResult = this.currentResult;
        const nextResult = this.createResult(this.currentQuery, this.options);
        this.currentResultState = this.currentQuery.state;
        this.currentResultOptions = this.options;
        if (utils.shallowEqualObjects(nextResult, prevResult)) {
          return;
        }
        this.currentResult = nextResult;
        const defaultNotifyOptions = {
          cache: true
        };
        const shouldNotifyListeners = () => {
          if (!prevResult) {
            return true;
          }
          const {
            notifyOnChangeProps
          } = this.options;
          const notifyOnChangePropsValue = typeof notifyOnChangeProps === "function" ? notifyOnChangeProps() : notifyOnChangeProps;
          if (notifyOnChangePropsValue === "all" || !notifyOnChangePropsValue && !this.trackedProps.size) {
            return true;
          }
          const includedProps = new Set(notifyOnChangePropsValue != null ? notifyOnChangePropsValue : this.trackedProps);
          if (this.options.useErrorBoundary) {
            includedProps.add("error");
          }
          return Object.keys(this.currentResult).some((key) => {
            const typedKey = key;
            const changed = this.currentResult[typedKey] !== prevResult[typedKey];
            return changed && includedProps.has(typedKey);
          });
        };
        if ((notifyOptions == null ? void 0 : notifyOptions.listeners) !== false && shouldNotifyListeners()) {
          defaultNotifyOptions.listeners = true;
        }
        this.notify({
          ...defaultNotifyOptions,
          ...notifyOptions
        });
      }
      updateQuery() {
        const query = this.client.getQueryCache().build(this.client, this.options);
        if (query === this.currentQuery) {
          return;
        }
        const prevQuery = this.currentQuery;
        this.currentQuery = query;
        this.currentQueryInitialState = query.state;
        this.previousQueryResult = this.currentResult;
        if (this.hasListeners()) {
          prevQuery == null ? void 0 : prevQuery.removeObserver(this);
          query.addObserver(this);
        }
      }
      onQueryUpdate(action) {
        const notifyOptions = {};
        if (action.type === "success") {
          notifyOptions.onSuccess = !action.manual;
        } else if (action.type === "error" && !retryer.isCancelledError(action.error)) {
          notifyOptions.onError = true;
        }
        this.updateResult(notifyOptions);
        if (this.hasListeners()) {
          this.updateTimers();
        }
      }
      notify(notifyOptions) {
        notifyManager.notifyManager.batch(() => {
          if (notifyOptions.onSuccess) {
            var _this$options$onSucce, _this$options, _this$options$onSettl, _this$options2;
            (_this$options$onSucce = (_this$options = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options, this.currentResult.data);
            (_this$options$onSettl = (_this$options2 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options2, this.currentResult.data, null);
          } else if (notifyOptions.onError) {
            var _this$options$onError, _this$options3, _this$options$onSettl2, _this$options4;
            (_this$options$onError = (_this$options3 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options3, this.currentResult.error);
            (_this$options$onSettl2 = (_this$options4 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options4, void 0, this.currentResult.error);
          }
          if (notifyOptions.listeners) {
            this.listeners.forEach(({
              listener
            }) => {
              listener(this.currentResult);
            });
          }
          if (notifyOptions.cache) {
            this.client.getQueryCache().notify({
              query: this.currentQuery,
              type: "observerResultsUpdated"
            });
          }
        });
      }
    };
    function shouldLoadOnMount(query, options) {
      return options.enabled !== false && !query.state.dataUpdatedAt && !(query.state.status === "error" && options.retryOnMount === false);
    }
    function shouldFetchOnMount(query, options) {
      return shouldLoadOnMount(query, options) || query.state.dataUpdatedAt > 0 && shouldFetchOn(query, options, options.refetchOnMount);
    }
    function shouldFetchOn(query, options, field) {
      if (options.enabled !== false) {
        const value = typeof field === "function" ? field(query) : field;
        return value === "always" || value !== false && isStale(query, options);
      }
      return false;
    }
    function shouldFetchOptionally(query, prevQuery, options, prevOptions) {
      return options.enabled !== false && (query !== prevQuery || prevOptions.enabled === false) && (!options.suspense || query.state.status !== "error") && isStale(query, options);
    }
    function isStale(query, options) {
      return query.isStaleByTime(options.staleTime);
    }
    function shouldAssignObserverCurrentProperties(observer, optimisticResult, options) {
      if (options.keepPreviousData) {
        return false;
      }
      if (options.placeholderData !== void 0) {
        return optimisticResult.isPlaceholderData;
      }
      if (!utils.shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {
        return true;
      }
      return false;
    }
    exports.QueryObserver = QueryObserver;
  }
});

// node_modules/@tanstack/query-core/build/lib/queriesObserver.js
var require_queriesObserver = __commonJS({
  "node_modules/@tanstack/query-core/build/lib/queriesObserver.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_utils();
    var notifyManager = require_notifyManager();
    var queryObserver = require_queryObserver();
    var subscribable = require_subscribable();
    var QueriesObserver = class extends subscribable.Subscribable {
      constructor(client, queries) {
        super();
        this.client = client;
        this.queries = [];
        this.result = [];
        this.observers = [];
        this.observersMap = {};
        if (queries) {
          this.setQueries(queries);
        }
      }
      onSubscribe() {
        if (this.listeners.size === 1) {
          this.observers.forEach((observer) => {
            observer.subscribe((result) => {
              this.onUpdate(observer, result);
            });
          });
        }
      }
      onUnsubscribe() {
        if (!this.listeners.size) {
          this.destroy();
        }
      }
      destroy() {
        this.listeners = /* @__PURE__ */ new Set();
        this.observers.forEach((observer) => {
          observer.destroy();
        });
      }
      setQueries(queries, notifyOptions) {
        this.queries = queries;
        notifyManager.notifyManager.batch(() => {
          const prevObservers = this.observers;
          const newObserverMatches = this.findMatchingObservers(this.queries);
          newObserverMatches.forEach((match) => match.observer.setOptions(match.defaultedQueryOptions, notifyOptions));
          const newObservers = newObserverMatches.map((match) => match.observer);
          const newObserversMap = Object.fromEntries(newObservers.map((observer) => [observer.options.queryHash, observer]));
          const newResult = newObservers.map((observer) => observer.getCurrentResult());
          const hasIndexChange = newObservers.some((observer, index) => observer !== prevObservers[index]);
          if (prevObservers.length === newObservers.length && !hasIndexChange) {
            return;
          }
          this.observers = newObservers;
          this.observersMap = newObserversMap;
          this.result = newResult;
          if (!this.hasListeners()) {
            return;
          }
          utils.difference(prevObservers, newObservers).forEach((observer) => {
            observer.destroy();
          });
          utils.difference(newObservers, prevObservers).forEach((observer) => {
            observer.subscribe((result) => {
              this.onUpdate(observer, result);
            });
          });
          this.notify();
        });
      }
      getCurrentResult() {
        return this.result;
      }
      getQueries() {
        return this.observers.map((observer) => observer.getCurrentQuery());
      }
      getObservers() {
        return this.observers;
      }
      getOptimisticResult(queries) {
        return this.findMatchingObservers(queries).map((match) => match.observer.getOptimisticResult(match.defaultedQueryOptions));
      }
      findMatchingObservers(queries) {
        const prevObservers = this.observers;
        const prevObserversMap = new Map(prevObservers.map((observer) => [observer.options.queryHash, observer]));
        const defaultedQueryOptions = queries.map((options) => this.client.defaultQueryOptions(options));
        const matchingObservers = defaultedQueryOptions.flatMap((defaultedOptions) => {
          const match = prevObserversMap.get(defaultedOptions.queryHash);
          if (match != null) {
            return [{
              defaultedQueryOptions: defaultedOptions,
              observer: match
            }];
          }
          return [];
        });
        const matchedQueryHashes = new Set(matchingObservers.map((match) => match.defaultedQueryOptions.queryHash));
        const unmatchedQueries = defaultedQueryOptions.filter((defaultedOptions) => !matchedQueryHashes.has(defaultedOptions.queryHash));
        const matchingObserversSet = new Set(matchingObservers.map((match) => match.observer));
        const unmatchedObservers = prevObservers.filter((prevObserver) => !matchingObserversSet.has(prevObserver));
        const getObserver = (options) => {
          const defaultedOptions = this.client.defaultQueryOptions(options);
          const currentObserver = this.observersMap[defaultedOptions.queryHash];
          return currentObserver != null ? currentObserver : new queryObserver.QueryObserver(this.client, defaultedOptions);
        };
        const newOrReusedObservers = unmatchedQueries.map((options, index) => {
          if (options.keepPreviousData) {
            const previouslyUsedObserver = unmatchedObservers[index];
            if (previouslyUsedObserver !== void 0) {
              return {
                defaultedQueryOptions: options,
                observer: previouslyUsedObserver
              };
            }
          }
          return {
            defaultedQueryOptions: options,
            observer: getObserver(options)
          };
        });
        const sortMatchesByOrderOfQueries = (a, b) => defaultedQueryOptions.indexOf(a.defaultedQueryOptions) - defaultedQueryOptions.indexOf(b.defaultedQueryOptions);
        return matchingObservers.concat(newOrReusedObservers).sort(sortMatchesByOrderOfQueries);
      }
      onUpdate(observer, result) {
        const index = this.observers.indexOf(observer);
        if (index !== -1) {
          this.result = utils.replaceAt(this.result, index, result);
          this.notify();
        }
      }
      notify() {
        notifyManager.notifyManager.batch(() => {
          this.listeners.forEach(({
            listener
          }) => {
            listener(this.result);
          });
        });
      }
    };
    exports.QueriesObserver = QueriesObserver;
  }
});

// node_modules/@tanstack/query-core/build/lib/infiniteQueryObserver.js
var require_infiniteQueryObserver = __commonJS({
  "node_modules/@tanstack/query-core/build/lib/infiniteQueryObserver.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var queryObserver = require_queryObserver();
    var infiniteQueryBehavior = require_infiniteQueryBehavior();
    var InfiniteQueryObserver = class extends queryObserver.QueryObserver {
      // Type override
      // Type override
      // Type override
      // eslint-disable-next-line @typescript-eslint/no-useless-constructor
      constructor(client, options) {
        super(client, options);
      }
      bindMethods() {
        super.bindMethods();
        this.fetchNextPage = this.fetchNextPage.bind(this);
        this.fetchPreviousPage = this.fetchPreviousPage.bind(this);
      }
      setOptions(options, notifyOptions) {
        super.setOptions({
          ...options,
          behavior: infiniteQueryBehavior.infiniteQueryBehavior()
        }, notifyOptions);
      }
      getOptimisticResult(options) {
        options.behavior = infiniteQueryBehavior.infiniteQueryBehavior();
        return super.getOptimisticResult(options);
      }
      fetchNextPage({
        pageParam,
        ...options
      } = {}) {
        return this.fetch({
          ...options,
          meta: {
            fetchMore: {
              direction: "forward",
              pageParam
            }
          }
        });
      }
      fetchPreviousPage({
        pageParam,
        ...options
      } = {}) {
        return this.fetch({
          ...options,
          meta: {
            fetchMore: {
              direction: "backward",
              pageParam
            }
          }
        });
      }
      createResult(query, options) {
        var _state$fetchMeta, _state$fetchMeta$fetc, _state$fetchMeta2, _state$fetchMeta2$fet, _state$data, _state$data2;
        const {
          state
        } = query;
        const result = super.createResult(query, options);
        const {
          isFetching,
          isRefetching
        } = result;
        const isFetchingNextPage = isFetching && ((_state$fetchMeta = state.fetchMeta) == null ? void 0 : (_state$fetchMeta$fetc = _state$fetchMeta.fetchMore) == null ? void 0 : _state$fetchMeta$fetc.direction) === "forward";
        const isFetchingPreviousPage = isFetching && ((_state$fetchMeta2 = state.fetchMeta) == null ? void 0 : (_state$fetchMeta2$fet = _state$fetchMeta2.fetchMore) == null ? void 0 : _state$fetchMeta2$fet.direction) === "backward";
        return {
          ...result,
          fetchNextPage: this.fetchNextPage,
          fetchPreviousPage: this.fetchPreviousPage,
          hasNextPage: infiniteQueryBehavior.hasNextPage(options, (_state$data = state.data) == null ? void 0 : _state$data.pages),
          hasPreviousPage: infiniteQueryBehavior.hasPreviousPage(options, (_state$data2 = state.data) == null ? void 0 : _state$data2.pages),
          isFetchingNextPage,
          isFetchingPreviousPage,
          isRefetching: isRefetching && !isFetchingNextPage && !isFetchingPreviousPage
        };
      }
    };
    exports.InfiniteQueryObserver = InfiniteQueryObserver;
  }
});

// node_modules/@tanstack/query-core/build/lib/mutationObserver.js
var require_mutationObserver = __commonJS({
  "node_modules/@tanstack/query-core/build/lib/mutationObserver.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var mutation = require_mutation();
    var notifyManager = require_notifyManager();
    var subscribable = require_subscribable();
    var utils = require_utils();
    var MutationObserver = class extends subscribable.Subscribable {
      constructor(client, options) {
        super();
        this.client = client;
        this.setOptions(options);
        this.bindMethods();
        this.updateResult();
      }
      bindMethods() {
        this.mutate = this.mutate.bind(this);
        this.reset = this.reset.bind(this);
      }
      setOptions(options) {
        var _this$currentMutation;
        const prevOptions = this.options;
        this.options = this.client.defaultMutationOptions(options);
        if (!utils.shallowEqualObjects(prevOptions, this.options)) {
          this.client.getMutationCache().notify({
            type: "observerOptionsUpdated",
            mutation: this.currentMutation,
            observer: this
          });
        }
        (_this$currentMutation = this.currentMutation) == null ? void 0 : _this$currentMutation.setOptions(this.options);
      }
      onUnsubscribe() {
        if (!this.hasListeners()) {
          var _this$currentMutation2;
          (_this$currentMutation2 = this.currentMutation) == null ? void 0 : _this$currentMutation2.removeObserver(this);
        }
      }
      onMutationUpdate(action) {
        this.updateResult();
        const notifyOptions = {
          listeners: true
        };
        if (action.type === "success") {
          notifyOptions.onSuccess = true;
        } else if (action.type === "error") {
          notifyOptions.onError = true;
        }
        this.notify(notifyOptions);
      }
      getCurrentResult() {
        return this.currentResult;
      }
      reset() {
        this.currentMutation = void 0;
        this.updateResult();
        this.notify({
          listeners: true
        });
      }
      mutate(variables, options) {
        this.mutateOptions = options;
        if (this.currentMutation) {
          this.currentMutation.removeObserver(this);
        }
        this.currentMutation = this.client.getMutationCache().build(this.client, {
          ...this.options,
          variables: typeof variables !== "undefined" ? variables : this.options.variables
        });
        this.currentMutation.addObserver(this);
        return this.currentMutation.execute();
      }
      updateResult() {
        const state = this.currentMutation ? this.currentMutation.state : mutation.getDefaultState();
        const result = {
          ...state,
          isLoading: state.status === "loading",
          isSuccess: state.status === "success",
          isError: state.status === "error",
          isIdle: state.status === "idle",
          mutate: this.mutate,
          reset: this.reset
        };
        this.currentResult = result;
      }
      notify(options) {
        notifyManager.notifyManager.batch(() => {
          if (this.mutateOptions && this.hasListeners()) {
            if (options.onSuccess) {
              var _this$mutateOptions$o, _this$mutateOptions, _this$mutateOptions$o2, _this$mutateOptions2;
              (_this$mutateOptions$o = (_this$mutateOptions = this.mutateOptions).onSuccess) == null ? void 0 : _this$mutateOptions$o.call(_this$mutateOptions, this.currentResult.data, this.currentResult.variables, this.currentResult.context);
              (_this$mutateOptions$o2 = (_this$mutateOptions2 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o2.call(_this$mutateOptions2, this.currentResult.data, null, this.currentResult.variables, this.currentResult.context);
            } else if (options.onError) {
              var _this$mutateOptions$o3, _this$mutateOptions3, _this$mutateOptions$o4, _this$mutateOptions4;
              (_this$mutateOptions$o3 = (_this$mutateOptions3 = this.mutateOptions).onError) == null ? void 0 : _this$mutateOptions$o3.call(_this$mutateOptions3, this.currentResult.error, this.currentResult.variables, this.currentResult.context);
              (_this$mutateOptions$o4 = (_this$mutateOptions4 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o4.call(_this$mutateOptions4, void 0, this.currentResult.error, this.currentResult.variables, this.currentResult.context);
            }
          }
          if (options.listeners) {
            this.listeners.forEach(({
              listener
            }) => {
              listener(this.currentResult);
            });
          }
        });
      }
    };
    exports.MutationObserver = MutationObserver;
  }
});

// node_modules/@tanstack/query-core/build/lib/hydration.js
var require_hydration = __commonJS({
  "node_modules/@tanstack/query-core/build/lib/hydration.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function dehydrateMutation(mutation) {
      return {
        mutationKey: mutation.options.mutationKey,
        state: mutation.state
      };
    }
    function dehydrateQuery(query) {
      return {
        state: query.state,
        queryKey: query.queryKey,
        queryHash: query.queryHash
      };
    }
    function defaultShouldDehydrateMutation(mutation) {
      return mutation.state.isPaused;
    }
    function defaultShouldDehydrateQuery(query) {
      return query.state.status === "success";
    }
    function dehydrate(client, options = {}) {
      const mutations = [];
      const queries = [];
      if (options.dehydrateMutations !== false) {
        const shouldDehydrateMutation = options.shouldDehydrateMutation || defaultShouldDehydrateMutation;
        client.getMutationCache().getAll().forEach((mutation) => {
          if (shouldDehydrateMutation(mutation)) {
            mutations.push(dehydrateMutation(mutation));
          }
        });
      }
      if (options.dehydrateQueries !== false) {
        const shouldDehydrateQuery = options.shouldDehydrateQuery || defaultShouldDehydrateQuery;
        client.getQueryCache().getAll().forEach((query) => {
          if (shouldDehydrateQuery(query)) {
            queries.push(dehydrateQuery(query));
          }
        });
      }
      return {
        mutations,
        queries
      };
    }
    function hydrate(client, dehydratedState, options) {
      if (typeof dehydratedState !== "object" || dehydratedState === null) {
        return;
      }
      const mutationCache = client.getMutationCache();
      const queryCache = client.getQueryCache();
      const mutations = dehydratedState.mutations || [];
      const queries = dehydratedState.queries || [];
      mutations.forEach((dehydratedMutation) => {
        var _options$defaultOptio;
        mutationCache.build(client, {
          ...options == null ? void 0 : (_options$defaultOptio = options.defaultOptions) == null ? void 0 : _options$defaultOptio.mutations,
          mutationKey: dehydratedMutation.mutationKey
        }, dehydratedMutation.state);
      });
      queries.forEach((dehydratedQuery) => {
        var _options$defaultOptio2;
        const query = queryCache.get(dehydratedQuery.queryHash);
        const dehydratedQueryState = {
          ...dehydratedQuery.state,
          fetchStatus: "idle"
        };
        if (query) {
          if (query.state.dataUpdatedAt < dehydratedQueryState.dataUpdatedAt) {
            query.setState(dehydratedQueryState);
          }
          return;
        }
        queryCache.build(client, {
          ...options == null ? void 0 : (_options$defaultOptio2 = options.defaultOptions) == null ? void 0 : _options$defaultOptio2.queries,
          queryKey: dehydratedQuery.queryKey,
          queryHash: dehydratedQuery.queryHash
        }, dehydratedQueryState);
      });
    }
    exports.defaultShouldDehydrateMutation = defaultShouldDehydrateMutation;
    exports.defaultShouldDehydrateQuery = defaultShouldDehydrateQuery;
    exports.dehydrate = dehydrate;
    exports.hydrate = hydrate;
  }
});

// node_modules/@tanstack/query-core/build/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/@tanstack/query-core/build/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var retryer = require_retryer();
    var queryCache = require_queryCache();
    var queryClient = require_queryClient();
    var queryObserver = require_queryObserver();
    var queriesObserver = require_queriesObserver();
    var infiniteQueryObserver = require_infiniteQueryObserver();
    var mutationCache = require_mutationCache();
    var mutationObserver = require_mutationObserver();
    var notifyManager = require_notifyManager();
    var focusManager = require_focusManager();
    var onlineManager = require_onlineManager();
    var utils = require_utils();
    var hydration = require_hydration();
    var query = require_query();
    exports.CancelledError = retryer.CancelledError;
    exports.isCancelledError = retryer.isCancelledError;
    exports.QueryCache = queryCache.QueryCache;
    exports.QueryClient = queryClient.QueryClient;
    exports.QueryObserver = queryObserver.QueryObserver;
    exports.QueriesObserver = queriesObserver.QueriesObserver;
    exports.InfiniteQueryObserver = infiniteQueryObserver.InfiniteQueryObserver;
    exports.MutationCache = mutationCache.MutationCache;
    exports.MutationObserver = mutationObserver.MutationObserver;
    exports.notifyManager = notifyManager.notifyManager;
    exports.focusManager = focusManager.focusManager;
    exports.onlineManager = onlineManager.onlineManager;
    exports.hashQueryKey = utils.hashQueryKey;
    exports.isError = utils.isError;
    exports.isServer = utils.isServer;
    exports.matchQuery = utils.matchQuery;
    exports.parseFilterArgs = utils.parseFilterArgs;
    exports.parseMutationArgs = utils.parseMutationArgs;
    exports.parseMutationFilterArgs = utils.parseMutationFilterArgs;
    exports.parseQueryArgs = utils.parseQueryArgs;
    exports.replaceEqualDeep = utils.replaceEqualDeep;
    exports.defaultShouldDehydrateMutation = hydration.defaultShouldDehydrateMutation;
    exports.defaultShouldDehydrateQuery = hydration.defaultShouldDehydrateQuery;
    exports.dehydrate = hydration.dehydrate;
    exports.hydrate = hydration.hydrate;
    exports.Query = query.Query;
  }
});

// node_modules/@tanstack/react-query/build/lib/reactBatchedUpdates.js
var require_reactBatchedUpdates = __commonJS({
  "node_modules/@tanstack/react-query/build/lib/reactBatchedUpdates.js"(exports) {
    "use strict";
    "use client";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ReactDOM = require_react_dom();
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var ReactDOM__namespace = /* @__PURE__ */ _interopNamespace(ReactDOM);
    var unstable_batchedUpdates = ReactDOM__namespace.unstable_batchedUpdates;
    exports.unstable_batchedUpdates = unstable_batchedUpdates;
  }
});

// node_modules/@tanstack/react-query/build/lib/setBatchUpdatesFn.js
var require_setBatchUpdatesFn = __commonJS({
  "node_modules/@tanstack/react-query/build/lib/setBatchUpdatesFn.js"() {
    "use strict";
    var queryCore = require_lib2();
    var reactBatchedUpdates = require_reactBatchedUpdates();
    queryCore.notifyManager.setBatchNotifyFunction(reactBatchedUpdates.unstable_batchedUpdates);
  }
});

// node_modules/@tanstack/react-query/build/lib/useSyncExternalStore.js
var require_useSyncExternalStore = __commonJS({
  "node_modules/@tanstack/react-query/build/lib/useSyncExternalStore.js"(exports) {
    "use strict";
    "use client";
    Object.defineProperty(exports, "__esModule", { value: true });
    var index_js = require_shim();
    var useSyncExternalStore = index_js.useSyncExternalStore;
    exports.useSyncExternalStore = useSyncExternalStore;
  }
});

// node_modules/@tanstack/react-query/build/lib/QueryClientProvider.js
var require_QueryClientProvider = __commonJS({
  "node_modules/@tanstack/react-query/build/lib/QueryClientProvider.js"(exports) {
    "use strict";
    "use client";
    Object.defineProperty(exports, "__esModule", { value: true });
    var React = require_react();
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var React__namespace = /* @__PURE__ */ _interopNamespace(React);
    var defaultContext = /* @__PURE__ */ React__namespace.createContext(void 0);
    var QueryClientSharingContext = /* @__PURE__ */ React__namespace.createContext(false);
    function getQueryClientContext(context, contextSharing) {
      if (context) {
        return context;
      }
      if (contextSharing && typeof window !== "undefined") {
        if (!window.ReactQueryClientContext) {
          window.ReactQueryClientContext = defaultContext;
        }
        return window.ReactQueryClientContext;
      }
      return defaultContext;
    }
    var useQueryClient = ({
      context
    } = {}) => {
      const queryClient = React__namespace.useContext(getQueryClientContext(context, React__namespace.useContext(QueryClientSharingContext)));
      if (!queryClient) {
        throw new Error("No QueryClient set, use QueryClientProvider to set one");
      }
      return queryClient;
    };
    var QueryClientProvider = ({
      client,
      children,
      context,
      contextSharing = false
    }) => {
      React__namespace.useEffect(() => {
        client.mount();
        return () => {
          client.unmount();
        };
      }, [client]);
      if (contextSharing) {
        client.getLogger().error("The contextSharing option has been deprecated and will be removed in the next major version");
      }
      const Context = getQueryClientContext(context, contextSharing);
      return /* @__PURE__ */ React__namespace.createElement(QueryClientSharingContext.Provider, {
        value: !context && contextSharing
      }, /* @__PURE__ */ React__namespace.createElement(Context.Provider, {
        value: client
      }, children));
    };
    exports.QueryClientProvider = QueryClientProvider;
    exports.defaultContext = defaultContext;
    exports.useQueryClient = useQueryClient;
  }
});

// node_modules/@tanstack/react-query/build/lib/isRestoring.js
var require_isRestoring = __commonJS({
  "node_modules/@tanstack/react-query/build/lib/isRestoring.js"(exports) {
    "use strict";
    "use client";
    Object.defineProperty(exports, "__esModule", { value: true });
    var React = require_react();
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var React__namespace = /* @__PURE__ */ _interopNamespace(React);
    var IsRestoringContext = /* @__PURE__ */ React__namespace.createContext(false);
    var useIsRestoring = () => React__namespace.useContext(IsRestoringContext);
    var IsRestoringProvider = IsRestoringContext.Provider;
    exports.IsRestoringProvider = IsRestoringProvider;
    exports.useIsRestoring = useIsRestoring;
  }
});

// node_modules/@tanstack/react-query/build/lib/QueryErrorResetBoundary.js
var require_QueryErrorResetBoundary = __commonJS({
  "node_modules/@tanstack/react-query/build/lib/QueryErrorResetBoundary.js"(exports) {
    "use strict";
    "use client";
    Object.defineProperty(exports, "__esModule", { value: true });
    var React = require_react();
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var React__namespace = /* @__PURE__ */ _interopNamespace(React);
    function createValue() {
      let isReset = false;
      return {
        clearReset: () => {
          isReset = false;
        },
        reset: () => {
          isReset = true;
        },
        isReset: () => {
          return isReset;
        }
      };
    }
    var QueryErrorResetBoundaryContext = /* @__PURE__ */ React__namespace.createContext(createValue());
    var useQueryErrorResetBoundary = () => React__namespace.useContext(QueryErrorResetBoundaryContext);
    var QueryErrorResetBoundary = ({
      children
    }) => {
      const [value] = React__namespace.useState(() => createValue());
      return /* @__PURE__ */ React__namespace.createElement(QueryErrorResetBoundaryContext.Provider, {
        value
      }, typeof children === "function" ? children(value) : children);
    };
    exports.QueryErrorResetBoundary = QueryErrorResetBoundary;
    exports.useQueryErrorResetBoundary = useQueryErrorResetBoundary;
  }
});

// node_modules/@tanstack/react-query/build/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/@tanstack/react-query/build/lib/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function shouldThrowError(_useErrorBoundary, params) {
      if (typeof _useErrorBoundary === "function") {
        return _useErrorBoundary(...params);
      }
      return !!_useErrorBoundary;
    }
    exports.shouldThrowError = shouldThrowError;
  }
});

// node_modules/@tanstack/react-query/build/lib/errorBoundaryUtils.js
var require_errorBoundaryUtils = __commonJS({
  "node_modules/@tanstack/react-query/build/lib/errorBoundaryUtils.js"(exports) {
    "use strict";
    "use client";
    Object.defineProperty(exports, "__esModule", { value: true });
    var React = require_react();
    var utils = require_utils2();
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var React__namespace = /* @__PURE__ */ _interopNamespace(React);
    var ensurePreventErrorBoundaryRetry = (options, errorResetBoundary) => {
      if (options.suspense || options.useErrorBoundary) {
        if (!errorResetBoundary.isReset()) {
          options.retryOnMount = false;
        }
      }
    };
    var useClearResetErrorBoundary = (errorResetBoundary) => {
      React__namespace.useEffect(() => {
        errorResetBoundary.clearReset();
      }, [errorResetBoundary]);
    };
    var getHasError = ({
      result,
      errorResetBoundary,
      useErrorBoundary,
      query
    }) => {
      return result.isError && !errorResetBoundary.isReset() && !result.isFetching && utils.shouldThrowError(useErrorBoundary, [result.error, query]);
    };
    exports.ensurePreventErrorBoundaryRetry = ensurePreventErrorBoundaryRetry;
    exports.getHasError = getHasError;
    exports.useClearResetErrorBoundary = useClearResetErrorBoundary;
  }
});

// node_modules/@tanstack/react-query/build/lib/suspense.js
var require_suspense = __commonJS({
  "node_modules/@tanstack/react-query/build/lib/suspense.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ensureStaleTime = (defaultedOptions) => {
      if (defaultedOptions.suspense) {
        if (typeof defaultedOptions.staleTime !== "number") {
          defaultedOptions.staleTime = 1e3;
        }
      }
    };
    var willFetch = (result, isRestoring) => result.isLoading && result.isFetching && !isRestoring;
    var shouldSuspend = (defaultedOptions, result, isRestoring) => (defaultedOptions == null ? void 0 : defaultedOptions.suspense) && willFetch(result, isRestoring);
    var fetchOptimistic = (defaultedOptions, observer, errorResetBoundary) => observer.fetchOptimistic(defaultedOptions).then(({
      data
    }) => {
      defaultedOptions.onSuccess == null ? void 0 : defaultedOptions.onSuccess(data);
      defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(data, null);
    }).catch((error) => {
      errorResetBoundary.clearReset();
      defaultedOptions.onError == null ? void 0 : defaultedOptions.onError(error);
      defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(void 0, error);
    });
    exports.ensureStaleTime = ensureStaleTime;
    exports.fetchOptimistic = fetchOptimistic;
    exports.shouldSuspend = shouldSuspend;
    exports.willFetch = willFetch;
  }
});

// node_modules/@tanstack/react-query/build/lib/useQueries.js
var require_useQueries = __commonJS({
  "node_modules/@tanstack/react-query/build/lib/useQueries.js"(exports) {
    "use strict";
    "use client";
    Object.defineProperty(exports, "__esModule", { value: true });
    var React = require_react();
    var queryCore = require_lib2();
    var useSyncExternalStore = require_useSyncExternalStore();
    var QueryClientProvider = require_QueryClientProvider();
    var isRestoring = require_isRestoring();
    var QueryErrorResetBoundary = require_QueryErrorResetBoundary();
    var errorBoundaryUtils = require_errorBoundaryUtils();
    var suspense = require_suspense();
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var React__namespace = /* @__PURE__ */ _interopNamespace(React);
    function useQueries({
      queries,
      context
    }) {
      const queryClient = QueryClientProvider.useQueryClient({
        context
      });
      const isRestoring$1 = isRestoring.useIsRestoring();
      const errorResetBoundary = QueryErrorResetBoundary.useQueryErrorResetBoundary();
      const defaultedQueries = React__namespace.useMemo(() => queries.map((options) => {
        const defaultedOptions = queryClient.defaultQueryOptions(options);
        defaultedOptions._optimisticResults = isRestoring$1 ? "isRestoring" : "optimistic";
        return defaultedOptions;
      }), [queries, queryClient, isRestoring$1]);
      defaultedQueries.forEach((query) => {
        suspense.ensureStaleTime(query);
        errorBoundaryUtils.ensurePreventErrorBoundaryRetry(query, errorResetBoundary);
      });
      errorBoundaryUtils.useClearResetErrorBoundary(errorResetBoundary);
      const [observer] = React__namespace.useState(() => new queryCore.QueriesObserver(queryClient, defaultedQueries));
      const optimisticResult = observer.getOptimisticResult(defaultedQueries);
      useSyncExternalStore.useSyncExternalStore(React__namespace.useCallback((onStoreChange) => isRestoring$1 ? () => void 0 : observer.subscribe(queryCore.notifyManager.batchCalls(onStoreChange)), [observer, isRestoring$1]), () => observer.getCurrentResult(), () => observer.getCurrentResult());
      React__namespace.useEffect(() => {
        observer.setQueries(defaultedQueries, {
          listeners: false
        });
      }, [defaultedQueries, observer]);
      const shouldAtLeastOneSuspend = optimisticResult.some((result, index) => suspense.shouldSuspend(defaultedQueries[index], result, isRestoring$1));
      const suspensePromises = shouldAtLeastOneSuspend ? optimisticResult.flatMap((result, index) => {
        const options = defaultedQueries[index];
        const queryObserver = observer.getObservers()[index];
        if (options && queryObserver) {
          if (suspense.shouldSuspend(options, result, isRestoring$1)) {
            return suspense.fetchOptimistic(options, queryObserver, errorResetBoundary);
          } else if (suspense.willFetch(result, isRestoring$1)) {
            void suspense.fetchOptimistic(options, queryObserver, errorResetBoundary);
          }
        }
        return [];
      }) : [];
      if (suspensePromises.length > 0) {
        throw Promise.all(suspensePromises);
      }
      const observerQueries = observer.getQueries();
      const firstSingleResultWhichShouldThrow = optimisticResult.find((result, index) => {
        var _defaultedQueries$ind, _defaultedQueries$ind2;
        return errorBoundaryUtils.getHasError({
          result,
          errorResetBoundary,
          useErrorBoundary: (_defaultedQueries$ind = (_defaultedQueries$ind2 = defaultedQueries[index]) == null ? void 0 : _defaultedQueries$ind2.useErrorBoundary) != null ? _defaultedQueries$ind : false,
          query: observerQueries[index]
        });
      });
      if (firstSingleResultWhichShouldThrow != null && firstSingleResultWhichShouldThrow.error) {
        throw firstSingleResultWhichShouldThrow.error;
      }
      return optimisticResult;
    }
    exports.useQueries = useQueries;
  }
});

// node_modules/@tanstack/react-query/build/lib/useBaseQuery.js
var require_useBaseQuery = __commonJS({
  "node_modules/@tanstack/react-query/build/lib/useBaseQuery.js"(exports) {
    "use strict";
    "use client";
    Object.defineProperty(exports, "__esModule", { value: true });
    var React = require_react();
    var queryCore = require_lib2();
    var useSyncExternalStore = require_useSyncExternalStore();
    var QueryErrorResetBoundary = require_QueryErrorResetBoundary();
    var QueryClientProvider = require_QueryClientProvider();
    var isRestoring = require_isRestoring();
    var errorBoundaryUtils = require_errorBoundaryUtils();
    var suspense = require_suspense();
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var React__namespace = /* @__PURE__ */ _interopNamespace(React);
    function useBaseQuery(options, Observer) {
      const queryClient = QueryClientProvider.useQueryClient({
        context: options.context
      });
      const isRestoring$1 = isRestoring.useIsRestoring();
      const errorResetBoundary = QueryErrorResetBoundary.useQueryErrorResetBoundary();
      const defaultedOptions = queryClient.defaultQueryOptions(options);
      defaultedOptions._optimisticResults = isRestoring$1 ? "isRestoring" : "optimistic";
      if (defaultedOptions.onError) {
        defaultedOptions.onError = queryCore.notifyManager.batchCalls(defaultedOptions.onError);
      }
      if (defaultedOptions.onSuccess) {
        defaultedOptions.onSuccess = queryCore.notifyManager.batchCalls(defaultedOptions.onSuccess);
      }
      if (defaultedOptions.onSettled) {
        defaultedOptions.onSettled = queryCore.notifyManager.batchCalls(defaultedOptions.onSettled);
      }
      suspense.ensureStaleTime(defaultedOptions);
      errorBoundaryUtils.ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary);
      errorBoundaryUtils.useClearResetErrorBoundary(errorResetBoundary);
      const [observer] = React__namespace.useState(() => new Observer(queryClient, defaultedOptions));
      const result = observer.getOptimisticResult(defaultedOptions);
      useSyncExternalStore.useSyncExternalStore(React__namespace.useCallback((onStoreChange) => {
        const unsubscribe = isRestoring$1 ? () => void 0 : observer.subscribe(queryCore.notifyManager.batchCalls(onStoreChange));
        observer.updateResult();
        return unsubscribe;
      }, [observer, isRestoring$1]), () => observer.getCurrentResult(), () => observer.getCurrentResult());
      React__namespace.useEffect(() => {
        observer.setOptions(defaultedOptions, {
          listeners: false
        });
      }, [defaultedOptions, observer]);
      if (suspense.shouldSuspend(defaultedOptions, result, isRestoring$1)) {
        throw suspense.fetchOptimistic(defaultedOptions, observer, errorResetBoundary);
      }
      if (errorBoundaryUtils.getHasError({
        result,
        errorResetBoundary,
        useErrorBoundary: defaultedOptions.useErrorBoundary,
        query: observer.getCurrentQuery()
      })) {
        throw result.error;
      }
      return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;
    }
    exports.useBaseQuery = useBaseQuery;
  }
});

// node_modules/@tanstack/react-query/build/lib/useQuery.js
var require_useQuery = __commonJS({
  "node_modules/@tanstack/react-query/build/lib/useQuery.js"(exports) {
    "use strict";
    "use client";
    Object.defineProperty(exports, "__esModule", { value: true });
    var queryCore = require_lib2();
    var useBaseQuery = require_useBaseQuery();
    function useQuery(arg1, arg2, arg3) {
      const parsedOptions = queryCore.parseQueryArgs(arg1, arg2, arg3);
      return useBaseQuery.useBaseQuery(parsedOptions, queryCore.QueryObserver);
    }
    exports.useQuery = useQuery;
  }
});

// node_modules/@tanstack/react-query/build/lib/Hydrate.js
var require_Hydrate = __commonJS({
  "node_modules/@tanstack/react-query/build/lib/Hydrate.js"(exports) {
    "use strict";
    "use client";
    Object.defineProperty(exports, "__esModule", { value: true });
    var React = require_react();
    var queryCore = require_lib2();
    var QueryClientProvider = require_QueryClientProvider();
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var React__namespace = /* @__PURE__ */ _interopNamespace(React);
    function useHydrate(state, options = {}) {
      const queryClient = QueryClientProvider.useQueryClient({
        context: options.context
      });
      const optionsRef = React__namespace.useRef(options);
      optionsRef.current = options;
      React__namespace.useMemo(() => {
        if (state) {
          queryCore.hydrate(queryClient, state, optionsRef.current);
        }
      }, [queryClient, state]);
    }
    var Hydrate = ({
      children,
      options,
      state
    }) => {
      useHydrate(state, options);
      return children;
    };
    exports.Hydrate = Hydrate;
    exports.useHydrate = useHydrate;
  }
});

// node_modules/@tanstack/react-query/build/lib/useIsFetching.js
var require_useIsFetching = __commonJS({
  "node_modules/@tanstack/react-query/build/lib/useIsFetching.js"(exports) {
    "use strict";
    "use client";
    Object.defineProperty(exports, "__esModule", { value: true });
    var React = require_react();
    var queryCore = require_lib2();
    var useSyncExternalStore = require_useSyncExternalStore();
    var QueryClientProvider = require_QueryClientProvider();
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var React__namespace = /* @__PURE__ */ _interopNamespace(React);
    function useIsFetching(arg1, arg2, arg3) {
      const [filters, options = {}] = queryCore.parseFilterArgs(arg1, arg2, arg3);
      const queryClient = QueryClientProvider.useQueryClient({
        context: options.context
      });
      const queryCache = queryClient.getQueryCache();
      return useSyncExternalStore.useSyncExternalStore(React__namespace.useCallback((onStoreChange) => queryCache.subscribe(queryCore.notifyManager.batchCalls(onStoreChange)), [queryCache]), () => queryClient.isFetching(filters), () => queryClient.isFetching(filters));
    }
    exports.useIsFetching = useIsFetching;
  }
});

// node_modules/@tanstack/react-query/build/lib/useIsMutating.js
var require_useIsMutating = __commonJS({
  "node_modules/@tanstack/react-query/build/lib/useIsMutating.js"(exports) {
    "use strict";
    "use client";
    Object.defineProperty(exports, "__esModule", { value: true });
    var React = require_react();
    var queryCore = require_lib2();
    var useSyncExternalStore = require_useSyncExternalStore();
    var QueryClientProvider = require_QueryClientProvider();
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var React__namespace = /* @__PURE__ */ _interopNamespace(React);
    function useIsMutating(arg1, arg2, arg3) {
      const [filters, options = {}] = queryCore.parseMutationFilterArgs(arg1, arg2, arg3);
      const queryClient = QueryClientProvider.useQueryClient({
        context: options.context
      });
      const mutationCache = queryClient.getMutationCache();
      return useSyncExternalStore.useSyncExternalStore(React__namespace.useCallback((onStoreChange) => mutationCache.subscribe(queryCore.notifyManager.batchCalls(onStoreChange)), [mutationCache]), () => queryClient.isMutating(filters), () => queryClient.isMutating(filters));
    }
    exports.useIsMutating = useIsMutating;
  }
});

// node_modules/@tanstack/react-query/build/lib/useMutation.js
var require_useMutation = __commonJS({
  "node_modules/@tanstack/react-query/build/lib/useMutation.js"(exports) {
    "use strict";
    "use client";
    Object.defineProperty(exports, "__esModule", { value: true });
    var React = require_react();
    var queryCore = require_lib2();
    var useSyncExternalStore = require_useSyncExternalStore();
    var QueryClientProvider = require_QueryClientProvider();
    var utils = require_utils2();
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var React__namespace = /* @__PURE__ */ _interopNamespace(React);
    function useMutation(arg1, arg2, arg3) {
      const options = queryCore.parseMutationArgs(arg1, arg2, arg3);
      const queryClient = QueryClientProvider.useQueryClient({
        context: options.context
      });
      const [observer] = React__namespace.useState(() => new queryCore.MutationObserver(queryClient, options));
      React__namespace.useEffect(() => {
        observer.setOptions(options);
      }, [observer, options]);
      const result = useSyncExternalStore.useSyncExternalStore(React__namespace.useCallback((onStoreChange) => observer.subscribe(queryCore.notifyManager.batchCalls(onStoreChange)), [observer]), () => observer.getCurrentResult(), () => observer.getCurrentResult());
      const mutate = React__namespace.useCallback((variables, mutateOptions) => {
        observer.mutate(variables, mutateOptions).catch(noop);
      }, [observer]);
      if (result.error && utils.shouldThrowError(observer.options.useErrorBoundary, [result.error])) {
        throw result.error;
      }
      return {
        ...result,
        mutate,
        mutateAsync: result.mutate
      };
    }
    function noop() {
    }
    exports.useMutation = useMutation;
  }
});

// node_modules/@tanstack/react-query/build/lib/useInfiniteQuery.js
var require_useInfiniteQuery = __commonJS({
  "node_modules/@tanstack/react-query/build/lib/useInfiniteQuery.js"(exports) {
    "use strict";
    "use client";
    Object.defineProperty(exports, "__esModule", { value: true });
    var queryCore = require_lib2();
    var useBaseQuery = require_useBaseQuery();
    function useInfiniteQuery(arg1, arg2, arg3) {
      const options = queryCore.parseQueryArgs(arg1, arg2, arg3);
      return useBaseQuery.useBaseQuery(options, queryCore.InfiniteQueryObserver);
    }
    exports.useInfiniteQuery = useInfiniteQuery;
  }
});

// node_modules/@tanstack/react-query/build/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/@tanstack/react-query/build/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    require_setBatchUpdatesFn();
    var queryCore = require_lib2();
    var useQueries = require_useQueries();
    var useQuery = require_useQuery();
    var QueryClientProvider = require_QueryClientProvider();
    var Hydrate = require_Hydrate();
    var QueryErrorResetBoundary = require_QueryErrorResetBoundary();
    var useIsFetching = require_useIsFetching();
    var useIsMutating = require_useIsMutating();
    var useMutation = require_useMutation();
    var useInfiniteQuery = require_useInfiniteQuery();
    var isRestoring = require_isRestoring();
    exports.useQueries = useQueries.useQueries;
    exports.useQuery = useQuery.useQuery;
    exports.QueryClientProvider = QueryClientProvider.QueryClientProvider;
    exports.defaultContext = QueryClientProvider.defaultContext;
    exports.useQueryClient = QueryClientProvider.useQueryClient;
    exports.Hydrate = Hydrate.Hydrate;
    exports.useHydrate = Hydrate.useHydrate;
    exports.QueryErrorResetBoundary = QueryErrorResetBoundary.QueryErrorResetBoundary;
    exports.useQueryErrorResetBoundary = QueryErrorResetBoundary.useQueryErrorResetBoundary;
    exports.useIsFetching = useIsFetching.useIsFetching;
    exports.useIsMutating = useIsMutating.useIsMutating;
    exports.useMutation = useMutation.useMutation;
    exports.useInfiniteQuery = useInfiniteQuery.useInfiniteQuery;
    exports.IsRestoringProvider = isRestoring.IsRestoringProvider;
    exports.useIsRestoring = isRestoring.useIsRestoring;
    Object.keys(queryCore).forEach(function(k) {
      if (k !== "default" && !exports.hasOwnProperty(k))
        Object.defineProperty(exports, k, {
          enumerable: true,
          get: function() {
            return queryCore[k];
          }
        });
    });
  }
});

// node_modules/@tanstack/query-persist-client-core/build/lib/persist.js
var require_persist = __commonJS({
  "node_modules/@tanstack/query-persist-client-core/build/lib/persist.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var queryCore = require_lib2();
    var cacheableEventTypes = ["added", "removed", "updated"];
    function isCacheableEventType(eventType) {
      return cacheableEventTypes.includes(eventType);
    }
    async function persistQueryClientRestore({
      queryClient,
      persister,
      maxAge = 1e3 * 60 * 60 * 24,
      buster = "",
      hydrateOptions
    }) {
      try {
        const persistedClient = await persister.restoreClient();
        if (persistedClient) {
          if (persistedClient.timestamp) {
            const expired = Date.now() - persistedClient.timestamp > maxAge;
            const busted = persistedClient.buster !== buster;
            if (expired || busted) {
              persister.removeClient();
            } else {
              queryCore.hydrate(queryClient, persistedClient.clientState, hydrateOptions);
            }
          } else {
            persister.removeClient();
          }
        }
      } catch (err) {
        if (true) {
          queryClient.getLogger().error(err);
          queryClient.getLogger().warn("Encountered an error attempting to restore client cache from persisted location. As a precaution, the persisted cache will be discarded.");
        }
        persister.removeClient();
      }
    }
    async function persistQueryClientSave({
      queryClient,
      persister,
      buster = "",
      dehydrateOptions
    }) {
      const persistClient = {
        buster,
        timestamp: Date.now(),
        clientState: queryCore.dehydrate(queryClient, dehydrateOptions)
      };
      await persister.persistClient(persistClient);
    }
    function persistQueryClientSubscribe(props) {
      const unsubscribeQueryCache = props.queryClient.getQueryCache().subscribe((event) => {
        if (isCacheableEventType(event.type)) {
          persistQueryClientSave(props);
        }
      });
      const unusbscribeMutationCache = props.queryClient.getMutationCache().subscribe((event) => {
        if (isCacheableEventType(event.type)) {
          persistQueryClientSave(props);
        }
      });
      return () => {
        unsubscribeQueryCache();
        unusbscribeMutationCache();
      };
    }
    function persistQueryClient(props) {
      let hasUnsubscribed = false;
      let persistQueryClientUnsubscribe;
      const unsubscribe = () => {
        hasUnsubscribed = true;
        persistQueryClientUnsubscribe == null ? void 0 : persistQueryClientUnsubscribe();
      };
      const restorePromise = persistQueryClientRestore(props).then(() => {
        if (!hasUnsubscribed) {
          persistQueryClientUnsubscribe = persistQueryClientSubscribe(props);
        }
      });
      return [unsubscribe, restorePromise];
    }
    exports.persistQueryClient = persistQueryClient;
    exports.persistQueryClientRestore = persistQueryClientRestore;
    exports.persistQueryClientSave = persistQueryClientSave;
    exports.persistQueryClientSubscribe = persistQueryClientSubscribe;
  }
});

// node_modules/@tanstack/query-persist-client-core/build/lib/retryStrategies.js
var require_retryStrategies = __commonJS({
  "node_modules/@tanstack/query-persist-client-core/build/lib/retryStrategies.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var removeOldestQuery = ({
      persistedClient
    }) => {
      const mutations = [...persistedClient.clientState.mutations];
      const queries = [...persistedClient.clientState.queries];
      const client = {
        ...persistedClient,
        clientState: {
          mutations,
          queries
        }
      };
      const sortedQueries = [...queries].sort((a, b) => a.state.dataUpdatedAt - b.state.dataUpdatedAt);
      if (sortedQueries.length > 0) {
        const oldestData = sortedQueries.shift();
        client.clientState.queries = queries.filter((q) => q !== oldestData);
        return client;
      }
      return void 0;
    };
    exports.removeOldestQuery = removeOldestQuery;
  }
});

// node_modules/@tanstack/query-persist-client-core/build/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/@tanstack/query-persist-client-core/build/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var persist2 = require_persist();
    var retryStrategies = require_retryStrategies();
    exports.persistQueryClient = persist2.persistQueryClient;
    exports.persistQueryClientRestore = persist2.persistQueryClientRestore;
    exports.persistQueryClientSave = persist2.persistQueryClientSave;
    exports.persistQueryClientSubscribe = persist2.persistQueryClientSubscribe;
    exports.removeOldestQuery = retryStrategies.removeOldestQuery;
  }
});

// node_modules/@tanstack/react-query-persist-client/build/lib/_virtual/_rollupPluginBabelHelpers.js
var require_rollupPluginBabelHelpers = __commonJS({
  "node_modules/@tanstack/react-query-persist-client/build/lib/_virtual/_rollupPluginBabelHelpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _extends() {
      _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    exports["extends"] = _extends;
  }
});

// node_modules/@tanstack/react-query-persist-client/build/lib/PersistQueryClientProvider.js
var require_PersistQueryClientProvider = __commonJS({
  "node_modules/@tanstack/react-query-persist-client/build/lib/PersistQueryClientProvider.js"(exports) {
    "use strict";
    "use client";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _rollupPluginBabelHelpers = require_rollupPluginBabelHelpers();
    var React = require_react();
    var queryPersistClientCore = require_lib4();
    var reactQuery = require_lib3();
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var React__namespace = /* @__PURE__ */ _interopNamespace(React);
    var PersistQueryClientProvider = ({
      client,
      children,
      persistOptions,
      onSuccess,
      ...props
    }) => {
      const [isRestoring, setIsRestoring] = React__namespace.useState(true);
      const refs = React__namespace.useRef({
        persistOptions,
        onSuccess
      });
      const didRestore = React__namespace.useRef(false);
      React__namespace.useEffect(() => {
        refs.current = {
          persistOptions,
          onSuccess
        };
      });
      React__namespace.useEffect(() => {
        const options = {
          ...refs.current.persistOptions,
          queryClient: client
        };
        if (!didRestore.current) {
          didRestore.current = true;
          setIsRestoring(true);
          queryPersistClientCore.persistQueryClientRestore(options).then(async () => {
            try {
              await (refs.current.onSuccess == null ? void 0 : refs.current.onSuccess());
            } finally {
              setIsRestoring(false);
            }
          });
        }
        return isRestoring ? void 0 : queryPersistClientCore.persistQueryClientSubscribe(options);
      }, [client, isRestoring]);
      return /* @__PURE__ */ React__namespace.createElement(reactQuery.QueryClientProvider, _rollupPluginBabelHelpers["extends"]({
        client
      }, props), /* @__PURE__ */ React__namespace.createElement(reactQuery.IsRestoringProvider, {
        value: isRestoring
      }, children));
    };
    exports.PersistQueryClientProvider = PersistQueryClientProvider;
  }
});

// node_modules/@tanstack/react-query-persist-client/build/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/@tanstack/react-query-persist-client/build/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var queryPersistClientCore = require_lib4();
    var PersistQueryClientProvider = require_PersistQueryClientProvider();
    exports.PersistQueryClientProvider = PersistQueryClientProvider.PersistQueryClientProvider;
    Object.keys(queryPersistClientCore).forEach(function(k) {
      if (k !== "default" && !exports.hasOwnProperty(k))
        Object.defineProperty(exports, k, {
          enumerable: true,
          get: function() {
            return queryPersistClientCore[k];
          }
        });
    });
  }
});

// node_modules/viem/_cjs/errors/version.js
var require_version = __commonJS({
  "node_modules/viem/_cjs/errors/version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "1.10.12";
  }
});

// node_modules/viem/_cjs/errors/utils.js
var require_utils3 = __commonJS({
  "node_modules/viem/_cjs/errors/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getVersion = exports.getUrl = exports.getContractAddress = void 0;
    var version_js_1 = require_version();
    var getContractAddress = (address) => address;
    exports.getContractAddress = getContractAddress;
    var getUrl = (url) => url;
    exports.getUrl = getUrl;
    var getVersion = () => `viem@${version_js_1.version}`;
    exports.getVersion = getVersion;
  }
});

// node_modules/viem/_cjs/errors/base.js
var require_base = __commonJS({
  "node_modules/viem/_cjs/errors/base.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaseError = void 0;
    var utils_js_1 = require_utils3();
    var BaseError = class extends Error {
      constructor(shortMessage, args = {}) {
        super();
        Object.defineProperty(this, "details", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "docsPath", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "metaMessages", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "shortMessage", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ViemError"
        });
        Object.defineProperty(this, "version", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: (0, utils_js_1.getVersion)()
        });
        const details = args.cause instanceof BaseError ? args.cause.details : args.cause?.message ? args.cause.message : args.details;
        const docsPath = args.cause instanceof BaseError ? args.cause.docsPath || args.docsPath : args.docsPath;
        this.message = [
          shortMessage || "An error occurred.",
          "",
          ...args.metaMessages ? [...args.metaMessages, ""] : [],
          ...docsPath ? [
            `Docs: https://viem.sh${docsPath}.html${args.docsSlug ? `#${args.docsSlug}` : ""}`
          ] : [],
          ...details ? [`Details: ${details}`] : [],
          `Version: ${this.version}`
        ].join("\n");
        if (args.cause)
          this.cause = args.cause;
        this.details = details;
        this.docsPath = docsPath;
        this.metaMessages = args.metaMessages;
        this.shortMessage = shortMessage;
      }
      walk(fn) {
        return walk(this, fn);
      }
    };
    exports.BaseError = BaseError;
    function walk(err, fn) {
      if (fn?.(err))
        return err;
      if (err && typeof err === "object" && "cause" in err)
        return walk(err.cause, fn);
      return fn ? null : err;
    }
  }
});

// node_modules/viem/_cjs/errors/chain.js
var require_chain = __commonJS({
  "node_modules/viem/_cjs/errors/chain.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InvalidChainIdError = exports.ClientChainNotConfiguredError = exports.ChainNotFoundError = exports.ChainMismatchError = exports.ChainDoesNotSupportContract = void 0;
    var base_js_1 = require_base();
    var ChainDoesNotSupportContract = class extends base_js_1.BaseError {
      constructor({ blockNumber, chain, contract }) {
        super(`Chain "${chain.name}" does not support contract "${contract.name}".`, {
          metaMessages: [
            "This could be due to any of the following:",
            ...blockNumber && contract.blockCreated && contract.blockCreated > blockNumber ? [
              `- The contract "${contract.name}" was not deployed until block ${contract.blockCreated} (current block ${blockNumber}).`
            ] : [
              `- The chain does not have the contract "${contract.name}" configured.`
            ]
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ChainDoesNotSupportContract"
        });
      }
    };
    exports.ChainDoesNotSupportContract = ChainDoesNotSupportContract;
    var ChainMismatchError = class extends base_js_1.BaseError {
      constructor({ chain, currentChainId }) {
        super(`The current chain of the wallet (id: ${currentChainId}) does not match the target chain for the transaction (id: ${chain.id} \u2013 ${chain.name}).`, {
          metaMessages: [
            `Current Chain ID:  ${currentChainId}`,
            `Expected Chain ID: ${chain.id} \u2013 ${chain.name}`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ChainMismatchError"
        });
      }
    };
    exports.ChainMismatchError = ChainMismatchError;
    var ChainNotFoundError = class extends base_js_1.BaseError {
      constructor() {
        super([
          "No chain was provided to the request.",
          "Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient."
        ].join("\n"));
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ChainNotFoundError"
        });
      }
    };
    exports.ChainNotFoundError = ChainNotFoundError;
    var ClientChainNotConfiguredError = class extends base_js_1.BaseError {
      constructor() {
        super("No chain was provided to the Client.");
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ClientChainNotConfiguredError"
        });
      }
    };
    exports.ClientChainNotConfiguredError = ClientChainNotConfiguredError;
    var InvalidChainIdError = class extends base_js_1.BaseError {
      constructor({ chainId }) {
        super(`Chain ID "${chainId}" is invalid.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidChainIdError"
        });
      }
    };
    exports.InvalidChainIdError = InvalidChainIdError;
  }
});

// node_modules/viem/_cjs/utils/chain.js
var require_chain2 = __commonJS({
  "node_modules/viem/_cjs/utils/chain.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getChainContractAddress = exports.defineChain = exports.assertCurrentChain = void 0;
    var chain_js_1 = require_chain();
    function assertCurrentChain({ chain, currentChainId }) {
      if (!chain)
        throw new chain_js_1.ChainNotFoundError();
      if (currentChainId !== chain.id)
        throw new chain_js_1.ChainMismatchError({ chain, currentChainId });
    }
    exports.assertCurrentChain = assertCurrentChain;
    function defineChain(chain, config = {}) {
      const { fees = chain.fees, formatters = chain.formatters, serializers = chain.serializers } = config;
      return {
        ...chain,
        fees,
        formatters,
        serializers
      };
    }
    exports.defineChain = defineChain;
    function getChainContractAddress({ blockNumber, chain, contract: name }) {
      const contract = chain?.contracts?.[name];
      if (!contract)
        throw new chain_js_1.ChainDoesNotSupportContract({
          chain,
          contract: { name }
        });
      if (blockNumber && contract.blockCreated && contract.blockCreated > blockNumber)
        throw new chain_js_1.ChainDoesNotSupportContract({
          blockNumber,
          chain,
          contract: {
            name,
            blockCreated: contract.blockCreated
          }
        });
      return contract.address;
    }
    exports.getChainContractAddress = getChainContractAddress;
  }
});

// node_modules/viem/_cjs/chains/definitions/arbitrum.js
var require_arbitrum = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/arbitrum.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.arbitrum = void 0;
    var chain_js_1 = require_chain2();
    exports.arbitrum = (0, chain_js_1.defineChain)({
      id: 42161,
      name: "Arbitrum One",
      network: "arbitrum",
      nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        alchemy: {
          http: ["https://arb-mainnet.g.alchemy.com/v2"],
          webSocket: ["wss://arb-mainnet.g.alchemy.com/v2"]
        },
        infura: {
          http: ["https://arbitrum-mainnet.infura.io/v3"],
          webSocket: ["wss://arbitrum-mainnet.infura.io/ws/v3"]
        },
        default: {
          http: ["https://arb1.arbitrum.io/rpc"]
        },
        public: {
          http: ["https://arb1.arbitrum.io/rpc"]
        }
      },
      blockExplorers: {
        etherscan: { name: "Arbiscan", url: "https://arbiscan.io" },
        default: { name: "Arbiscan", url: "https://arbiscan.io" }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 7654707
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/arbitrumGoerli.js
var require_arbitrumGoerli = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/arbitrumGoerli.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.arbitrumGoerli = void 0;
    var chain_js_1 = require_chain2();
    exports.arbitrumGoerli = (0, chain_js_1.defineChain)({
      id: 421613,
      name: "Arbitrum Goerli",
      network: "arbitrum-goerli",
      nativeCurrency: {
        name: "Arbitrum Goerli Ether",
        symbol: "ETH",
        decimals: 18
      },
      rpcUrls: {
        alchemy: {
          http: ["https://arb-goerli.g.alchemy.com/v2"],
          webSocket: ["wss://arb-goerli.g.alchemy.com/v2"]
        },
        infura: {
          http: ["https://arbitrum-goerli.infura.io/v3"],
          webSocket: ["wss://arbitrum-goerli.infura.io/ws/v3"]
        },
        default: {
          http: ["https://goerli-rollup.arbitrum.io/rpc"]
        },
        public: {
          http: ["https://goerli-rollup.arbitrum.io/rpc"]
        }
      },
      blockExplorers: {
        etherscan: { name: "Arbiscan", url: "https://goerli.arbiscan.io/" },
        default: { name: "Arbiscan", url: "https://goerli.arbiscan.io/" }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 88114
        }
      },
      testnet: true
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/arbitrumNova.js
var require_arbitrumNova = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/arbitrumNova.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.arbitrumNova = void 0;
    var chain_js_1 = require_chain2();
    exports.arbitrumNova = (0, chain_js_1.defineChain)({
      id: 42170,
      name: "Arbitrum Nova",
      network: "arbitrum-nova",
      nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        blast: {
          http: ["https://arbitrum-nova.public.blastapi.io"],
          webSocket: ["wss://arbitrum-nova.public.blastapi.io"]
        },
        default: {
          http: ["https://nova.arbitrum.io/rpc"]
        },
        public: {
          http: ["https://nova.arbitrum.io/rpc"]
        }
      },
      blockExplorers: {
        etherscan: { name: "Arbiscan", url: "https://nova.arbiscan.io" },
        blockScout: {
          name: "BlockScout",
          url: "https://nova-explorer.arbitrum.io/"
        },
        default: { name: "Arbiscan", url: "https://nova.arbiscan.io" }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 1746963
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/aurora.js
var require_aurora = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/aurora.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.aurora = void 0;
    var chain_js_1 = require_chain2();
    exports.aurora = (0, chain_js_1.defineChain)({
      id: 1313161554,
      name: "Aurora",
      network: "aurora",
      nativeCurrency: {
        decimals: 18,
        name: "Ether",
        symbol: "ETH"
      },
      rpcUrls: {
        infura: { http: ["https://aurora-mainnet.infura.io/v3"] },
        default: { http: ["https://mainnet.aurora.dev"] },
        public: { http: ["https://mainnet.aurora.dev"] }
      },
      blockExplorers: {
        etherscan: { name: "Aurorascan", url: "https://aurorascan.dev" },
        default: { name: "Aurorascan", url: "https://aurorascan.dev" }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/auroraTestnet.js
var require_auroraTestnet = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/auroraTestnet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.auroraTestnet = void 0;
    var chain_js_1 = require_chain2();
    exports.auroraTestnet = (0, chain_js_1.defineChain)({
      id: 1313161555,
      name: "Aurora Testnet",
      network: "aurora-testnet",
      nativeCurrency: {
        decimals: 18,
        name: "Ether",
        symbol: "ETH"
      },
      rpcUrls: {
        infura: { http: ["https://aurora-testnet.infura.io/v3"] },
        default: { http: ["https://testnet.aurora.dev"] },
        public: { http: ["https://testnet.aurora.dev"] }
      },
      blockExplorers: {
        etherscan: { name: "Aurorascan", url: "https://testnet.aurorascan.dev" },
        default: { name: "Aurorascan", url: "https://testnet.aurorascan.dev" }
      },
      testnet: true
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/avalanche.js
var require_avalanche = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/avalanche.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.avalanche = void 0;
    var chain_js_1 = require_chain2();
    exports.avalanche = (0, chain_js_1.defineChain)({
      id: 43114,
      name: "Avalanche",
      network: "avalanche",
      nativeCurrency: {
        decimals: 18,
        name: "Avalanche",
        symbol: "AVAX"
      },
      rpcUrls: {
        default: { http: ["https://api.avax.network/ext/bc/C/rpc"] },
        public: { http: ["https://api.avax.network/ext/bc/C/rpc"] }
      },
      blockExplorers: {
        etherscan: { name: "SnowTrace", url: "https://snowtrace.io" },
        default: { name: "SnowTrace", url: "https://snowtrace.io" }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 11907934
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/avalancheFuji.js
var require_avalancheFuji = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/avalancheFuji.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.avalancheFuji = void 0;
    var chain_js_1 = require_chain2();
    exports.avalancheFuji = (0, chain_js_1.defineChain)({
      id: 43113,
      name: "Avalanche Fuji",
      network: "avalanche-fuji",
      nativeCurrency: {
        decimals: 18,
        name: "Avalanche Fuji",
        symbol: "AVAX"
      },
      rpcUrls: {
        default: { http: ["https://api.avax-test.network/ext/bc/C/rpc"] },
        public: { http: ["https://api.avax-test.network/ext/bc/C/rpc"] }
      },
      blockExplorers: {
        etherscan: { name: "SnowTrace", url: "https://testnet.snowtrace.io" },
        default: { name: "SnowTrace", url: "https://testnet.snowtrace.io" }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 7096959
        }
      },
      testnet: true
    });
  }
});

// node_modules/viem/_cjs/errors/encoding.js
var require_encoding = __commonJS({
  "node_modules/viem/_cjs/errors/encoding.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SizeOverflowError = exports.OffsetOutOfBoundsError = exports.InvalidHexValueError = exports.InvalidHexBooleanError = exports.InvalidBytesBooleanError = exports.IntegerOutOfRangeError = exports.DataLengthTooShortError = exports.DataLengthTooLongError = void 0;
    var base_js_1 = require_base();
    var DataLengthTooLongError = class extends base_js_1.BaseError {
      constructor({ consumed, length }) {
        super(`Consumed bytes (${consumed}) is shorter than data length (${length - 1}).`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "DataLengthTooLongError"
        });
      }
    };
    exports.DataLengthTooLongError = DataLengthTooLongError;
    var DataLengthTooShortError = class extends base_js_1.BaseError {
      constructor({ length, dataLength }) {
        super(`Data length (${dataLength - 1}) is shorter than prefix length (${length - 1}).`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "DataLengthTooShortError"
        });
      }
    };
    exports.DataLengthTooShortError = DataLengthTooShortError;
    var IntegerOutOfRangeError = class extends base_js_1.BaseError {
      constructor({ max, min, signed, size, value }) {
        super(`Number "${value}" is not in safe ${size ? `${size * 8}-bit ${signed ? "signed" : "unsigned"} ` : ""}integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "IntegerOutOfRangeError"
        });
      }
    };
    exports.IntegerOutOfRangeError = IntegerOutOfRangeError;
    var InvalidBytesBooleanError = class extends base_js_1.BaseError {
      constructor(bytes) {
        super(`Bytes value "${bytes}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidBytesBooleanError"
        });
      }
    };
    exports.InvalidBytesBooleanError = InvalidBytesBooleanError;
    var InvalidHexBooleanError = class extends base_js_1.BaseError {
      constructor(hex) {
        super(`Hex value "${hex}" is not a valid boolean. The hex value must be "0x0" (false) or "0x1" (true).`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidHexBooleanError"
        });
      }
    };
    exports.InvalidHexBooleanError = InvalidHexBooleanError;
    var InvalidHexValueError = class extends base_js_1.BaseError {
      constructor(value) {
        super(`Hex value "${value}" is an odd length (${value.length}). It must be an even length.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidHexValueError"
        });
      }
    };
    exports.InvalidHexValueError = InvalidHexValueError;
    var OffsetOutOfBoundsError = class extends base_js_1.BaseError {
      constructor({ nextOffset, offset }) {
        super(`Next offset (${nextOffset}) is greater than previous offset + consumed bytes (${offset})`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "OffsetOutOfBoundsError"
        });
      }
    };
    exports.OffsetOutOfBoundsError = OffsetOutOfBoundsError;
    var SizeOverflowError = class extends base_js_1.BaseError {
      constructor({ givenSize, maxSize }) {
        super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "SizeOverflowError"
        });
      }
    };
    exports.SizeOverflowError = SizeOverflowError;
  }
});

// node_modules/viem/_cjs/utils/data/isHex.js
var require_isHex = __commonJS({
  "node_modules/viem/_cjs/utils/data/isHex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isHex = void 0;
    function isHex(value, { strict = true } = {}) {
      if (!value)
        return false;
      if (typeof value !== "string")
        return false;
      return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith("0x");
    }
    exports.isHex = isHex;
  }
});

// node_modules/viem/_cjs/utils/data/size.js
var require_size = __commonJS({
  "node_modules/viem/_cjs/utils/data/size.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.size = void 0;
    var isHex_js_1 = require_isHex();
    function size(value) {
      if ((0, isHex_js_1.isHex)(value, { strict: false }))
        return Math.ceil((value.length - 2) / 2);
      return value.length;
    }
    exports.size = size;
  }
});

// node_modules/viem/_cjs/utils/data/trim.js
var require_trim = __commonJS({
  "node_modules/viem/_cjs/utils/data/trim.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.trim = void 0;
    function trim(hexOrBytes, { dir = "left" } = {}) {
      let data = typeof hexOrBytes === "string" ? hexOrBytes.replace("0x", "") : hexOrBytes;
      let sliceLength = 0;
      for (let i = 0; i < data.length - 1; i++) {
        if (data[dir === "left" ? i : data.length - i - 1].toString() === "0")
          sliceLength++;
        else
          break;
      }
      data = dir === "left" ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);
      if (typeof hexOrBytes === "string") {
        if (data.length === 1 && dir === "right")
          data = `${data}0`;
        return `0x${data.length % 2 === 1 ? `0${data}` : data}`;
      }
      return data;
    }
    exports.trim = trim;
  }
});

// node_modules/viem/_cjs/errors/data.js
var require_data = __commonJS({
  "node_modules/viem/_cjs/errors/data.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SizeExceedsPaddingSizeError = exports.SliceOffsetOutOfBoundsError = void 0;
    var base_js_1 = require_base();
    var SliceOffsetOutOfBoundsError = class extends base_js_1.BaseError {
      constructor({ offset, position, size }) {
        super(`Slice ${position === "start" ? "starting" : "ending"} at offset "${offset}" is out-of-bounds (size: ${size}).`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "SliceOffsetOutOfBoundsError"
        });
      }
    };
    exports.SliceOffsetOutOfBoundsError = SliceOffsetOutOfBoundsError;
    var SizeExceedsPaddingSizeError = class extends base_js_1.BaseError {
      constructor({ size, targetSize, type }) {
        super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (${size}) exceeds padding size (${targetSize}).`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "SizeExceedsPaddingSizeError"
        });
      }
    };
    exports.SizeExceedsPaddingSizeError = SizeExceedsPaddingSizeError;
  }
});

// node_modules/viem/_cjs/utils/data/pad.js
var require_pad = __commonJS({
  "node_modules/viem/_cjs/utils/data/pad.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.padBytes = exports.padHex = exports.pad = void 0;
    var data_js_1 = require_data();
    function pad(hexOrBytes, { dir, size = 32 } = {}) {
      if (typeof hexOrBytes === "string")
        return padHex(hexOrBytes, { dir, size });
      return padBytes(hexOrBytes, { dir, size });
    }
    exports.pad = pad;
    function padHex(hex_, { dir, size = 32 } = {}) {
      if (size === null)
        return hex_;
      const hex = hex_.replace("0x", "");
      if (hex.length > size * 2)
        throw new data_js_1.SizeExceedsPaddingSizeError({
          size: Math.ceil(hex.length / 2),
          targetSize: size,
          type: "hex"
        });
      return `0x${hex[dir === "right" ? "padEnd" : "padStart"](size * 2, "0")}`;
    }
    exports.padHex = padHex;
    function padBytes(bytes, { dir, size = 32 } = {}) {
      if (size === null)
        return bytes;
      if (bytes.length > size)
        throw new data_js_1.SizeExceedsPaddingSizeError({
          size: bytes.length,
          targetSize: size,
          type: "bytes"
        });
      const paddedBytes = new Uint8Array(size);
      for (let i = 0; i < size; i++) {
        const padEnd = dir === "right";
        paddedBytes[padEnd ? i : size - i - 1] = bytes[padEnd ? i : bytes.length - i - 1];
      }
      return paddedBytes;
    }
    exports.padBytes = padBytes;
  }
});

// node_modules/viem/_cjs/utils/encoding/toHex.js
var require_toHex = __commonJS({
  "node_modules/viem/_cjs/utils/encoding/toHex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringToHex = exports.numberToHex = exports.bytesToHex = exports.boolToHex = exports.toHex = void 0;
    var encoding_js_1 = require_encoding();
    var pad_js_1 = require_pad();
    var fromHex_js_1 = require_fromHex();
    var hexes = Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, "0"));
    function toHex(value, opts = {}) {
      if (typeof value === "number" || typeof value === "bigint")
        return numberToHex(value, opts);
      if (typeof value === "string") {
        return stringToHex(value, opts);
      }
      if (typeof value === "boolean")
        return boolToHex(value, opts);
      return bytesToHex(value, opts);
    }
    exports.toHex = toHex;
    function boolToHex(value, opts = {}) {
      const hex = `0x${Number(value)}`;
      if (typeof opts.size === "number") {
        (0, fromHex_js_1.assertSize)(hex, { size: opts.size });
        return (0, pad_js_1.pad)(hex, { size: opts.size });
      }
      return hex;
    }
    exports.boolToHex = boolToHex;
    function bytesToHex(value, opts = {}) {
      let hexString = "";
      for (let i = 0; i < value.length; i++) {
        hexString += hexes[value[i]];
      }
      const hex = `0x${hexString}`;
      if (typeof opts.size === "number") {
        (0, fromHex_js_1.assertSize)(hex, { size: opts.size });
        return (0, pad_js_1.pad)(hex, { dir: "right", size: opts.size });
      }
      return hex;
    }
    exports.bytesToHex = bytesToHex;
    function numberToHex(value_, opts = {}) {
      const { signed, size } = opts;
      const value = BigInt(value_);
      let maxValue;
      if (size) {
        if (signed)
          maxValue = (1n << BigInt(size) * 8n - 1n) - 1n;
        else
          maxValue = 2n ** (BigInt(size) * 8n) - 1n;
      } else if (typeof value_ === "number") {
        maxValue = BigInt(Number.MAX_SAFE_INTEGER);
      }
      const minValue = typeof maxValue === "bigint" && signed ? -maxValue - 1n : 0;
      if (maxValue && value > maxValue || value < minValue) {
        const suffix = typeof value_ === "bigint" ? "n" : "";
        throw new encoding_js_1.IntegerOutOfRangeError({
          max: maxValue ? `${maxValue}${suffix}` : void 0,
          min: `${minValue}${suffix}`,
          signed,
          size,
          value: `${value_}${suffix}`
        });
      }
      const hex = `0x${(signed && value < 0 ? (1n << BigInt(size * 8)) + BigInt(value) : value).toString(16)}`;
      if (size)
        return (0, pad_js_1.pad)(hex, { size });
      return hex;
    }
    exports.numberToHex = numberToHex;
    var encoder = new TextEncoder();
    function stringToHex(value_, opts = {}) {
      const value = encoder.encode(value_);
      return bytesToHex(value, opts);
    }
    exports.stringToHex = stringToHex;
  }
});

// node_modules/viem/_cjs/utils/encoding/toBytes.js
var require_toBytes = __commonJS({
  "node_modules/viem/_cjs/utils/encoding/toBytes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringToBytes = exports.numberToBytes = exports.hexToBytes = exports.boolToBytes = exports.toBytes = void 0;
    var base_js_1 = require_base();
    var isHex_js_1 = require_isHex();
    var pad_js_1 = require_pad();
    var fromHex_js_1 = require_fromHex();
    var toHex_js_1 = require_toHex();
    var encoder = new TextEncoder();
    function toBytes(value, opts = {}) {
      if (typeof value === "number" || typeof value === "bigint")
        return numberToBytes(value, opts);
      if (typeof value === "boolean")
        return boolToBytes(value, opts);
      if ((0, isHex_js_1.isHex)(value))
        return hexToBytes(value, opts);
      return stringToBytes(value, opts);
    }
    exports.toBytes = toBytes;
    function boolToBytes(value, opts = {}) {
      const bytes = new Uint8Array(1);
      bytes[0] = Number(value);
      if (typeof opts.size === "number") {
        (0, fromHex_js_1.assertSize)(bytes, { size: opts.size });
        return (0, pad_js_1.pad)(bytes, { size: opts.size });
      }
      return bytes;
    }
    exports.boolToBytes = boolToBytes;
    function hexToBytes(hex_, opts = {}) {
      let hex = hex_;
      if (opts.size) {
        (0, fromHex_js_1.assertSize)(hex, { size: opts.size });
        hex = (0, pad_js_1.pad)(hex, { dir: "right", size: opts.size });
      }
      let hexString = hex.slice(2);
      if (hexString.length % 2)
        hexString = `0${hexString}`;
      const bytes = new Uint8Array(hexString.length / 2);
      for (let index = 0; index < bytes.length; index++) {
        const start = index * 2;
        const hexByte = hexString.slice(start, start + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
          throw new base_js_1.BaseError(`Invalid byte sequence ("${hexByte}" in "${hexString}").`);
        bytes[index] = byte;
      }
      return bytes;
    }
    exports.hexToBytes = hexToBytes;
    function numberToBytes(value, opts) {
      const hex = (0, toHex_js_1.numberToHex)(value, opts);
      return hexToBytes(hex);
    }
    exports.numberToBytes = numberToBytes;
    function stringToBytes(value, opts = {}) {
      const bytes = encoder.encode(value);
      if (typeof opts.size === "number") {
        (0, fromHex_js_1.assertSize)(bytes, { size: opts.size });
        return (0, pad_js_1.pad)(bytes, { dir: "right", size: opts.size });
      }
      return bytes;
    }
    exports.stringToBytes = stringToBytes;
  }
});

// node_modules/viem/_cjs/utils/encoding/fromHex.js
var require_fromHex = __commonJS({
  "node_modules/viem/_cjs/utils/encoding/fromHex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hexToString = exports.hexToNumber = exports.hexToBool = exports.hexToBigInt = exports.fromHex = exports.assertSize = void 0;
    var encoding_js_1 = require_encoding();
    var size_js_1 = require_size();
    var trim_js_1 = require_trim();
    var toBytes_js_1 = require_toBytes();
    function assertSize(hexOrBytes, { size }) {
      if ((0, size_js_1.size)(hexOrBytes) > size)
        throw new encoding_js_1.SizeOverflowError({
          givenSize: (0, size_js_1.size)(hexOrBytes),
          maxSize: size
        });
    }
    exports.assertSize = assertSize;
    function fromHex(hex, toOrOpts) {
      const opts = typeof toOrOpts === "string" ? { to: toOrOpts } : toOrOpts;
      const to = opts.to;
      if (to === "number")
        return hexToNumber(hex, opts);
      if (to === "bigint")
        return hexToBigInt(hex, opts);
      if (to === "string")
        return hexToString(hex, opts);
      if (to === "boolean")
        return hexToBool(hex, opts);
      return (0, toBytes_js_1.hexToBytes)(hex, opts);
    }
    exports.fromHex = fromHex;
    function hexToBigInt(hex, opts = {}) {
      const { signed } = opts;
      if (opts.size)
        assertSize(hex, { size: opts.size });
      const value = BigInt(hex);
      if (!signed)
        return value;
      const size = (hex.length - 2) / 2;
      const max = (1n << BigInt(size) * 8n - 1n) - 1n;
      if (value <= max)
        return value;
      return value - BigInt(`0x${"f".padStart(size * 2, "f")}`) - 1n;
    }
    exports.hexToBigInt = hexToBigInt;
    function hexToBool(hex_, opts = {}) {
      let hex = hex_;
      if (opts.size) {
        assertSize(hex, { size: opts.size });
        hex = (0, trim_js_1.trim)(hex);
      }
      if ((0, trim_js_1.trim)(hex) === "0x00")
        return false;
      if ((0, trim_js_1.trim)(hex) === "0x01")
        return true;
      throw new encoding_js_1.InvalidHexBooleanError(hex);
    }
    exports.hexToBool = hexToBool;
    function hexToNumber(hex, opts = {}) {
      return Number(hexToBigInt(hex, opts));
    }
    exports.hexToNumber = hexToNumber;
    function hexToString(hex, opts = {}) {
      let bytes = (0, toBytes_js_1.hexToBytes)(hex);
      if (opts.size) {
        assertSize(bytes, { size: opts.size });
        bytes = (0, trim_js_1.trim)(bytes, { dir: "right" });
      }
      return new TextDecoder().decode(bytes);
    }
    exports.hexToString = hexToString;
  }
});

// node_modules/viem/_cjs/utils/formatters/formatter.js
var require_formatter = __commonJS({
  "node_modules/viem/_cjs/utils/formatters/formatter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defineFormatter = void 0;
    function defineFormatter(type, format) {
      return ({ exclude, format: overrides }) => {
        return {
          exclude,
          format: (args) => {
            const formatted = format(args);
            if (exclude) {
              for (const key of exclude) {
                delete formatted[key];
              }
            }
            return {
              ...formatted,
              ...overrides(args)
            };
          },
          type
        };
      };
    }
    exports.defineFormatter = defineFormatter;
  }
});

// node_modules/viem/_cjs/utils/formatters/transaction.js
var require_transaction = __commonJS({
  "node_modules/viem/_cjs/utils/formatters/transaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defineTransaction = exports.formatTransaction = exports.transactionType = void 0;
    var fromHex_js_1 = require_fromHex();
    var formatter_js_1 = require_formatter();
    exports.transactionType = {
      "0x0": "legacy",
      "0x1": "eip2930",
      "0x2": "eip1559"
    };
    function formatTransaction(transaction) {
      const transaction_ = {
        ...transaction,
        blockHash: transaction.blockHash ? transaction.blockHash : null,
        blockNumber: transaction.blockNumber ? BigInt(transaction.blockNumber) : null,
        chainId: transaction.chainId ? (0, fromHex_js_1.hexToNumber)(transaction.chainId) : void 0,
        gas: transaction.gas ? BigInt(transaction.gas) : void 0,
        gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : void 0,
        maxFeePerGas: transaction.maxFeePerGas ? BigInt(transaction.maxFeePerGas) : void 0,
        maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ? BigInt(transaction.maxPriorityFeePerGas) : void 0,
        nonce: transaction.nonce ? (0, fromHex_js_1.hexToNumber)(transaction.nonce) : void 0,
        to: transaction.to ? transaction.to : null,
        transactionIndex: transaction.transactionIndex ? Number(transaction.transactionIndex) : null,
        type: transaction.type ? exports.transactionType[transaction.type] : void 0,
        typeHex: transaction.type ? transaction.type : void 0,
        value: transaction.value ? BigInt(transaction.value) : void 0,
        v: transaction.v ? BigInt(transaction.v) : void 0
      };
      if (transaction_.type === "legacy") {
        delete transaction_.accessList;
        delete transaction_.maxFeePerGas;
        delete transaction_.maxPriorityFeePerGas;
      }
      if (transaction_.type === "eip2930") {
        delete transaction_.maxFeePerGas;
        delete transaction_.maxPriorityFeePerGas;
      }
      return transaction_;
    }
    exports.formatTransaction = formatTransaction;
    exports.defineTransaction = (0, formatter_js_1.defineFormatter)("transaction", formatTransaction);
  }
});

// node_modules/viem/_cjs/utils/formatters/block.js
var require_block = __commonJS({
  "node_modules/viem/_cjs/utils/formatters/block.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defineBlock = exports.formatBlock = void 0;
    var formatter_js_1 = require_formatter();
    var transaction_js_1 = require_transaction();
    function formatBlock(block) {
      const transactions = block.transactions?.map((transaction) => {
        if (typeof transaction === "string")
          return transaction;
        return (0, transaction_js_1.formatTransaction)(transaction);
      });
      return {
        ...block,
        baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
        difficulty: block.difficulty ? BigInt(block.difficulty) : void 0,
        gasLimit: block.gasLimit ? BigInt(block.gasLimit) : void 0,
        gasUsed: block.gasUsed ? BigInt(block.gasUsed) : void 0,
        hash: block.hash ? block.hash : null,
        logsBloom: block.logsBloom ? block.logsBloom : null,
        nonce: block.nonce ? block.nonce : null,
        number: block.number ? BigInt(block.number) : null,
        size: block.size ? BigInt(block.size) : void 0,
        timestamp: block.timestamp ? BigInt(block.timestamp) : void 0,
        transactions,
        totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null
      };
    }
    exports.formatBlock = formatBlock;
    exports.defineBlock = (0, formatter_js_1.defineFormatter)("block", formatBlock);
  }
});

// node_modules/viem/_cjs/utils/formatters/log.js
var require_log = __commonJS({
  "node_modules/viem/_cjs/utils/formatters/log.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatLog = void 0;
    function formatLog(log, { args, eventName } = {}) {
      return {
        ...log,
        blockHash: log.blockHash ? log.blockHash : null,
        blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
        logIndex: log.logIndex ? Number(log.logIndex) : null,
        transactionHash: log.transactionHash ? log.transactionHash : null,
        transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null,
        ...eventName ? { args, eventName } : {}
      };
    }
    exports.formatLog = formatLog;
  }
});

// node_modules/viem/_cjs/utils/formatters/transactionReceipt.js
var require_transactionReceipt = __commonJS({
  "node_modules/viem/_cjs/utils/formatters/transactionReceipt.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defineTransactionReceipt = exports.formatTransactionReceipt = void 0;
    var fromHex_js_1 = require_fromHex();
    var formatter_js_1 = require_formatter();
    var log_js_1 = require_log();
    var transaction_js_1 = require_transaction();
    var statuses = {
      "0x0": "reverted",
      "0x1": "success"
    };
    function formatTransactionReceipt(transactionReceipt) {
      return {
        ...transactionReceipt,
        blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,
        contractAddress: transactionReceipt.contractAddress ? transactionReceipt.contractAddress : null,
        cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,
        effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,
        gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,
        logs: transactionReceipt.logs ? transactionReceipt.logs.map((log) => (0, log_js_1.formatLog)(log)) : null,
        to: transactionReceipt.to ? transactionReceipt.to : null,
        transactionIndex: transactionReceipt.transactionIndex ? (0, fromHex_js_1.hexToNumber)(transactionReceipt.transactionIndex) : null,
        status: transactionReceipt.status ? statuses[transactionReceipt.status] : null,
        type: transactionReceipt.type ? transaction_js_1.transactionType[transactionReceipt.type] || transactionReceipt.type : null
      };
    }
    exports.formatTransactionReceipt = formatTransactionReceipt;
    exports.defineTransactionReceipt = (0, formatter_js_1.defineFormatter)("transactionReceipt", formatTransactionReceipt);
  }
});

// node_modules/viem/_cjs/chains/optimism/formatters.js
var require_formatters = __commonJS({
  "node_modules/viem/_cjs/chains/optimism/formatters.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formattersOptimism = void 0;
    var fromHex_js_1 = require_fromHex();
    var block_js_1 = require_block();
    var transaction_js_1 = require_transaction();
    var transactionReceipt_js_1 = require_transactionReceipt();
    exports.formattersOptimism = {
      block: (0, block_js_1.defineBlock)({
        format(args) {
          const transactions = args.transactions?.map((transaction) => {
            if (typeof transaction === "string")
              return transaction;
            const formatted = (0, transaction_js_1.formatTransaction)(transaction);
            if (formatted.typeHex === "0x7e") {
              formatted.isSystemTx = transaction.isSystemTx;
              formatted.mint = transaction.mint ? (0, fromHex_js_1.hexToBigInt)(transaction.mint) : void 0;
              formatted.sourceHash = transaction.sourceHash;
              formatted.type = "deposit";
            }
            return formatted;
          });
          return {
            transactions,
            stateRoot: args.stateRoot
          };
        }
      }),
      transaction: (0, transaction_js_1.defineTransaction)({
        format(args) {
          const transaction = {};
          if (args.type === "0x7e") {
            transaction.isSystemTx = args.isSystemTx;
            transaction.mint = args.mint ? (0, fromHex_js_1.hexToBigInt)(args.mint) : void 0;
            transaction.sourceHash = args.sourceHash;
            transaction.type = "deposit";
          }
          return transaction;
        }
      }),
      transactionReceipt: (0, transactionReceipt_js_1.defineTransactionReceipt)({
        format(args) {
          return {
            l1GasPrice: args.l1GasPrice ? (0, fromHex_js_1.hexToBigInt)(args.l1GasPrice) : null,
            l1GasUsed: args.l1GasUsed ? (0, fromHex_js_1.hexToBigInt)(args.l1GasUsed) : null,
            l1Fee: args.l1Fee ? (0, fromHex_js_1.hexToBigInt)(args.l1Fee) : null,
            l1FeeScalar: args.l1FeeScalar ? Number(args.l1FeeScalar) : null
          };
        }
      })
    };
  }
});

// node_modules/viem/_cjs/chains/definitions/base.js
var require_base2 = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/base.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.base = void 0;
    var chain_js_1 = require_chain2();
    var formatters_js_1 = require_formatters();
    exports.base = (0, chain_js_1.defineChain)({
      id: 8453,
      network: "base",
      name: "Base",
      nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        alchemy: {
          http: ["https://base-mainnet.g.alchemy.com/v2"],
          webSocket: ["wss://base-mainnet.g.alchemy.com/v2"]
        },
        default: {
          http: ["https://mainnet.base.org"]
        },
        public: {
          http: ["https://mainnet.base.org"]
        }
      },
      blockExplorers: {
        blockscout: {
          name: "Basescout",
          url: "https://base.blockscout.com"
        },
        default: {
          name: "Basescan",
          url: "https://basescan.org"
        },
        etherscan: {
          name: "Basescan",
          url: "https://basescan.org"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 5022
        }
      }
    }, {
      formatters: formatters_js_1.formattersOptimism
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/baseGoerli.js
var require_baseGoerli = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/baseGoerli.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.baseGoerli = void 0;
    var chain_js_1 = require_chain2();
    var formatters_js_1 = require_formatters();
    exports.baseGoerli = (0, chain_js_1.defineChain)({
      id: 84531,
      network: "base-goerli",
      name: "Base Goerli",
      nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        alchemy: {
          http: ["https://base-goerli.g.alchemy.com/v2"],
          webSocket: ["wss://base-goerli.g.alchemy.com/v2"]
        },
        default: {
          http: ["https://goerli.base.org"]
        },
        public: {
          http: ["https://goerli.base.org"]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "Basescan",
          url: "https://goerli.basescan.org"
        },
        default: {
          name: "Basescan",
          url: "https://goerli.basescan.org"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 1376988
        }
      },
      testnet: true,
      sourceId: 5
    }, {
      formatters: formatters_js_1.formattersOptimism
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/bearNetworkChainMainnet.js
var require_bearNetworkChainMainnet = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/bearNetworkChainMainnet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bearNetworkChainMainnet = void 0;
    var chain_js_1 = require_chain2();
    exports.bearNetworkChainMainnet = (0, chain_js_1.defineChain)({
      id: 641230,
      name: "Bear Network Chain Mainnet",
      network: "BearNetworkChainMainnet",
      nativeCurrency: {
        decimals: 18,
        name: "BearNetworkChain",
        symbol: "BRNKC"
      },
      rpcUrls: {
        public: { http: ["https://brnkc-mainnet.bearnetwork.net"] },
        default: { http: ["https://brnkc-mainnet.bearnetwork.net"] }
      },
      blockExplorers: {
        default: { name: "BrnkScan", url: "https://brnkscan.bearnetwork.net" }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/bearNetworkChainTestnet.js
var require_bearNetworkChainTestnet = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/bearNetworkChainTestnet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bearNetworkChainTestnet = void 0;
    var chain_js_1 = require_chain2();
    exports.bearNetworkChainTestnet = (0, chain_js_1.defineChain)({
      id: 751230,
      name: "Bear Network Chain Testnet",
      network: "BearNetworkChainTestnet",
      nativeCurrency: {
        decimals: 18,
        name: "tBRNKC",
        symbol: "tBRNKC"
      },
      rpcUrls: {
        public: { http: ["https://brnkc-test.bearnetwork.net"] },
        default: { http: ["https://brnkc-test.bearnetwork.net"] }
      },
      blockExplorers: {
        default: {
          name: "BrnkTestScan",
          url: "https://brnktest-scan.bearnetwork.net"
        }
      },
      testnet: true
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/boba.js
var require_boba = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/boba.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.boba = void 0;
    var chain_js_1 = require_chain2();
    exports.boba = (0, chain_js_1.defineChain)({
      id: 288,
      name: "Boba Network",
      network: "boba",
      nativeCurrency: {
        decimals: 18,
        name: "Boba",
        symbol: "BOBA"
      },
      rpcUrls: {
        default: { http: ["https://mainnet.boba.network"] },
        public: { http: ["https://mainnet.boba.network"] }
      },
      blockExplorers: {
        etherscan: { name: "BOBAScan", url: "https://bobascan.com" },
        default: { name: "BOBAScan", url: "https://bobascan.com" }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 446859
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/bronos.js
var require_bronos = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/bronos.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bronos = void 0;
    var chain_js_1 = require_chain2();
    exports.bronos = (0, chain_js_1.defineChain)({
      id: 1039,
      name: "Bronos",
      network: "bronos",
      nativeCurrency: {
        decimals: 18,
        name: "BRO",
        symbol: "BRO"
      },
      rpcUrls: {
        default: { http: ["https://evm.bronos.org"] },
        public: { http: ["https://evm.bronos.org"] }
      },
      blockExplorers: {
        default: { name: "BronoScan", url: "https://broscan.bronos.org" }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/bronosTestnet.js
var require_bronosTestnet = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/bronosTestnet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bronosTestnet = void 0;
    var chain_js_1 = require_chain2();
    exports.bronosTestnet = (0, chain_js_1.defineChain)({
      id: 1038,
      name: "Bronos Testnet",
      network: "bronos-testnet",
      nativeCurrency: {
        decimals: 18,
        name: "Bronos Coin",
        symbol: "tBRO"
      },
      rpcUrls: {
        default: { http: ["https://evm-testnet.bronos.org"] },
        public: { http: ["https://evm-testnet.bronos.org"] }
      },
      blockExplorers: {
        default: { name: "BronoScan", url: "https://tbroscan.bronos.org" }
      },
      testnet: true
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/bsc.js
var require_bsc = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/bsc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bsc = void 0;
    var chain_js_1 = require_chain2();
    exports.bsc = (0, chain_js_1.defineChain)({
      id: 56,
      name: "BNB Smart Chain",
      network: "bsc",
      nativeCurrency: {
        decimals: 18,
        name: "BNB",
        symbol: "BNB"
      },
      rpcUrls: {
        default: { http: ["https://rpc.ankr.com/bsc"] },
        public: { http: ["https://rpc.ankr.com/bsc"] }
      },
      blockExplorers: {
        etherscan: { name: "BscScan", url: "https://bscscan.com" },
        default: { name: "BscScan", url: "https://bscscan.com" }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 15921452
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/bscTestnet.js
var require_bscTestnet = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/bscTestnet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bscTestnet = void 0;
    var chain_js_1 = require_chain2();
    exports.bscTestnet = (0, chain_js_1.defineChain)({
      id: 97,
      name: "Binance Smart Chain Testnet",
      network: "bsc-testnet",
      nativeCurrency: {
        decimals: 18,
        name: "BNB",
        symbol: "tBNB"
      },
      rpcUrls: {
        default: { http: ["https://data-seed-prebsc-1-s1.binance.org:8545"] },
        public: { http: ["https://data-seed-prebsc-1-s1.binance.org:8545"] }
      },
      blockExplorers: {
        etherscan: { name: "BscScan", url: "https://testnet.bscscan.com" },
        default: { name: "BscScan", url: "https://testnet.bscscan.com" }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 17422483
        }
      },
      testnet: true
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/bxn.js
var require_bxn = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/bxn.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bxn = void 0;
    var chain_js_1 = require_chain2();
    exports.bxn = (0, chain_js_1.defineChain)({
      id: 4999,
      name: "BlackFort Exchange Network",
      network: "bxn",
      nativeCurrency: { name: "BlackFort Token", symbol: "BXN", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://mainnet.blackfort.network/rpc"]
        },
        public: {
          http: ["https://mainnet.blackfort.network/rpc"]
        }
      },
      blockExplorers: {
        default: {
          name: "Blockscout",
          url: "https://explorer.blackfort.network"
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/bxnTestnet.js
var require_bxnTestnet = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/bxnTestnet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bxnTestnet = void 0;
    var chain_js_1 = require_chain2();
    exports.bxnTestnet = (0, chain_js_1.defineChain)({
      id: 4777,
      name: "BlackFort Exchange Network Testnet",
      network: "bxnTestnet",
      nativeCurrency: {
        name: "BlackFort Testnet Token",
        symbol: "TBXN",
        decimals: 18
      },
      rpcUrls: {
        default: {
          http: ["https://testnet.blackfort.network/rpc"]
        },
        public: {
          http: ["https://testnet.blackfort.network/rpc"]
        }
      },
      blockExplorers: {
        default: {
          name: "Blockscout",
          url: "https://testnet-explorer.blackfort.network"
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/canto.js
var require_canto = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/canto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.canto = void 0;
    var chain_js_1 = require_chain2();
    exports.canto = (0, chain_js_1.defineChain)({
      id: 7700,
      name: "Canto",
      network: "canto",
      nativeCurrency: {
        decimals: 18,
        name: "Canto",
        symbol: "CANTO"
      },
      rpcUrls: {
        default: { http: ["https://canto.gravitychain.io"] },
        public: { http: ["https://canto.gravitychain.io"] }
      },
      blockExplorers: {
        default: {
          name: "Tuber.Build (Blockscout)",
          url: "https://tuber.build"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 2905789
        }
      }
    });
  }
});

// node_modules/viem/_cjs/utils/formatters/transactionRequest.js
var require_transactionRequest = __commonJS({
  "node_modules/viem/_cjs/utils/formatters/transactionRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defineTransactionRequest = exports.formatTransactionRequest = exports.rpcTransactionType = void 0;
    var toHex_js_1 = require_toHex();
    var formatter_js_1 = require_formatter();
    exports.rpcTransactionType = {
      legacy: "0x0",
      eip2930: "0x1",
      eip1559: "0x2"
    };
    function formatTransactionRequest(transactionRequest) {
      return {
        ...transactionRequest,
        gas: typeof transactionRequest.gas !== "undefined" ? (0, toHex_js_1.numberToHex)(transactionRequest.gas) : void 0,
        gasPrice: typeof transactionRequest.gasPrice !== "undefined" ? (0, toHex_js_1.numberToHex)(transactionRequest.gasPrice) : void 0,
        maxFeePerGas: typeof transactionRequest.maxFeePerGas !== "undefined" ? (0, toHex_js_1.numberToHex)(transactionRequest.maxFeePerGas) : void 0,
        maxPriorityFeePerGas: typeof transactionRequest.maxPriorityFeePerGas !== "undefined" ? (0, toHex_js_1.numberToHex)(transactionRequest.maxPriorityFeePerGas) : void 0,
        nonce: typeof transactionRequest.nonce !== "undefined" ? (0, toHex_js_1.numberToHex)(transactionRequest.nonce) : void 0,
        type: typeof transactionRequest.type !== "undefined" ? exports.rpcTransactionType[transactionRequest.type] : void 0,
        value: typeof transactionRequest.value !== "undefined" ? (0, toHex_js_1.numberToHex)(transactionRequest.value) : void 0
      };
    }
    exports.formatTransactionRequest = formatTransactionRequest;
    exports.defineTransactionRequest = (0, formatter_js_1.defineFormatter)("transactionRequest", formatTransactionRequest);
  }
});

// node_modules/viem/_cjs/chains/celo/formatters.js
var require_formatters2 = __commonJS({
  "node_modules/viem/_cjs/chains/celo/formatters.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formattersCelo = void 0;
    var fromHex_js_1 = require_fromHex();
    var toHex_js_1 = require_toHex();
    var block_js_1 = require_block();
    var transaction_js_1 = require_transaction();
    var transactionReceipt_js_1 = require_transactionReceipt();
    var transactionRequest_js_1 = require_transactionRequest();
    exports.formattersCelo = {
      block: (0, block_js_1.defineBlock)({
        exclude: ["difficulty", "gasLimit", "mixHash", "nonce", "uncles"],
        format(args) {
          const transactions = args.transactions?.map((transaction) => {
            if (typeof transaction === "string")
              return transaction;
            return {
              ...(0, transaction_js_1.formatTransaction)(transaction),
              feeCurrency: transaction.feeCurrency,
              gatewayFee: transaction.gatewayFee ? (0, fromHex_js_1.hexToBigInt)(transaction.gatewayFee) : null,
              gatewayFeeRecipient: transaction.gatewayFeeRecipient
            };
          });
          return {
            randomness: args.randomness,
            transactions
          };
        }
      }),
      transaction: (0, transaction_js_1.defineTransaction)({
        format(args) {
          return {
            feeCurrency: args.feeCurrency,
            gatewayFee: args.gatewayFee ? (0, fromHex_js_1.hexToBigInt)(args.gatewayFee) : null,
            gatewayFeeRecipient: args.gatewayFeeRecipient
          };
        }
      }),
      transactionReceipt: (0, transactionReceipt_js_1.defineTransactionReceipt)({
        format(args) {
          return {
            feeCurrency: args.feeCurrency,
            gatewayFee: args.gatewayFee ? (0, fromHex_js_1.hexToBigInt)(args.gatewayFee) : null,
            gatewayFeeRecipient: args.gatewayFeeRecipient
          };
        }
      }),
      transactionRequest: (0, transactionRequest_js_1.defineTransactionRequest)({
        format(args) {
          const request = {
            feeCurrency: args.feeCurrency,
            gatewayFee: typeof args.gatewayFee !== "undefined" ? (0, toHex_js_1.numberToHex)(args.gatewayFee) : void 0,
            gatewayFeeRecipient: args.gatewayFeeRecipient
          };
          if (args.type === "cip42")
            request.type = "0x7c";
          return request;
        }
      })
    };
  }
});

// node_modules/viem/_cjs/errors/address.js
var require_address = __commonJS({
  "node_modules/viem/_cjs/errors/address.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InvalidAddressError = void 0;
    var base_js_1 = require_base();
    var InvalidAddressError = class extends base_js_1.BaseError {
      constructor({ address }) {
        super(`Address "${address}" is invalid.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidAddressError"
        });
      }
    };
    exports.InvalidAddressError = InvalidAddressError;
  }
});

// node_modules/viem/_cjs/constants/unit.js
var require_unit = __commonJS({
  "node_modules/viem/_cjs/constants/unit.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.weiUnits = exports.gweiUnits = exports.etherUnits = void 0;
    exports.etherUnits = {
      gwei: 9,
      wei: 18
    };
    exports.gweiUnits = {
      ether: -9,
      wei: 9
    };
    exports.weiUnits = {
      ether: -18,
      gwei: -9
    };
  }
});

// node_modules/viem/_cjs/utils/unit/formatUnits.js
var require_formatUnits = __commonJS({
  "node_modules/viem/_cjs/utils/unit/formatUnits.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatUnits = void 0;
    function formatUnits(value, decimals) {
      let display = value.toString();
      const negative = display.startsWith("-");
      if (negative)
        display = display.slice(1);
      display = display.padStart(decimals, "0");
      let [integer, fraction] = [
        display.slice(0, display.length - decimals),
        display.slice(display.length - decimals)
      ];
      fraction = fraction.replace(/(0+)$/, "");
      return `${negative ? "-" : ""}${integer || "0"}${fraction ? `.${fraction}` : ""}`;
    }
    exports.formatUnits = formatUnits;
  }
});

// node_modules/viem/_cjs/utils/unit/formatGwei.js
var require_formatGwei = __commonJS({
  "node_modules/viem/_cjs/utils/unit/formatGwei.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatGwei = void 0;
    var unit_js_1 = require_unit();
    var formatUnits_js_1 = require_formatUnits();
    function formatGwei(wei, unit = "wei") {
      return (0, formatUnits_js_1.formatUnits)(wei, unit_js_1.gweiUnits[unit]);
    }
    exports.formatGwei = formatGwei;
  }
});

// node_modules/viem/_cjs/errors/node.js
var require_node = __commonJS({
  "node_modules/viem/_cjs/errors/node.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UnknownNodeError = exports.TipAboveFeeCapError = exports.TransactionTypeNotSupportedError = exports.IntrinsicGasTooLowError = exports.IntrinsicGasTooHighError = exports.InsufficientFundsError = exports.NonceMaxValueError = exports.NonceTooLowError = exports.NonceTooHighError = exports.FeeCapTooLowError = exports.FeeCapTooHighError = exports.ExecutionRevertedError = void 0;
    var formatGwei_js_1 = require_formatGwei();
    var base_js_1 = require_base();
    var ExecutionRevertedError = class extends base_js_1.BaseError {
      constructor({ cause, message } = {}) {
        const reason = message?.replace("execution reverted: ", "")?.replace("execution reverted", "");
        super(`Execution reverted ${reason ? `with reason: ${reason}` : "for an unknown reason"}.`, {
          cause
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ExecutionRevertedError"
        });
      }
    };
    exports.ExecutionRevertedError = ExecutionRevertedError;
    Object.defineProperty(ExecutionRevertedError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 3
    });
    Object.defineProperty(ExecutionRevertedError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /execution reverted/
    });
    var FeeCapTooHighError = class extends base_js_1.BaseError {
      constructor({ cause, maxFeePerGas } = {}) {
        super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${(0, formatGwei_js_1.formatGwei)(maxFeePerGas)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
          cause
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "FeeCapTooHigh"
        });
      }
    };
    exports.FeeCapTooHighError = FeeCapTooHighError;
    Object.defineProperty(FeeCapTooHighError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
    });
    var FeeCapTooLowError = class extends base_js_1.BaseError {
      constructor({ cause, maxFeePerGas } = {}) {
        super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${(0, formatGwei_js_1.formatGwei)(maxFeePerGas)}` : ""} gwei) cannot be lower than the block base fee.`, {
          cause
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "FeeCapTooLow"
        });
      }
    };
    exports.FeeCapTooLowError = FeeCapTooLowError;
    Object.defineProperty(FeeCapTooLowError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
    });
    var NonceTooHighError = class extends base_js_1.BaseError {
      constructor({ cause, nonce } = {}) {
        super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is higher than the next one expected.`, { cause });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "NonceTooHighError"
        });
      }
    };
    exports.NonceTooHighError = NonceTooHighError;
    Object.defineProperty(NonceTooHighError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /nonce too high/
    });
    var NonceTooLowError = class extends base_js_1.BaseError {
      constructor({ cause, nonce } = {}) {
        super([
          `Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is lower than the current nonce of the account.`,
          "Try increasing the nonce or find the latest nonce with `getTransactionCount`."
        ].join("\n"), { cause });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "NonceTooLowError"
        });
      }
    };
    exports.NonceTooLowError = NonceTooLowError;
    Object.defineProperty(NonceTooLowError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /nonce too low|transaction already imported|already known/
    });
    var NonceMaxValueError = class extends base_js_1.BaseError {
      constructor({ cause, nonce } = {}) {
        super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}exceeds the maximum allowed nonce.`, { cause });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "NonceMaxValueError"
        });
      }
    };
    exports.NonceMaxValueError = NonceMaxValueError;
    Object.defineProperty(NonceMaxValueError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /nonce has max value/
    });
    var InsufficientFundsError = class extends base_js_1.BaseError {
      constructor({ cause } = {}) {
        super([
          "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."
        ].join("\n"), {
          cause,
          metaMessages: [
            "This error could arise when the account does not have enough funds to:",
            " - pay for the total gas fee,",
            " - pay for the value to send.",
            " ",
            "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
            " - `gas` is the amount of gas needed for transaction to execute,",
            " - `gas fee` is the gas fee,",
            " - `value` is the amount of ether to send to the recipient."
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InsufficientFundsError"
        });
      }
    };
    exports.InsufficientFundsError = InsufficientFundsError;
    Object.defineProperty(InsufficientFundsError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /insufficient funds/
    });
    var IntrinsicGasTooHighError = class extends base_js_1.BaseError {
      constructor({ cause, gas } = {}) {
        super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`, {
          cause
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "IntrinsicGasTooHighError"
        });
      }
    };
    exports.IntrinsicGasTooHighError = IntrinsicGasTooHighError;
    Object.defineProperty(IntrinsicGasTooHighError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /intrinsic gas too high|gas limit reached/
    });
    var IntrinsicGasTooLowError = class extends base_js_1.BaseError {
      constructor({ cause, gas } = {}) {
        super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction is too low.`, {
          cause
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "IntrinsicGasTooLowError"
        });
      }
    };
    exports.IntrinsicGasTooLowError = IntrinsicGasTooLowError;
    Object.defineProperty(IntrinsicGasTooLowError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /intrinsic gas too low/
    });
    var TransactionTypeNotSupportedError = class extends base_js_1.BaseError {
      constructor({ cause }) {
        super("The transaction type is not supported for this chain.", {
          cause
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "TransactionTypeNotSupportedError"
        });
      }
    };
    exports.TransactionTypeNotSupportedError = TransactionTypeNotSupportedError;
    Object.defineProperty(TransactionTypeNotSupportedError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /transaction type not valid/
    });
    var TipAboveFeeCapError = class extends base_js_1.BaseError {
      constructor({ cause, maxPriorityFeePerGas, maxFeePerGas } = {}) {
        super([
          `The provided tip (\`maxPriorityFeePerGas\`${maxPriorityFeePerGas ? ` = ${(0, formatGwei_js_1.formatGwei)(maxPriorityFeePerGas)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${(0, formatGwei_js_1.formatGwei)(maxFeePerGas)} gwei` : ""}).`
        ].join("\n"), {
          cause
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "TipAboveFeeCapError"
        });
      }
    };
    exports.TipAboveFeeCapError = TipAboveFeeCapError;
    Object.defineProperty(TipAboveFeeCapError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
    });
    var UnknownNodeError = class extends base_js_1.BaseError {
      constructor({ cause }) {
        super(`An error occurred while executing: ${cause?.shortMessage}`, {
          cause
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "UnknownNodeError"
        });
      }
    };
    exports.UnknownNodeError = UnknownNodeError;
  }
});

// node_modules/viem/_cjs/utils/address/isAddress.js
var require_isAddress = __commonJS({
  "node_modules/viem/_cjs/utils/address/isAddress.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAddress = void 0;
    var addressRegex = /^0x[a-fA-F0-9]{40}$/;
    function isAddress(address) {
      return addressRegex.test(address);
    }
    exports.isAddress = isAddress;
  }
});

// node_modules/viem/_cjs/utils/data/concat.js
var require_concat = __commonJS({
  "node_modules/viem/_cjs/utils/data/concat.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.concatHex = exports.concatBytes = exports.concat = void 0;
    function concat(values) {
      if (typeof values[0] === "string")
        return concatHex(values);
      return concatBytes(values);
    }
    exports.concat = concat;
    function concatBytes(values) {
      let length = 0;
      for (const arr of values) {
        length += arr.length;
      }
      const result = new Uint8Array(length);
      let offset = 0;
      for (const arr of values) {
        result.set(arr, offset);
        offset += arr.length;
      }
      return result;
    }
    exports.concatBytes = concatBytes;
    function concatHex(values) {
      return `0x${values.reduce((acc, x) => acc + x.replace("0x", ""), "")}`;
    }
    exports.concatHex = concatHex;
  }
});

// node_modules/viem/_cjs/utils/encoding/toRlp.js
var require_toRlp = __commonJS({
  "node_modules/viem/_cjs/utils/encoding/toRlp.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bytesToRlp = exports.toRlp = void 0;
    var concat_js_1 = require_concat();
    var toBytes_js_1 = require_toBytes();
    var toHex_js_1 = require_toHex();
    function toRlp(hexOrBytes, to_) {
      const to = to_ || "hex";
      return format(bytesToRlp(parse(hexOrBytes)), to);
    }
    exports.toRlp = toRlp;
    function parse(hexOrBytes) {
      if (Array.isArray(hexOrBytes))
        return hexOrBytes.map(parse);
      return typeof hexOrBytes === "string" ? (0, toBytes_js_1.toBytes)(hexOrBytes) : hexOrBytes;
    }
    function format(bytes, type = "bytes") {
      return type === "hex" ? (0, toHex_js_1.bytesToHex)(bytes) : bytes;
    }
    function bytesToRlp(bytes) {
      if (Array.isArray(bytes)) {
        const encoded = (0, concat_js_1.concat)(bytes.map(bytesToRlp));
        return new Uint8Array([...encodeLength(encoded.length, 192), ...encoded]);
      }
      if (bytes.length === 1 && bytes[0] < 128)
        return bytes;
      return new Uint8Array([...encodeLength(bytes.length, 128), ...bytes]);
    }
    exports.bytesToRlp = bytesToRlp;
    function encodeLength(length, offset) {
      if (length < 56)
        return [offset + length];
      return [(0, toBytes_js_1.toBytes)(length).length + offset + 55, ...(0, toBytes_js_1.toBytes)(length)];
    }
  }
});

// node_modules/viem/_cjs/utils/unit/formatEther.js
var require_formatEther = __commonJS({
  "node_modules/viem/_cjs/utils/unit/formatEther.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatEther = void 0;
    var unit_js_1 = require_unit();
    var formatUnits_js_1 = require_formatUnits();
    function formatEther(wei, unit = "wei") {
      return (0, formatUnits_js_1.formatUnits)(wei, unit_js_1.etherUnits[unit]);
    }
    exports.formatEther = formatEther;
  }
});

// node_modules/viem/_cjs/errors/transaction.js
var require_transaction2 = __commonJS({
  "node_modules/viem/_cjs/errors/transaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WaitForTransactionReceiptTimeoutError = exports.TransactionReceiptNotFoundError = exports.TransactionNotFoundError = exports.TransactionExecutionError = exports.InvalidStorageKeySizeError = exports.InvalidSerializedTransactionError = exports.InvalidSerializedTransactionTypeError = exports.InvalidSerializableTransactionError = exports.InvalidLegacyVError = exports.FeeConflictError = exports.prettyPrint = void 0;
    var formatEther_js_1 = require_formatEther();
    var formatGwei_js_1 = require_formatGwei();
    var base_js_1 = require_base();
    function prettyPrint(args) {
      const entries = Object.entries(args).map(([key, value]) => {
        if (value === void 0 || value === false)
          return null;
        return [key, value];
      }).filter(Boolean);
      const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0);
      return entries.map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`).join("\n");
    }
    exports.prettyPrint = prettyPrint;
    var FeeConflictError = class extends base_js_1.BaseError {
      constructor() {
        super([
          "Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.",
          "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."
        ].join("\n"));
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "FeeConflictError"
        });
      }
    };
    exports.FeeConflictError = FeeConflictError;
    var InvalidLegacyVError = class extends base_js_1.BaseError {
      constructor({ v }) {
        super(`Invalid \`v\` value "${v}". Expected 27 or 28.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidLegacyVError"
        });
      }
    };
    exports.InvalidLegacyVError = InvalidLegacyVError;
    var InvalidSerializableTransactionError = class extends base_js_1.BaseError {
      constructor({ transaction }) {
        super("Cannot infer a transaction type from provided transaction.", {
          metaMessages: [
            "Provided Transaction:",
            "{",
            prettyPrint(transaction),
            "}",
            "",
            "To infer the type, either provide:",
            "- a `type` to the Transaction, or",
            "- an EIP-1559 Transaction with `maxFeePerGas`, or",
            "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
            "- a Legacy Transaction with `gasPrice`"
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidSerializableTransactionError"
        });
      }
    };
    exports.InvalidSerializableTransactionError = InvalidSerializableTransactionError;
    var InvalidSerializedTransactionTypeError = class extends base_js_1.BaseError {
      constructor({ serializedType }) {
        super(`Serialized transaction type "${serializedType}" is invalid.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidSerializedTransactionType"
        });
        Object.defineProperty(this, "serializedType", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.serializedType = serializedType;
      }
    };
    exports.InvalidSerializedTransactionTypeError = InvalidSerializedTransactionTypeError;
    var InvalidSerializedTransactionError = class extends base_js_1.BaseError {
      constructor({ attributes, serializedTransaction, type }) {
        const missing = Object.entries(attributes).map(([key, value]) => typeof value === "undefined" ? key : void 0).filter(Boolean);
        super(`Invalid serialized transaction of type "${type}" was provided.`, {
          metaMessages: [
            `Serialized Transaction: "${serializedTransaction}"`,
            missing.length > 0 ? `Missing Attributes: ${missing.join(", ")}` : ""
          ].filter(Boolean)
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidSerializedTransactionError"
        });
        Object.defineProperty(this, "serializedTransaction", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "type", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.serializedTransaction = serializedTransaction;
        this.type = type;
      }
    };
    exports.InvalidSerializedTransactionError = InvalidSerializedTransactionError;
    var InvalidStorageKeySizeError = class extends base_js_1.BaseError {
      constructor({ storageKey }) {
        super(`Size for storage key "${storageKey}" is invalid. Expected 32 bytes. Got ${Math.floor((storageKey.length - 2) / 2)} bytes.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidStorageKeySizeError"
        });
      }
    };
    exports.InvalidStorageKeySizeError = InvalidStorageKeySizeError;
    var TransactionExecutionError = class extends base_js_1.BaseError {
      constructor(cause, { account, docsPath, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
        const prettyArgs = prettyPrint({
          chain: chain && `${chain?.name} (id: ${chain?.id})`,
          from: account?.address,
          to,
          value: typeof value !== "undefined" && `${(0, formatEther_js_1.formatEther)(value)} ${chain?.nativeCurrency.symbol || "ETH"}`,
          data,
          gas,
          gasPrice: typeof gasPrice !== "undefined" && `${(0, formatGwei_js_1.formatGwei)(gasPrice)} gwei`,
          maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${(0, formatGwei_js_1.formatGwei)(maxFeePerGas)} gwei`,
          maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${(0, formatGwei_js_1.formatGwei)(maxPriorityFeePerGas)} gwei`,
          nonce
        });
        super(cause.shortMessage, {
          cause,
          docsPath,
          metaMessages: [
            ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
            "Request Arguments:",
            prettyArgs
          ].filter(Boolean)
        });
        Object.defineProperty(this, "cause", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "TransactionExecutionError"
        });
        this.cause = cause;
      }
    };
    exports.TransactionExecutionError = TransactionExecutionError;
    var TransactionNotFoundError = class extends base_js_1.BaseError {
      constructor({ blockHash, blockNumber, blockTag, hash, index }) {
        let identifier = "Transaction";
        if (blockTag && index !== void 0)
          identifier = `Transaction at block time "${blockTag}" at index "${index}"`;
        if (blockHash && index !== void 0)
          identifier = `Transaction at block hash "${blockHash}" at index "${index}"`;
        if (blockNumber && index !== void 0)
          identifier = `Transaction at block number "${blockNumber}" at index "${index}"`;
        if (hash)
          identifier = `Transaction with hash "${hash}"`;
        super(`${identifier} could not be found.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "TransactionNotFoundError"
        });
      }
    };
    exports.TransactionNotFoundError = TransactionNotFoundError;
    var TransactionReceiptNotFoundError = class extends base_js_1.BaseError {
      constructor({ hash }) {
        super(`Transaction receipt with hash "${hash}" could not be found. The Transaction may not be processed on a block yet.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "TransactionReceiptNotFoundError"
        });
      }
    };
    exports.TransactionReceiptNotFoundError = TransactionReceiptNotFoundError;
    var WaitForTransactionReceiptTimeoutError = class extends base_js_1.BaseError {
      constructor({ hash }) {
        super(`Timed out while waiting for transaction with hash "${hash}" to be confirmed.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "WaitForTransactionReceiptTimeoutError"
        });
      }
    };
    exports.WaitForTransactionReceiptTimeoutError = WaitForTransactionReceiptTimeoutError;
  }
});

// node_modules/viem/_cjs/utils/transaction/serializeAccessList.js
var require_serializeAccessList = __commonJS({
  "node_modules/viem/_cjs/utils/transaction/serializeAccessList.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serializeAccessList = void 0;
    var address_js_1 = require_address();
    var transaction_js_1 = require_transaction2();
    var isAddress_js_1 = require_isAddress();
    function serializeAccessList(accessList) {
      if (!accessList || accessList.length === 0)
        return [];
      const serializedAccessList = [];
      for (let i = 0; i < accessList.length; i++) {
        const { address, storageKeys } = accessList[i];
        for (let j = 0; j < storageKeys.length; j++) {
          if (storageKeys[j].length - 2 !== 64) {
            throw new transaction_js_1.InvalidStorageKeySizeError({ storageKey: storageKeys[j] });
          }
        }
        if (!(0, isAddress_js_1.isAddress)(address)) {
          throw new address_js_1.InvalidAddressError({ address });
        }
        serializedAccessList.push([address, storageKeys]);
      }
      return serializedAccessList;
    }
    exports.serializeAccessList = serializeAccessList;
  }
});

// node_modules/viem/_cjs/utils/transaction/assertTransaction.js
var require_assertTransaction = __commonJS({
  "node_modules/viem/_cjs/utils/transaction/assertTransaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assertTransactionLegacy = exports.assertTransactionEIP2930 = exports.assertTransactionEIP1559 = void 0;
    var address_js_1 = require_address();
    var base_js_1 = require_base();
    var chain_js_1 = require_chain();
    var node_js_1 = require_node();
    var isAddress_js_1 = require_isAddress();
    function assertTransactionEIP1559(transaction) {
      const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } = transaction;
      if (chainId <= 0)
        throw new chain_js_1.InvalidChainIdError({ chainId });
      if (to && !(0, isAddress_js_1.isAddress)(to))
        throw new address_js_1.InvalidAddressError({ address: to });
      if (gasPrice)
        throw new base_js_1.BaseError("`gasPrice` is not a valid EIP-1559 Transaction attribute.");
      if (maxFeePerGas && maxFeePerGas > 2n ** 256n - 1n)
        throw new node_js_1.FeeCapTooHighError({ maxFeePerGas });
      if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
        throw new node_js_1.TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
    }
    exports.assertTransactionEIP1559 = assertTransactionEIP1559;
    function assertTransactionEIP2930(transaction) {
      const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } = transaction;
      if (chainId <= 0)
        throw new chain_js_1.InvalidChainIdError({ chainId });
      if (to && !(0, isAddress_js_1.isAddress)(to))
        throw new address_js_1.InvalidAddressError({ address: to });
      if (maxPriorityFeePerGas || maxFeePerGas)
        throw new base_js_1.BaseError("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.");
      if (gasPrice && gasPrice > 2n ** 256n - 1n)
        throw new node_js_1.FeeCapTooHighError({ maxFeePerGas: gasPrice });
    }
    exports.assertTransactionEIP2930 = assertTransactionEIP2930;
    function assertTransactionLegacy(transaction) {
      const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to, accessList } = transaction;
      if (to && !(0, isAddress_js_1.isAddress)(to))
        throw new address_js_1.InvalidAddressError({ address: to });
      if (typeof chainId !== "undefined" && chainId <= 0)
        throw new chain_js_1.InvalidChainIdError({ chainId });
      if (maxPriorityFeePerGas || maxFeePerGas)
        throw new base_js_1.BaseError("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.");
      if (gasPrice && gasPrice > 2n ** 256n - 1n)
        throw new node_js_1.FeeCapTooHighError({ maxFeePerGas: gasPrice });
      if (accessList)
        throw new base_js_1.BaseError("`accessList` is not a valid Legacy Transaction attribute.");
    }
    exports.assertTransactionLegacy = assertTransactionLegacy;
  }
});

// node_modules/viem/_cjs/utils/transaction/getTransactionType.js
var require_getTransactionType = __commonJS({
  "node_modules/viem/_cjs/utils/transaction/getTransactionType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTransactionType = void 0;
    var transaction_js_1 = require_transaction2();
    function getTransactionType(transaction) {
      if (transaction.type)
        return transaction.type;
      if (typeof transaction.maxFeePerGas !== "undefined" || typeof transaction.maxPriorityFeePerGas !== "undefined")
        return "eip1559";
      if (typeof transaction.gasPrice !== "undefined") {
        if (typeof transaction.accessList !== "undefined")
          return "eip2930";
        return "legacy";
      }
      throw new transaction_js_1.InvalidSerializableTransactionError({ transaction });
    }
    exports.getTransactionType = getTransactionType;
  }
});

// node_modules/viem/_cjs/utils/transaction/serializeTransaction.js
var require_serializeTransaction = __commonJS({
  "node_modules/viem/_cjs/utils/transaction/serializeTransaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serializeTransaction = void 0;
    var transaction_js_1 = require_transaction2();
    var concat_js_1 = require_concat();
    var trim_js_1 = require_trim();
    var toHex_js_1 = require_toHex();
    var toRlp_js_1 = require_toRlp();
    var assertTransaction_js_1 = require_assertTransaction();
    var getTransactionType_js_1 = require_getTransactionType();
    var serializeAccessList_js_1 = require_serializeAccessList();
    function serializeTransaction(transaction, signature) {
      const type = (0, getTransactionType_js_1.getTransactionType)(transaction);
      if (type === "eip1559")
        return serializeTransactionEIP1559(transaction, signature);
      if (type === "eip2930")
        return serializeTransactionEIP2930(transaction, signature);
      return serializeTransactionLegacy(transaction, signature);
    }
    exports.serializeTransaction = serializeTransaction;
    function serializeTransactionEIP1559(transaction, signature) {
      const { chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data } = transaction;
      (0, assertTransaction_js_1.assertTransactionEIP1559)(transaction);
      const serializedAccessList = (0, serializeAccessList_js_1.serializeAccessList)(accessList);
      const serializedTransaction = [
        (0, toHex_js_1.toHex)(chainId),
        nonce ? (0, toHex_js_1.toHex)(nonce) : "0x",
        maxPriorityFeePerGas ? (0, toHex_js_1.toHex)(maxPriorityFeePerGas) : "0x",
        maxFeePerGas ? (0, toHex_js_1.toHex)(maxFeePerGas) : "0x",
        gas ? (0, toHex_js_1.toHex)(gas) : "0x",
        to ?? "0x",
        value ? (0, toHex_js_1.toHex)(value) : "0x",
        data ?? "0x",
        serializedAccessList
      ];
      if (signature)
        serializedTransaction.push(signature.v === 27n ? "0x" : (0, toHex_js_1.toHex)(1), (0, trim_js_1.trim)(signature.r), (0, trim_js_1.trim)(signature.s));
      return (0, concat_js_1.concatHex)([
        "0x02",
        (0, toRlp_js_1.toRlp)(serializedTransaction)
      ]);
    }
    function serializeTransactionEIP2930(transaction, signature) {
      const { chainId, gas, data, nonce, to, value, accessList, gasPrice } = transaction;
      (0, assertTransaction_js_1.assertTransactionEIP2930)(transaction);
      const serializedAccessList = (0, serializeAccessList_js_1.serializeAccessList)(accessList);
      const serializedTransaction = [
        (0, toHex_js_1.toHex)(chainId),
        nonce ? (0, toHex_js_1.toHex)(nonce) : "0x",
        gasPrice ? (0, toHex_js_1.toHex)(gasPrice) : "0x",
        gas ? (0, toHex_js_1.toHex)(gas) : "0x",
        to ?? "0x",
        value ? (0, toHex_js_1.toHex)(value) : "0x",
        data ?? "0x",
        serializedAccessList
      ];
      if (signature)
        serializedTransaction.push(signature.v === 27n ? "0x" : (0, toHex_js_1.toHex)(1), signature.r, signature.s);
      return (0, concat_js_1.concatHex)([
        "0x01",
        (0, toRlp_js_1.toRlp)(serializedTransaction)
      ]);
    }
    function serializeTransactionLegacy(transaction, signature) {
      const { chainId = 0, gas, data, nonce, to, value, gasPrice } = transaction;
      (0, assertTransaction_js_1.assertTransactionLegacy)(transaction);
      let serializedTransaction = [
        nonce ? (0, toHex_js_1.toHex)(nonce) : "0x",
        gasPrice ? (0, toHex_js_1.toHex)(gasPrice) : "0x",
        gas ? (0, toHex_js_1.toHex)(gas) : "0x",
        to ?? "0x",
        value ? (0, toHex_js_1.toHex)(value) : "0x",
        data ?? "0x"
      ];
      if (signature) {
        let v = 27n + (signature.v === 27n ? 0n : 1n);
        if (chainId > 0)
          v = BigInt(chainId * 2) + BigInt(35n + signature.v - 27n);
        else if (signature.v !== v)
          throw new transaction_js_1.InvalidLegacyVError({ v: signature.v });
        serializedTransaction = [
          ...serializedTransaction,
          (0, toHex_js_1.toHex)(v),
          signature.r,
          signature.s
        ];
      } else if (chainId > 0) {
        serializedTransaction = [
          ...serializedTransaction,
          (0, toHex_js_1.toHex)(chainId),
          "0x",
          "0x"
        ];
      }
      return (0, toRlp_js_1.toRlp)(serializedTransaction);
    }
  }
});

// node_modules/viem/_cjs/chains/celo/serializers.js
var require_serializers = __commonJS({
  "node_modules/viem/_cjs/chains/celo/serializers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assertTransactionCIP42 = exports.serializersCelo = exports.serializeTransactionCelo = void 0;
    var address_js_1 = require_address();
    var base_js_1 = require_base();
    var chain_js_1 = require_chain();
    var node_js_1 = require_node();
    var isAddress_js_1 = require_isAddress();
    var concat_js_1 = require_concat();
    var trim_js_1 = require_trim();
    var toHex_js_1 = require_toHex();
    var toRlp_js_1 = require_toRlp();
    var serializeAccessList_js_1 = require_serializeAccessList();
    var serializeTransaction_js_1 = require_serializeTransaction();
    var serializeTransactionCelo = (tx, signature) => {
      if (isCIP42(tx))
        return serializeTransactionCIP42(tx, signature);
      return (0, serializeTransaction_js_1.serializeTransaction)(tx, signature);
    };
    exports.serializeTransactionCelo = serializeTransactionCelo;
    exports.serializersCelo = {
      transaction: exports.serializeTransactionCelo
    };
    function serializeTransactionCIP42(transaction, signature) {
      assertTransactionCIP42(transaction);
      const { chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, feeCurrency, gatewayFeeRecipient, gatewayFee, data } = transaction;
      const serializedTransaction = [
        (0, toHex_js_1.toHex)(chainId),
        nonce ? (0, toHex_js_1.toHex)(nonce) : "0x",
        maxPriorityFeePerGas ? (0, toHex_js_1.toHex)(maxPriorityFeePerGas) : "0x",
        maxFeePerGas ? (0, toHex_js_1.toHex)(maxFeePerGas) : "0x",
        gas ? (0, toHex_js_1.toHex)(gas) : "0x",
        feeCurrency ?? "0x",
        gatewayFeeRecipient ?? "0x",
        gatewayFee ? (0, toHex_js_1.toHex)(gatewayFee) : "0x",
        to ?? "0x",
        value ? (0, toHex_js_1.toHex)(value) : "0x",
        data ?? "0x",
        (0, serializeAccessList_js_1.serializeAccessList)(accessList)
      ];
      if (signature) {
        serializedTransaction.push(signature.v === 27n ? "0x" : (0, toHex_js_1.toHex)(1), (0, trim_js_1.trim)(signature.r), (0, trim_js_1.trim)(signature.s));
      }
      return (0, concat_js_1.concatHex)([
        "0x7c",
        (0, toRlp_js_1.toRlp)(serializedTransaction)
      ]);
    }
    function isCIP42(transaction) {
      if ("maxFeePerGas" in transaction && "maxPriorityFeePerGas" in transaction && ("feeCurrency" in transaction || "gatewayFee" in transaction || "gatewayFeeRecipient" in transaction))
        return true;
      return false;
    }
    var MAX_MAX_FEE_PER_GAS = 115792089237316195423570985008687907853269984665640564039457584007913129639935n;
    function assertTransactionCIP42(transaction) {
      const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to, feeCurrency, gatewayFee, gatewayFeeRecipient } = transaction;
      if (chainId <= 0)
        throw new chain_js_1.InvalidChainIdError({ chainId });
      if (to && !(0, isAddress_js_1.isAddress)(to))
        throw new address_js_1.InvalidAddressError({ address: to });
      if (gasPrice)
        throw new base_js_1.BaseError("`gasPrice` is not a valid CIP-42 Transaction attribute.");
      if (maxFeePerGas && maxFeePerGas > MAX_MAX_FEE_PER_GAS)
        throw new node_js_1.FeeCapTooHighError({ maxFeePerGas });
      if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
        throw new node_js_1.TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
      if (gatewayFee && !gatewayFeeRecipient || gatewayFeeRecipient && !gatewayFee) {
        throw new base_js_1.BaseError("`gatewayFee` and `gatewayFeeRecipient` must be provided together.");
      }
      if (feeCurrency && !feeCurrency?.startsWith("0x")) {
        throw new base_js_1.BaseError("`feeCurrency` MUST be a token address for CIP-42 transactions.");
      }
      if (!feeCurrency && !gatewayFeeRecipient) {
        throw new base_js_1.BaseError("Either `feeCurrency` or `gatewayFeeRecipient` must be provided for CIP-42 transactions.");
      }
    }
    exports.assertTransactionCIP42 = assertTransactionCIP42;
  }
});

// node_modules/viem/_cjs/chains/definitions/celo.js
var require_celo = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/celo.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.celo = void 0;
    var chain_js_1 = require_chain2();
    var formatters_js_1 = require_formatters2();
    var serializers_js_1 = require_serializers();
    exports.celo = (0, chain_js_1.defineChain)({
      id: 42220,
      name: "Celo",
      network: "celo",
      nativeCurrency: {
        decimals: 18,
        name: "CELO",
        symbol: "CELO"
      },
      rpcUrls: {
        default: { http: ["https://forno.celo.org"] },
        infura: {
          http: ["https://celo-mainnet.infura.io/v3"]
        },
        public: {
          http: ["https://forno.celo.org"]
        }
      },
      blockExplorers: {
        default: {
          name: "Celo Explorer",
          url: "https://explorer.celo.org/mainnet"
        },
        etherscan: { name: "CeloScan", url: "https://celoscan.io" }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 13112599
        }
      },
      testnet: false
    }, {
      formatters: formatters_js_1.formattersCelo,
      serializers: serializers_js_1.serializersCelo
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/celoAlfajores.js
var require_celoAlfajores = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/celoAlfajores.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.celoAlfajores = void 0;
    var chain_js_1 = require_chain2();
    var formatters_js_1 = require_formatters2();
    var serializers_js_1 = require_serializers();
    exports.celoAlfajores = (0, chain_js_1.defineChain)({
      id: 44787,
      name: "Alfajores",
      network: "celo-alfajores",
      nativeCurrency: {
        decimals: 18,
        name: "CELO",
        symbol: "A-CELO"
      },
      rpcUrls: {
        default: {
          http: ["https://alfajores-forno.celo-testnet.org"]
        },
        infura: {
          http: ["https://celo-alfajores.infura.io/v3"]
        },
        public: {
          http: ["https://alfajores-forno.celo-testnet.org"]
        }
      },
      blockExplorers: {
        default: {
          name: "Celo Explorer",
          url: "https://explorer.celo.org/alfajores"
        },
        etherscan: { name: "CeloScan", url: "https://alfajores.celoscan.io/" }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 14569001
        }
      },
      testnet: true
    }, {
      formatters: formatters_js_1.formattersCelo,
      serializers: serializers_js_1.serializersCelo
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/celoCannoli.js
var require_celoCannoli = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/celoCannoli.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.celoCannoli = void 0;
    var chain_js_1 = require_chain2();
    var formatters_js_1 = require_formatters2();
    var serializers_js_1 = require_serializers();
    exports.celoCannoli = (0, chain_js_1.defineChain)({
      id: 17323,
      name: "Cannoli",
      network: "celo-cannoli",
      nativeCurrency: {
        decimals: 18,
        name: "CELO",
        symbol: "C-CELO"
      },
      rpcUrls: {
        default: {
          http: ["https://forno.cannoli.celo-testnet.org"]
        },
        public: {
          http: ["https://forno.cannoli.celo-testnet.org"]
        }
      },
      blockExplorers: {
        default: {
          name: "Celo Explorer",
          url: "https://explorer.celo.org/cannoli"
        }
      },
      contracts: {
        multicall3: {
          address: "0x5Acb0aa8BF4E8Ff0d882Ee187140713C12BF9718",
          blockCreated: 87429
        }
      },
      testnet: true
    }, {
      formatters: formatters_js_1.formattersCelo,
      serializers: serializers_js_1.serializersCelo
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/classic.js
var require_classic = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/classic.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.classic = void 0;
    var chain_js_1 = require_chain2();
    exports.classic = (0, chain_js_1.defineChain)({
      id: 61,
      name: "Ethereum Classic",
      network: "classic",
      nativeCurrency: {
        decimals: 18,
        name: "ETC",
        symbol: "ETC"
      },
      rpcUrls: {
        default: { http: ["https://etc.rivet.link"] },
        public: { http: ["https://etc.rivet.link"] }
      },
      blockExplorers: {
        default: {
          name: "Blockscout",
          url: "https://blockscout.com/etc/mainnet"
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/confluxESpace.js
var require_confluxESpace = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/confluxESpace.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.confluxESpace = void 0;
    var chain_js_1 = require_chain2();
    exports.confluxESpace = (0, chain_js_1.defineChain)({
      id: 1030,
      name: "Conflux eSpace",
      network: "cfx-espace",
      nativeCurrency: { name: "Conflux", symbol: "CFX", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://evm.confluxrpc.org"]
        },
        public: {
          http: ["https://evm.confluxrpc.org"]
        }
      },
      blockExplorers: {
        default: {
          name: "ConfluxScan",
          url: "https://evm.confluxscan.io"
        }
      },
      contracts: {
        multicall3: {
          address: "0xEFf0078910f638cd81996cc117bccD3eDf2B072F",
          blockCreated: 68602935
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/cronos.js
var require_cronos = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/cronos.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.cronos = void 0;
    var chain_js_1 = require_chain2();
    exports.cronos = (0, chain_js_1.defineChain)({
      id: 25,
      name: "Cronos Mainnet",
      network: "cronos",
      nativeCurrency: {
        decimals: 18,
        name: "Cronos",
        symbol: "CRO"
      },
      rpcUrls: {
        default: { http: ["https://evm.cronos.org"] },
        public: { http: ["https://evm.cronos.org"] }
      },
      blockExplorers: {
        default: { name: "Cronoscan", url: "https://cronoscan.com" }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 1963112
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/cronosTestnet.js
var require_cronosTestnet = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/cronosTestnet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.cronosTestnet = void 0;
    var chain_js_1 = require_chain2();
    exports.cronosTestnet = (0, chain_js_1.defineChain)({
      id: 338,
      name: "Cronos Testnet",
      network: "cronos-testnet",
      nativeCurrency: {
        decimals: 18,
        name: "CRO",
        symbol: "tCRO"
      },
      rpcUrls: {
        default: { http: ["https://evm-t3.cronos.org"] },
        public: { http: ["https://evm-t3.cronos.org"] }
      },
      blockExplorers: {
        default: {
          name: "Cronos Explorer",
          url: "https://cronos.org/explorer/testnet3"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 10191251
        }
      },
      testnet: true
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/crossbell.js
var require_crossbell = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/crossbell.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crossbell = void 0;
    var chain_js_1 = require_chain2();
    exports.crossbell = (0, chain_js_1.defineChain)({
      id: 3737,
      network: "crossbell",
      name: "Crossbell",
      nativeCurrency: {
        decimals: 18,
        name: "CSB",
        symbol: "CSB"
      },
      rpcUrls: {
        default: {
          http: ["https://rpc.crossbell.io"]
        },
        public: {
          http: ["https://rpc.crossbell.io"]
        }
      },
      blockExplorers: {
        default: { name: "CrossScan", url: "https://scan.crossbell.io" }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 38246031
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/dfk.js
var require_dfk = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/dfk.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dfk = void 0;
    var chain_js_1 = require_chain2();
    exports.dfk = (0, chain_js_1.defineChain)({
      id: 53935,
      name: "DFK Chain",
      network: "dfk",
      nativeCurrency: {
        decimals: 18,
        name: "Jewel",
        symbol: "JEWEL"
      },
      rpcUrls: {
        default: {
          http: ["https://subnets.avax.network/defi-kingdoms/dfk-chain/rpc"]
        },
        public: {
          http: ["https://subnets.avax.network/defi-kingdoms/dfk-chain/rpc"]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "DFKSubnetScan",
          url: "https://subnets.avax.network/defi-kingdoms"
        },
        default: {
          name: "DFKSubnetScan",
          url: "https://subnets.avax.network/defi-kingdoms"
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/dogechain.js
var require_dogechain = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/dogechain.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dogechain = void 0;
    var chain_js_1 = require_chain2();
    exports.dogechain = (0, chain_js_1.defineChain)({
      id: 2e3,
      name: "Dogechain",
      network: "dogechain",
      nativeCurrency: {
        decimals: 18,
        name: "Dogechain",
        symbol: "DC"
      },
      rpcUrls: {
        default: { http: ["https://rpc.dogechain.dog"] },
        public: { http: ["https://rpc.dogechain.dog"] }
      },
      blockExplorers: {
        etherscan: {
          name: "DogeChainExplorer",
          url: "https://explorer.dogechain.dog"
        },
        default: {
          name: "DogeChainExplorer",
          url: "https://explorer.dogechain.dog"
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/edgeware.js
var require_edgeware = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/edgeware.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.edgeware = void 0;
    var chain_js_1 = require_chain2();
    exports.edgeware = (0, chain_js_1.defineChain)({
      id: 2021,
      name: "Edgeware EdgeEVM Mainnet",
      network: "edgeware",
      nativeCurrency: {
        decimals: 18,
        name: "Edgeware",
        symbol: "EDG"
      },
      rpcUrls: {
        default: { http: ["https://edgeware-evm.jelliedowl.net"] },
        public: { http: ["https://edgeware-evm.jelliedowl.net"] }
      },
      blockExplorers: {
        etherscan: { name: "Edgscan by Bharathcoorg", url: "https://edgscan.live" },
        default: { name: "Edgscan by Bharathcoorg", url: "https://edgscan.live" }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 18117872
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/edgewareTestnet.js
var require_edgewareTestnet = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/edgewareTestnet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.edgewareTestnet = void 0;
    var chain_js_1 = require_chain2();
    exports.edgewareTestnet = (0, chain_js_1.defineChain)({
      id: 2022,
      name: "Beresheet BereEVM Testnet",
      network: "edgewareTestnet",
      nativeCurrency: {
        decimals: 18,
        name: "Testnet EDG",
        symbol: "tEDG"
      },
      rpcUrls: {
        default: { http: ["https://beresheet-evm.jelliedowl.net"] },
        public: { http: ["https://beresheet-evm.jelliedowl.net"] }
      },
      blockExplorers: {
        etherscan: {
          name: "Edgscan by Bharathcoorg",
          url: "https://testnet.edgscan.live"
        },
        default: {
          name: "Edgscan by Bharathcoorg",
          url: "https://testnet.edgscan.live"
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/eos.js
var require_eos = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/eos.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.eos = void 0;
    var chain_js_1 = require_chain2();
    exports.eos = (0, chain_js_1.defineChain)({
      id: 17777,
      name: "EOS EVM",
      network: "eos",
      nativeCurrency: {
        decimals: 18,
        name: "EOS",
        symbol: "EOS"
      },
      rpcUrls: {
        default: { http: ["https://api.evm.eosnetwork.com"] },
        public: { http: ["https://api.evm.eosnetwork.com"] }
      },
      blockExplorers: {
        etherscan: {
          name: "EOS EVM Explorer",
          url: "https://explorer.evm.eosnetwork.com"
        },
        default: {
          name: "EOS EVM Explorer",
          url: "https://explorer.evm.eosnetwork.com"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 7943933
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/eosTestnet.js
var require_eosTestnet = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/eosTestnet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.eosTestnet = void 0;
    var chain_js_1 = require_chain2();
    exports.eosTestnet = (0, chain_js_1.defineChain)({
      id: 15557,
      name: "EOS EVM Testnet",
      network: "eos",
      nativeCurrency: {
        decimals: 18,
        name: "EOS",
        symbol: "EOS"
      },
      rpcUrls: {
        default: { http: ["https://api.testnet.evm.eosnetwork.com"] },
        public: { http: ["https://api.testnet.evm.eosnetwork.com"] }
      },
      blockExplorers: {
        etherscan: {
          name: "EOS EVM Testnet Explorer",
          url: "https://explorer.testnet.evm.eosnetwork.com"
        },
        default: {
          name: "EOS EVM Testnet Explorer",
          url: "https://explorer.testnet.evm.eosnetwork.com"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 9067940
        }
      },
      testnet: true
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/evmos.js
var require_evmos = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/evmos.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.evmos = void 0;
    var chain_js_1 = require_chain2();
    exports.evmos = (0, chain_js_1.defineChain)({
      id: 9001,
      name: "Evmos",
      network: "evmos",
      nativeCurrency: {
        decimals: 18,
        name: "Evmos",
        symbol: "EVMOS"
      },
      rpcUrls: {
        default: { http: ["https://eth.bd.evmos.org:8545"] },
        public: { http: ["https://eth.bd.evmos.org:8545"] }
      },
      blockExplorers: {
        default: { name: "Evmos Block Explorer", url: "https://escan.live" }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/evmosTestnet.js
var require_evmosTestnet = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/evmosTestnet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.evmosTestnet = void 0;
    var chain_js_1 = require_chain2();
    exports.evmosTestnet = (0, chain_js_1.defineChain)({
      id: 9e3,
      name: "Evmos Testnet",
      network: "evmos-testnet",
      nativeCurrency: {
        decimals: 18,
        name: "Evmos",
        symbol: "EVMOS"
      },
      rpcUrls: {
        default: { http: ["https://eth.bd.evmos.dev:8545"] },
        public: { http: ["https://eth.bd.evmos.dev:8545"] }
      },
      blockExplorers: {
        default: {
          name: "Evmos Testnet Block Explorer",
          url: "https://evm.evmos.dev/"
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/ekta.js
var require_ekta = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/ekta.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ekta = void 0;
    var chain_js_1 = require_chain2();
    exports.ekta = (0, chain_js_1.defineChain)({
      id: 1994,
      name: "Ekta",
      network: "ekta",
      nativeCurrency: {
        decimals: 18,
        name: "EKTA",
        symbol: "EKTA"
      },
      rpcUrls: {
        public: { http: ["https://main.ekta.io"] },
        default: { http: ["https://main.ekta.io"] }
      },
      blockExplorers: {
        default: { name: "Ektascan", url: "https://ektascan.io" }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/ektaTestnet.js
var require_ektaTestnet = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/ektaTestnet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ektaTestnet = void 0;
    var chain_js_1 = require_chain2();
    exports.ektaTestnet = (0, chain_js_1.defineChain)({
      id: 1004,
      name: "Ekta Testnet",
      network: "ekta-testnet",
      nativeCurrency: {
        decimals: 18,
        name: "EKTA",
        symbol: "EKTA"
      },
      rpcUrls: {
        public: { http: ["https://test.ekta.io:8545"] },
        default: { http: ["https://test.ekta.io:8545"] }
      },
      blockExplorers: {
        default: { name: "Test Ektascan", url: "https://test.ektascan.io" }
      },
      testnet: true
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/fantom.js
var require_fantom = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/fantom.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fantom = void 0;
    var chain_js_1 = require_chain2();
    exports.fantom = (0, chain_js_1.defineChain)({
      id: 250,
      name: "Fantom",
      network: "fantom",
      nativeCurrency: {
        decimals: 18,
        name: "Fantom",
        symbol: "FTM"
      },
      rpcUrls: {
        default: { http: ["https://rpc.ankr.com/fantom"] },
        public: { http: ["https://rpc.ankr.com/fantom"] }
      },
      blockExplorers: {
        etherscan: { name: "FTMScan", url: "https://ftmscan.com" },
        default: { name: "FTMScan", url: "https://ftmscan.com" }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 33001987
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/fantomTestnet.js
var require_fantomTestnet = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/fantomTestnet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fantomTestnet = void 0;
    var chain_js_1 = require_chain2();
    exports.fantomTestnet = (0, chain_js_1.defineChain)({
      id: 4002,
      name: "Fantom Testnet",
      network: "fantom-testnet",
      nativeCurrency: {
        decimals: 18,
        name: "Fantom",
        symbol: "FTM"
      },
      rpcUrls: {
        default: { http: ["https://rpc.testnet.fantom.network"] },
        public: { http: ["https://rpc.testnet.fantom.network"] }
      },
      blockExplorers: {
        etherscan: { name: "FTMScan", url: "https://testnet.ftmscan.com" },
        default: { name: "FTMScan", url: "https://testnet.ftmscan.com" }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 8328688
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/fibo.js
var require_fibo = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/fibo.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fibo = void 0;
    var chain_js_1 = require_chain2();
    exports.fibo = (0, chain_js_1.defineChain)({
      id: 12306,
      name: "Fibo Chain",
      network: "fibochain",
      nativeCurrency: {
        decimals: 18,
        name: "fibo",
        symbol: "FIBO"
      },
      rpcUrls: {
        default: { http: ["https://network.hzroc.art"] },
        public: { http: ["https://network.hzroc.art"] }
      },
      blockExplorers: {
        default: { name: "FiboScan", url: "https://scan.fibochain.org" }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/filecoin.js
var require_filecoin = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/filecoin.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.filecoin = void 0;
    var chain_js_1 = require_chain2();
    exports.filecoin = (0, chain_js_1.defineChain)({
      id: 314,
      name: "Filecoin Mainnet",
      network: "filecoin-mainnet",
      nativeCurrency: {
        decimals: 18,
        name: "filecoin",
        symbol: "FIL"
      },
      rpcUrls: {
        default: { http: ["https://api.node.glif.io/rpc/v1"] },
        public: { http: ["https://api.node.glif.io/rpc/v1"] }
      },
      blockExplorers: {
        default: { name: "Filfox", url: "https://filfox.info/en" },
        filscan: { name: "Filscan", url: "https://filscan.io" },
        filscout: { name: "Filscout", url: "https://filscout.io/en" },
        glif: { name: "Glif", url: "https://explorer.glif.io" }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/filecoinCalibration.js
var require_filecoinCalibration = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/filecoinCalibration.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.filecoinCalibration = void 0;
    var chain_js_1 = require_chain2();
    exports.filecoinCalibration = (0, chain_js_1.defineChain)({
      id: 314159,
      name: "Filecoin Calibration",
      network: "filecoin-calibration",
      nativeCurrency: {
        decimals: 18,
        name: "testnet filecoin",
        symbol: "tFIL"
      },
      rpcUrls: {
        default: { http: ["https://api.calibration.node.glif.io/rpc/v1"] },
        public: { http: ["https://api.calibration.node.glif.io/rpc/v1"] }
      },
      blockExplorers: {
        default: { name: "Filscan", url: "https://calibration.filscan.io" }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/filecoinHyperspace.js
var require_filecoinHyperspace = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/filecoinHyperspace.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.filecoinHyperspace = void 0;
    var chain_js_1 = require_chain2();
    exports.filecoinHyperspace = (0, chain_js_1.defineChain)({
      id: 3141,
      name: "Filecoin Hyperspace",
      network: "filecoin-hyperspace",
      nativeCurrency: {
        decimals: 18,
        name: "testnet filecoin",
        symbol: "tFIL"
      },
      rpcUrls: {
        default: { http: ["https://api.hyperspace.node.glif.io/rpc/v1"] },
        public: { http: ["https://api.hyperspace.node.glif.io/rpc/v1"] }
      },
      blockExplorers: {
        default: { name: "Filfox", url: "https://hyperspace.filfox.info/en" },
        filscan: { name: "Filscan", url: "https://hyperspace.filscan.io" }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/flare.js
var require_flare = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/flare.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.flare = void 0;
    var chain_js_1 = require_chain2();
    exports.flare = (0, chain_js_1.defineChain)({
      id: 14,
      name: "Flare Mainnet",
      network: "flare-mainnet",
      nativeCurrency: {
        decimals: 18,
        name: "flare",
        symbol: "FLR"
      },
      rpcUrls: {
        default: { http: ["https://flare-api.flare.network/ext/C/rpc"] },
        public: { http: ["https://flare-api.flare.network/ext/C/rpc"] }
      },
      blockExplorers: {
        default: {
          name: "Flare Explorer",
          url: "https://flare-explorer.flare.network"
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/flareTestnet.js
var require_flareTestnet = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/flareTestnet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.flareTestnet = void 0;
    var chain_js_1 = require_chain2();
    exports.flareTestnet = (0, chain_js_1.defineChain)({
      id: 114,
      name: "Coston2",
      network: "coston2",
      nativeCurrency: {
        decimals: 18,
        name: "coston2flare",
        symbol: "C2FLR"
      },
      rpcUrls: {
        default: { http: ["https://coston2-api.flare.network/ext/C/rpc"] },
        public: { http: ["https://coston2-api.flare.network/ext/C/rpc"] }
      },
      blockExplorers: {
        default: {
          name: "Coston2 Explorer",
          url: "https://coston2-explorer.flare.network"
        }
      },
      testnet: true
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/foundry.js
var require_foundry = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/foundry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.foundry = void 0;
    var chain_js_1 = require_chain2();
    exports.foundry = (0, chain_js_1.defineChain)({
      id: 31337,
      name: "Foundry",
      network: "foundry",
      nativeCurrency: {
        decimals: 18,
        name: "Ether",
        symbol: "ETH"
      },
      rpcUrls: {
        default: {
          http: ["http://127.0.0.1:8545"],
          webSocket: ["ws://127.0.0.1:8545"]
        },
        public: {
          http: ["http://127.0.0.1:8545"],
          webSocket: ["ws://127.0.0.1:8545"]
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/fuse.js
var require_fuse = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/fuse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fuse = void 0;
    var chain_js_1 = require_chain2();
    exports.fuse = (0, chain_js_1.defineChain)({
      id: 122,
      name: "Fuse",
      network: "fuse",
      nativeCurrency: { name: "Fuse", symbol: "FUSE", decimals: 18 },
      rpcUrls: {
        default: { http: ["https://rpc.fuse.io"] },
        public: { http: ["https://fuse-mainnet.chainstacklabs.com"] }
      },
      blockExplorers: {
        default: { name: "Fuse Explorer", url: "https://explorer.fuse.io" }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/fuseSparknet.js
var require_fuseSparknet = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/fuseSparknet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fuseSparknet = void 0;
    var chain_js_1 = require_chain2();
    exports.fuseSparknet = (0, chain_js_1.defineChain)({
      id: 123,
      name: "Fuse Sparknet",
      network: "fuse",
      nativeCurrency: { name: "Spark", symbol: "SPARK", decimals: 18 },
      rpcUrls: {
        default: { http: ["https://rpc.fusespark.io"] },
        public: { http: ["https://rpc.fusespark.io"] }
      },
      blockExplorers: {
        default: {
          name: "Sparkent Explorer",
          url: "https://explorer.fusespark.io"
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/iotex.js
var require_iotex = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/iotex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.iotex = void 0;
    var chain_js_1 = require_chain2();
    exports.iotex = (0, chain_js_1.defineChain)({
      id: 4689,
      name: "IoTeX",
      network: "iotex",
      nativeCurrency: {
        decimals: 18,
        name: "IoTeX",
        symbol: "IOTX"
      },
      rpcUrls: {
        default: {
          http: ["https://babel-api.mainnet.iotex.io"],
          webSocket: ["wss://babel-api.mainnet.iotex.io"]
        },
        public: {
          http: ["https://babel-api.mainnet.iotex.io"],
          webSocket: ["wss://babel-api.mainnet.iotex.io"]
        }
      },
      blockExplorers: {
        default: { name: "IoTeXScan", url: "https://iotexscan.io" }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/iotexTestnet.js
var require_iotexTestnet = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/iotexTestnet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.iotexTestnet = void 0;
    var chain_js_1 = require_chain2();
    exports.iotexTestnet = (0, chain_js_1.defineChain)({
      id: 4690,
      name: "IoTeX Testnet",
      network: "iotex-testnet",
      nativeCurrency: {
        decimals: 18,
        name: "IoTeX",
        symbol: "IOTX"
      },
      rpcUrls: {
        default: {
          http: ["https://babel-api.testnet.iotex.io"],
          webSocket: ["wss://babel-api.testnet.iotex.io"]
        },
        public: {
          http: ["https://babel-api.testnet.iotex.io"],
          webSocket: ["wss://babel-api.testnet.iotex.io"]
        }
      },
      blockExplorers: {
        default: { name: "IoTeXScan", url: "https://testnet.iotexscan.io" }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/gobi.js
var require_gobi = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/gobi.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.gobi = void 0;
    var chain_js_1 = require_chain2();
    exports.gobi = (0, chain_js_1.defineChain)({
      id: 1663,
      name: "Horizen Gobi Testnet",
      network: "gobi",
      nativeCurrency: {
        decimals: 18,
        name: "Test ZEN",
        symbol: "tZEN"
      },
      rpcUrls: {
        public: { http: ["https://gobi-testnet.horizenlabs.io/ethv1"] },
        default: { http: ["https://gobi-testnet.horizenlabs.io/ethv1"] }
      },
      blockExplorers: {
        default: { name: "Gobi Explorer", url: "https://gobi-explorer.horizen.io" }
      },
      contracts: {},
      testnet: true
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/goerli.js
var require_goerli = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/goerli.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.goerli = void 0;
    var chain_js_1 = require_chain2();
    exports.goerli = (0, chain_js_1.defineChain)({
      id: 5,
      network: "goerli",
      name: "Goerli",
      nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        alchemy: {
          http: ["https://eth-goerli.g.alchemy.com/v2"],
          webSocket: ["wss://eth-goerli.g.alchemy.com/v2"]
        },
        infura: {
          http: ["https://goerli.infura.io/v3"],
          webSocket: ["wss://goerli.infura.io/ws/v3"]
        },
        default: {
          http: ["https://rpc.ankr.com/eth_goerli"]
        },
        public: {
          http: ["https://rpc.ankr.com/eth_goerli"]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "Etherscan",
          url: "https://goerli.etherscan.io"
        },
        default: {
          name: "Etherscan",
          url: "https://goerli.etherscan.io"
        }
      },
      contracts: {
        ensRegistry: {
          address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
        },
        ensUniversalResolver: {
          address: "0x56522D00C410a43BFfDF00a9A569489297385790",
          blockCreated: 8765204
        },
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 6507670
        }
      },
      testnet: true
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/gnosis.js
var require_gnosis = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/gnosis.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.gnosis = void 0;
    var chain_js_1 = require_chain2();
    exports.gnosis = (0, chain_js_1.defineChain)({
      id: 100,
      name: "Gnosis",
      network: "gnosis",
      nativeCurrency: {
        decimals: 18,
        name: "Gnosis",
        symbol: "xDAI"
      },
      rpcUrls: {
        default: { http: ["https://rpc.gnosischain.com"] },
        public: { http: ["https://rpc.gnosischain.com"] }
      },
      blockExplorers: {
        etherscan: {
          name: "Gnosisscan",
          url: "https://gnosisscan.io"
        },
        default: {
          name: "Gnosis Chain Explorer",
          url: "https://blockscout.com/xdai/mainnet"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 21022491
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/gnosisChiado.js
var require_gnosisChiado = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/gnosisChiado.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.gnosisChiado = void 0;
    var chain_js_1 = require_chain2();
    exports.gnosisChiado = (0, chain_js_1.defineChain)({
      id: 10200,
      name: "Gnosis Chiado",
      network: "chiado",
      nativeCurrency: {
        decimals: 18,
        name: "Gnosis",
        symbol: "xDAI"
      },
      rpcUrls: {
        default: { http: ["https://rpc.chiadochain.net"] },
        public: { http: ["https://rpc.chiadochain.net"] }
      },
      blockExplorers: {
        default: {
          name: "Blockscout",
          url: "https://blockscout.chiadochain.net"
        }
      },
      testnet: true
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/hardhat.js
var require_hardhat = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/hardhat.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hardhat = void 0;
    var chain_js_1 = require_chain2();
    exports.hardhat = (0, chain_js_1.defineChain)({
      id: 31337,
      name: "Hardhat",
      network: "hardhat",
      nativeCurrency: {
        decimals: 18,
        name: "Ether",
        symbol: "ETH"
      },
      rpcUrls: {
        default: { http: ["http://127.0.0.1:8545"] },
        public: { http: ["http://127.0.0.1:8545"] }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/harmonyOne.js
var require_harmonyOne = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/harmonyOne.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.harmonyOne = void 0;
    var chain_js_1 = require_chain2();
    exports.harmonyOne = (0, chain_js_1.defineChain)({
      id: 16666e5,
      name: "Harmony One",
      network: "harmony",
      nativeCurrency: {
        name: "Harmony",
        symbol: "ONE",
        decimals: 18
      },
      rpcUrls: {
        public: { http: ["https://rpc.ankr.com/harmony"] },
        default: { http: ["https://rpc.ankr.com/harmony"] }
      },
      blockExplorers: {
        default: { name: "Harmony Explorer", url: "https://explorer.harmony.one" }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 24185753
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/haqqMainnet.js
var require_haqqMainnet = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/haqqMainnet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.haqqMainnet = void 0;
    var chain_js_1 = require_chain2();
    exports.haqqMainnet = (0, chain_js_1.defineChain)({
      id: 11235,
      name: "HAQQ Mainnet",
      network: "haqq-mainnet",
      nativeCurrency: {
        decimals: 18,
        name: "Islamic Coin",
        symbol: "ISLM"
      },
      rpcUrls: {
        default: {
          http: ["https://rpc.eth.haqq.network"]
        },
        public: {
          http: ["https://rpc.eth.haqq.network"]
        }
      },
      blockExplorers: {
        default: {
          name: "HAQQ Explorer",
          url: "https://explorer.haqq.network"
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/haqqTestedge2.js
var require_haqqTestedge2 = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/haqqTestedge2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.haqqTestedge2 = void 0;
    var chain_js_1 = require_chain2();
    exports.haqqTestedge2 = (0, chain_js_1.defineChain)({
      id: 54211,
      name: "HAQQ Testedge 2",
      network: "haqq-testedge-2",
      nativeCurrency: {
        decimals: 18,
        name: "Islamic Coin",
        symbol: "ISLMT"
      },
      rpcUrls: {
        default: {
          http: ["https://rpc.eth.testedge2.haqq.network"]
        },
        public: {
          http: ["https://rpc.eth.testedge2.haqq.network"]
        }
      },
      blockExplorers: {
        default: {
          name: "HAQQ Explorer",
          url: "https://explorer.testedge2.haqq.network"
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/holesky.js
var require_holesky = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/holesky.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.holesky = void 0;
    var chain_js_1 = require_chain2();
    exports.holesky = (0, chain_js_1.defineChain)({
      id: 17e3,
      network: "holesky",
      name: "Holesky",
      nativeCurrency: { name: "Holesky Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://rpc.holesky.ethpandaops.io"]
        },
        public: {
          http: ["https://rpc.holesky.ethpandaops.io"]
        }
      },
      contracts: {},
      testnet: true
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/klaytn.js
var require_klaytn = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/klaytn.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.klaytn = void 0;
    var chain_js_1 = require_chain2();
    exports.klaytn = (0, chain_js_1.defineChain)({
      id: 8217,
      name: "Klaytn",
      network: "klaytn",
      nativeCurrency: {
        decimals: 18,
        name: "Klaytn",
        symbol: "KLAY"
      },
      rpcUrls: {
        default: { http: ["https://cypress.fautor.app/archive"] },
        public: { http: ["https://cypress.fautor.app/archive"] }
      },
      blockExplorers: {
        etherscan: { name: "KlaytnScope", url: "https://scope.klaytn.com" },
        default: { name: "KlaytnScope", url: "https://scope.klaytn.com" }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/kroma.js
var require_kroma = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/kroma.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.kroma = void 0;
    var chain_js_1 = require_chain2();
    exports.kroma = (0, chain_js_1.defineChain)({
      id: 255,
      network: "kroma",
      name: "Kroma",
      nativeCurrency: { name: "ETH", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://api.kroma.network"]
        },
        public: {
          http: ["https://api.kroma.network"]
        }
      },
      blockExplorers: {
        default: {
          name: "Kroma Explorer",
          url: "https://blockscout.kroma.network"
        }
      },
      testnet: false
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/kromaSepolia.js
var require_kromaSepolia = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/kromaSepolia.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.kromaSepolia = void 0;
    var chain_js_1 = require_chain2();
    exports.kromaSepolia = (0, chain_js_1.defineChain)({
      id: 2358,
      network: "kroma-sepolia",
      name: "Kroma Sepolia",
      nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://api.sepolia.kroma.network"]
        },
        public: {
          http: ["https://api.sepolia.kroma.network"]
        }
      },
      blockExplorers: {
        default: {
          name: "Kroma Sepolia Explorer",
          url: "https://blockscout.sepolia.kroma.network"
        }
      },
      testnet: true
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/linea.js
var require_linea = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/linea.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.linea = void 0;
    var chain_js_1 = require_chain2();
    exports.linea = (0, chain_js_1.defineChain)({
      id: 59144,
      name: "Linea Mainnet",
      network: "linea-mainnet",
      nativeCurrency: { name: "Linea Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        infura: {
          http: ["https://linea-mainnet.infura.io/v3"],
          webSocket: ["wss://linea-mainnet.infura.io/ws/v3"]
        },
        default: {
          http: ["https://rpc.linea.build"],
          webSocket: ["wss://rpc.linea.build"]
        },
        public: {
          http: ["https://rpc.linea.build"],
          webSocket: ["wss://rpc.linea.build"]
        }
      },
      blockExplorers: {
        default: {
          name: "Etherscan",
          url: "https://lineascan.build"
        },
        etherscan: {
          name: "Etherscan",
          url: "https://lineascan.build"
        },
        blockscout: {
          name: "Blockscout",
          url: "https://explorer.linea.build"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 42
        }
      },
      testnet: false
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/lineaTestnet.js
var require_lineaTestnet = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/lineaTestnet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.lineaTestnet = void 0;
    var chain_js_1 = require_chain2();
    exports.lineaTestnet = (0, chain_js_1.defineChain)({
      id: 59140,
      name: "Linea Goerli Testnet",
      network: "linea-testnet",
      nativeCurrency: { name: "Linea Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        infura: {
          http: ["https://linea-goerli.infura.io/v3"],
          webSocket: ["wss://linea-goerli.infura.io/ws/v3"]
        },
        default: {
          http: ["https://rpc.goerli.linea.build"],
          webSocket: ["wss://rpc.goerli.linea.build"]
        },
        public: {
          http: ["https://rpc.goerli.linea.build"],
          webSocket: ["wss://rpc.goerli.linea.build"]
        }
      },
      blockExplorers: {
        default: {
          name: "Etherscan",
          url: "https://goerli.lineascan.build"
        },
        etherscan: {
          name: "Etherscan",
          url: "https://goerli.lineascan.build"
        },
        blockscout: {
          name: "Blockscout",
          url: "https://explorer.goerli.linea.build"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 498623
        }
      },
      testnet: true
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/localhost.js
var require_localhost = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/localhost.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.localhost = void 0;
    var chain_js_1 = require_chain2();
    exports.localhost = (0, chain_js_1.defineChain)({
      id: 1337,
      name: "Localhost",
      network: "localhost",
      nativeCurrency: {
        decimals: 18,
        name: "Ether",
        symbol: "ETH"
      },
      rpcUrls: {
        default: { http: ["http://127.0.0.1:8545"] },
        public: { http: ["http://127.0.0.1:8545"] }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/mainnet.js
var require_mainnet = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/mainnet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mainnet = void 0;
    var chain_js_1 = require_chain2();
    exports.mainnet = (0, chain_js_1.defineChain)({
      id: 1,
      network: "homestead",
      name: "Ethereum",
      nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        alchemy: {
          http: ["https://eth-mainnet.g.alchemy.com/v2"],
          webSocket: ["wss://eth-mainnet.g.alchemy.com/v2"]
        },
        infura: {
          http: ["https://mainnet.infura.io/v3"],
          webSocket: ["wss://mainnet.infura.io/ws/v3"]
        },
        default: {
          http: ["https://cloudflare-eth.com"]
        },
        public: {
          http: ["https://cloudflare-eth.com"]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "Etherscan",
          url: "https://etherscan.io"
        },
        default: {
          name: "Etherscan",
          url: "https://etherscan.io"
        }
      },
      contracts: {
        ensRegistry: {
          address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
        },
        ensUniversalResolver: {
          address: "0xc0497E381f536Be9ce14B0dD3817cBcAe57d2F62",
          blockCreated: 16966585
        },
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 14353601
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/mantle.js
var require_mantle = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/mantle.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mantle = void 0;
    var chain_js_1 = require_chain2();
    exports.mantle = (0, chain_js_1.defineChain)({
      id: 5e3,
      name: "Mantle",
      network: "mantle",
      nativeCurrency: {
        decimals: 18,
        name: "MNT",
        symbol: "MNT"
      },
      rpcUrls: {
        default: { http: ["https://rpc.mantle.xyz"] },
        public: { http: ["https://rpc.mantle.xyz"] }
      },
      blockExplorers: {
        etherscan: {
          name: "Mantle Explorer",
          url: "https://explorer.mantle.xyz"
        },
        default: {
          name: "Mantle Explorer",
          url: "https://explorer.mantle.xyz"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 304717
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/mantleTestnet.js
var require_mantleTestnet = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/mantleTestnet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mantleTestnet = void 0;
    var chain_js_1 = require_chain2();
    exports.mantleTestnet = (0, chain_js_1.defineChain)({
      id: 5001,
      name: "Mantle Testnet",
      network: "mantle",
      nativeCurrency: {
        decimals: 18,
        name: "MNT",
        symbol: "MNT"
      },
      rpcUrls: {
        default: { http: ["https://rpc.testnet.mantle.xyz"] },
        public: { http: ["https://rpc.testnet.mantle.xyz"] }
      },
      blockExplorers: {
        etherscan: {
          name: "Mantle Testnet Explorer",
          url: "https://explorer.testnet.mantle.xyz"
        },
        default: {
          name: "Mantle Testnet Explorer",
          url: "https://explorer.testnet.mantle.xyz"
        }
      },
      testnet: true
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/meter.js
var require_meter = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/meter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.meter = void 0;
    var chain_js_1 = require_chain2();
    exports.meter = (0, chain_js_1.defineChain)({
      id: 82,
      name: "Meter",
      network: "meter",
      nativeCurrency: {
        decimals: 18,
        name: "MTR",
        symbol: "MTR"
      },
      rpcUrls: {
        default: { http: ["https://rpc.meter.io"] },
        public: { http: ["https://rpc.meter.io"] }
      },
      blockExplorers: {
        default: { name: "MeterScan", url: "https://scan.meter.io" }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/meterTestnet.js
var require_meterTestnet = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/meterTestnet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.meterTestnet = void 0;
    var chain_js_1 = require_chain2();
    exports.meterTestnet = (0, chain_js_1.defineChain)({
      id: 83,
      name: "Meter Testnet",
      network: "meter-testnet",
      nativeCurrency: {
        decimals: 18,
        name: "MTR",
        symbol: "MTR"
      },
      rpcUrls: {
        default: { http: ["https://rpctest.meter.io"] },
        public: { http: ["https://rpctest.meter.io"] }
      },
      blockExplorers: {
        default: {
          name: "MeterTestnetScan",
          url: "https://scan-warringstakes.meter.io"
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/metis.js
var require_metis = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/metis.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.metis = void 0;
    var chain_js_1 = require_chain2();
    exports.metis = (0, chain_js_1.defineChain)({
      id: 1088,
      name: "Metis",
      network: "andromeda",
      nativeCurrency: {
        decimals: 18,
        name: "Metis",
        symbol: "METIS"
      },
      rpcUrls: {
        default: { http: ["https://andromeda.metis.io/?owner=1088"] },
        public: { http: ["https://andromeda.metis.io/?owner=1088"] }
      },
      blockExplorers: {
        default: {
          name: "Andromeda Explorer",
          url: "https://andromeda-explorer.metis.io"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 2338552
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/metisGoerli.js
var require_metisGoerli = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/metisGoerli.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.metisGoerli = void 0;
    var chain_js_1 = require_chain2();
    exports.metisGoerli = (0, chain_js_1.defineChain)({
      id: 599,
      name: "Metis Goerli",
      network: "metis-goerli",
      nativeCurrency: {
        decimals: 18,
        name: "Metis Goerli",
        symbol: "METIS"
      },
      rpcUrls: {
        default: { http: ["https://goerli.gateway.metisdevops.link"] },
        public: { http: ["https://goerli.gateway.metisdevops.link"] }
      },
      blockExplorers: {
        default: {
          name: "Metis Goerli Explorer",
          url: "https://goerli.explorer.metisdevops.link"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 1006207
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/mev.js
var require_mev = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/mev.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mev = void 0;
    var chain_js_1 = require_chain2();
    exports.mev = (0, chain_js_1.defineChain)({
      id: 7518,
      network: "MEVerse",
      name: "MEVerse Chain Mainnet",
      nativeCurrency: {
        decimals: 18,
        name: "MEVerse",
        symbol: "MEV"
      },
      rpcUrls: {
        default: {
          http: ["https://rpc.meversemainnet.io"]
        },
        public: {
          http: ["https://rpc.meversemainnet.io"]
        }
      },
      blockExplorers: {
        default: {
          name: "Explorer",
          url: "https://www.meversescan.io"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 86881340
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/mevTestnet.js
var require_mevTestnet = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/mevTestnet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mevTestnet = void 0;
    var chain_js_1 = require_chain2();
    exports.mevTestnet = (0, chain_js_1.defineChain)({
      id: 4759,
      network: "MEVerse Testnet",
      name: "MEVerse Chain Testnet",
      nativeCurrency: {
        decimals: 18,
        name: "MEVerse",
        symbol: "MEV"
      },
      rpcUrls: {
        default: {
          http: ["https://rpc.meversetestnet.io"]
        },
        public: {
          http: ["https://rpc.meversetestnet.io"]
        }
      },
      blockExplorers: {
        default: {
          name: "Explorer",
          url: "https://testnet.meversescan.io/"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 64371115
        }
      },
      testnet: true
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/modeTestnet.js
var require_modeTestnet = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/modeTestnet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.modeTestnet = void 0;
    var chain_js_1 = require_chain2();
    exports.modeTestnet = (0, chain_js_1.defineChain)({
      id: 919,
      name: "Mode Testnet",
      network: "mode-testnet",
      nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://sepolia.mode.network"]
        },
        public: {
          http: ["https://sepolia.mode.network"]
        }
      },
      blockExplorers: {
        default: {
          name: "Blockscout",
          url: "https://sepolia.explorer.mode.network"
        }
      },
      testnet: true
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/moonbaseAlpha.js
var require_moonbaseAlpha = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/moonbaseAlpha.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.moonbaseAlpha = void 0;
    var chain_js_1 = require_chain2();
    exports.moonbaseAlpha = (0, chain_js_1.defineChain)({
      id: 1287,
      name: "Moonbase Alpha",
      network: "moonbase-alpha",
      nativeCurrency: {
        decimals: 18,
        name: "DEV",
        symbol: "DEV"
      },
      rpcUrls: {
        default: {
          http: ["https://rpc.api.moonbase.moonbeam.network"],
          webSocket: ["wss://wss.api.moonbase.moonbeam.network"]
        },
        public: {
          http: ["https://rpc.api.moonbase.moonbeam.network"],
          webSocket: ["wss://wss.api.moonbase.moonbeam.network"]
        }
      },
      blockExplorers: {
        default: {
          name: "Moonscan",
          url: "https://moonbase.moonscan.io"
        },
        etherscan: {
          name: "Moonscan",
          url: "https://moonbase.moonscan.io"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 1850686
        }
      },
      testnet: true
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/moonbeam.js
var require_moonbeam = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/moonbeam.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.moonbeam = void 0;
    var chain_js_1 = require_chain2();
    exports.moonbeam = (0, chain_js_1.defineChain)({
      id: 1284,
      name: "Moonbeam",
      network: "moonbeam",
      nativeCurrency: {
        decimals: 18,
        name: "GLMR",
        symbol: "GLMR"
      },
      rpcUrls: {
        public: {
          http: ["https://moonbeam.public.blastapi.io"],
          webSocket: ["wss://moonbeam.public.blastapi.io"]
        },
        default: {
          http: ["https://moonbeam.public.blastapi.io"],
          webSocket: ["wss://moonbeam.public.blastapi.io"]
        }
      },
      blockExplorers: {
        default: {
          name: "Moonscan",
          url: "https://moonscan.io"
        },
        etherscan: {
          name: "Moonscan",
          url: "https://moonscan.io"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 609002
        }
      },
      testnet: false
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/moonriver.js
var require_moonriver = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/moonriver.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.moonriver = void 0;
    var chain_js_1 = require_chain2();
    exports.moonriver = (0, chain_js_1.defineChain)({
      id: 1285,
      name: "Moonriver",
      network: "moonriver",
      nativeCurrency: {
        decimals: 18,
        name: "MOVR",
        symbol: "MOVR"
      },
      rpcUrls: {
        public: {
          http: ["https://moonriver.public.blastapi.io"],
          webSocket: ["wss://moonriver.public.blastapi.io"]
        },
        default: {
          http: ["https://moonriver.public.blastapi.io"],
          webSocket: ["wss://moonriver.public.blastapi.io"]
        }
      },
      blockExplorers: {
        default: {
          name: "Moonscan",
          url: "https://moonriver.moonscan.io"
        },
        etherscan: {
          name: "Moonscan",
          url: "https://moonriver.moonscan.io"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 1597904
        }
      },
      testnet: false
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/neonDevnet.js
var require_neonDevnet = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/neonDevnet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.neonDevnet = void 0;
    var chain_js_1 = require_chain2();
    exports.neonDevnet = (0, chain_js_1.defineChain)({
      id: 245022926,
      network: "neonDevnet",
      name: "Neon EVM DevNet",
      nativeCurrency: { name: "NEON", symbol: "NEON", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://devnet.neonevm.org"]
        },
        public: {
          http: ["https://devnet.neonevm.org"]
        }
      },
      blockExplorers: {
        default: {
          name: "Neonscan",
          url: "https://neonscan.org"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 205206112
        }
      },
      testnet: true
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/nexi.js
var require_nexi = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/nexi.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.nexi = void 0;
    var chain_js_1 = require_chain2();
    exports.nexi = (0, chain_js_1.defineChain)({
      id: 4242,
      name: "Nexi",
      network: "nexi",
      nativeCurrency: { name: "Nexi", symbol: "NEXI", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://rpc.chain.nexi.technology"]
        },
        public: {
          http: ["https://rpc.chain.nexi.technology"]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "NexiScan",
          url: "https://www.nexiscan.com"
        },
        default: {
          name: "NexiScan",
          url: "https://www.nexiscan.com"
        }
      },
      contracts: {
        multicall3: {
          address: "0x0277A46Cc69A57eE3A6C8c158bA874832F718B8E",
          blockCreated: 25770160
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/nexilix.js
var require_nexilix = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/nexilix.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.nexilix = void 0;
    var chain_js_1 = require_chain2();
    exports.nexilix = (0, chain_js_1.defineChain)({
      id: 240,
      name: "Nexilix Smart Chain",
      network: "nexilix",
      nativeCurrency: {
        decimals: 18,
        name: "Nexilix",
        symbol: "NEXILIX"
      },
      rpcUrls: {
        default: { http: ["https://rpcurl.pos.nexilix.com"] },
        public: { http: ["https://rpcurl.pos.nexilix.com"] }
      },
      blockExplorers: {
        etherscan: { name: "NexilixScan", url: "https://scan.nexilix.com" },
        default: { name: "NexilixScan", url: "https://scan.nexilix.com" }
      },
      contracts: {
        multicall3: {
          address: "0x58381c8e2BF9d0C2C4259cA14BdA9Afe02831244",
          blockCreated: 74448
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/oasys.js
var require_oasys = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/oasys.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.oasys = void 0;
    var chain_js_1 = require_chain2();
    exports.oasys = (0, chain_js_1.defineChain)({
      id: 248,
      name: "Oasys",
      network: "oasys",
      nativeCurrency: { name: "Oasys", symbol: "OAS", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://rpc.mainnet.oasys.games"]
        },
        public: {
          http: ["https://rpc.mainnet.oasys.games"]
        }
      },
      blockExplorers: {
        default: {
          name: "OasysScan",
          url: "https://scan.oasys.games"
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/okc.js
var require_okc = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/okc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.okc = void 0;
    var chain_js_1 = require_chain2();
    exports.okc = (0, chain_js_1.defineChain)({
      id: 66,
      name: "OKC",
      network: "okc",
      nativeCurrency: {
        decimals: 18,
        name: "OKT",
        symbol: "OKT"
      },
      rpcUrls: {
        default: { http: ["https://exchainrpc.okex.org"] },
        public: { http: ["https://exchainrpc.okex.org"] }
      },
      blockExplorers: {
        default: { name: "oklink", url: "https://www.oklink.com/okc" }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 10364792
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/optimism.js
var require_optimism = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/optimism.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.optimism = void 0;
    var chain_js_1 = require_chain2();
    var formatters_js_1 = require_formatters();
    exports.optimism = (0, chain_js_1.defineChain)({
      id: 10,
      name: "OP Mainnet",
      network: "optimism",
      nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        alchemy: {
          http: ["https://opt-mainnet.g.alchemy.com/v2"],
          webSocket: ["wss://opt-mainnet.g.alchemy.com/v2"]
        },
        infura: {
          http: ["https://optimism-mainnet.infura.io/v3"],
          webSocket: ["wss://optimism-mainnet.infura.io/ws/v3"]
        },
        default: {
          http: ["https://mainnet.optimism.io"]
        },
        public: {
          http: ["https://mainnet.optimism.io"]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "Etherscan",
          url: "https://optimistic.etherscan.io"
        },
        default: {
          name: "Optimism Explorer",
          url: "https://explorer.optimism.io"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 4286263
        }
      }
    }, {
      formatters: formatters_js_1.formattersOptimism
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/optimismGoerli.js
var require_optimismGoerli = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/optimismGoerli.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.optimismGoerli = void 0;
    var chain_js_1 = require_chain2();
    var formatters_js_1 = require_formatters();
    exports.optimismGoerli = (0, chain_js_1.defineChain)({
      id: 420,
      name: "Optimism Goerli",
      network: "optimism-goerli",
      nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        alchemy: {
          http: ["https://opt-goerli.g.alchemy.com/v2"],
          webSocket: ["wss://opt-goerli.g.alchemy.com/v2"]
        },
        infura: {
          http: ["https://optimism-goerli.infura.io/v3"],
          webSocket: ["wss://optimism-goerli.infura.io/ws/v3"]
        },
        default: {
          http: ["https://goerli.optimism.io"]
        },
        public: {
          http: ["https://goerli.optimism.io"]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "Etherscan",
          url: "https://goerli-optimism.etherscan.io"
        },
        default: {
          name: "Etherscan",
          url: "https://goerli-optimism.etherscan.io"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 49461
        }
      },
      testnet: true
    }, {
      formatters: formatters_js_1.formattersOptimism
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/opBNB.js
var require_opBNB = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/opBNB.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.opBNB = void 0;
    var chain_js_1 = require_chain2();
    exports.opBNB = (0, chain_js_1.defineChain)({
      id: 204,
      name: "opBNB",
      network: "opBNB Mainnet",
      nativeCurrency: {
        name: "BNB",
        symbol: "BNB",
        decimals: 18
      },
      rpcUrls: {
        public: { http: ["https://opbnb-mainnet-rpc.bnbchain.org"] },
        default: { http: ["https://opbnb-mainnet-rpc.bnbchain.org"] }
      },
      blockExplorers: {
        default: { name: "opbnbscan", url: "https://mainnet.opbnbscan.com" }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 512881
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/opBNBTestnet.js
var require_opBNBTestnet = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/opBNBTestnet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.opBNBTestnet = void 0;
    var chain_js_1 = require_chain2();
    exports.opBNBTestnet = (0, chain_js_1.defineChain)({
      id: 5611,
      name: "opBNB Testnet",
      network: "opBNB Testnet",
      nativeCurrency: {
        decimals: 18,
        name: "tBNB",
        symbol: "tBNB"
      },
      rpcUrls: {
        public: { http: ["https://opbnb-testnet-rpc.bnbchain.org"] },
        default: { http: ["https://opbnb-testnet-rpc.bnbchain.org"] }
      },
      blockExplorers: {
        default: { name: "opbnbscan", url: "https://opbnbscan.com" }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 3705108
        }
      },
      testnet: true
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/plinga.js
var require_plinga = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/plinga.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.plinga = void 0;
    var chain_js_1 = require_chain2();
    exports.plinga = (0, chain_js_1.defineChain)({
      id: 242,
      name: "Plinga",
      network: "plinga",
      nativeCurrency: { name: "Plinga", symbol: "PLINGA", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://rpcurl.mainnet.plgchain.com"]
        },
        public: {
          http: ["https://rpcurl.mainnet.plgchain.com"]
        }
      },
      blockExplorers: {
        default: {
          name: "Plgscan",
          url: "https://www.plgscan.com"
        }
      },
      contracts: {
        multicall3: {
          address: "0x0989576160f2e7092908BB9479631b901060b6e4",
          blockCreated: 204489
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/polygon.js
var require_polygon = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/polygon.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.polygon = void 0;
    var chain_js_1 = require_chain2();
    exports.polygon = (0, chain_js_1.defineChain)({
      id: 137,
      name: "Polygon",
      network: "matic",
      nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
      rpcUrls: {
        alchemy: {
          http: ["https://polygon-mainnet.g.alchemy.com/v2"],
          webSocket: ["wss://polygon-mainnet.g.alchemy.com/v2"]
        },
        infura: {
          http: ["https://polygon-mainnet.infura.io/v3"],
          webSocket: ["wss://polygon-mainnet.infura.io/ws/v3"]
        },
        default: {
          http: ["https://polygon-rpc.com"]
        },
        public: {
          http: ["https://polygon-rpc.com"]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "PolygonScan",
          url: "https://polygonscan.com"
        },
        default: {
          name: "PolygonScan",
          url: "https://polygonscan.com"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 25770160
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/polygonMumbai.js
var require_polygonMumbai = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/polygonMumbai.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.polygonMumbai = void 0;
    var chain_js_1 = require_chain2();
    exports.polygonMumbai = (0, chain_js_1.defineChain)({
      id: 80001,
      name: "Polygon Mumbai",
      network: "maticmum",
      nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
      rpcUrls: {
        alchemy: {
          http: ["https://polygon-mumbai.g.alchemy.com/v2"],
          webSocket: ["wss://polygon-mumbai.g.alchemy.com/v2"]
        },
        infura: {
          http: ["https://polygon-mumbai.infura.io/v3"],
          webSocket: ["wss://polygon-mumbai.infura.io/ws/v3"]
        },
        default: {
          http: ["https://rpc.ankr.com/polygon_mumbai"]
        },
        public: {
          http: ["https://rpc.ankr.com/polygon_mumbai"]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "PolygonScan",
          url: "https://mumbai.polygonscan.com"
        },
        default: {
          name: "PolygonScan",
          url: "https://mumbai.polygonscan.com"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 25770160
        }
      },
      testnet: true
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/polygonZkEvmTestnet.js
var require_polygonZkEvmTestnet = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/polygonZkEvmTestnet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.polygonZkEvmTestnet = void 0;
    var chain_js_1 = require_chain2();
    exports.polygonZkEvmTestnet = (0, chain_js_1.defineChain)({
      id: 1442,
      name: "Polygon zkEVM Testnet",
      network: "polygon-zkevm-testnet",
      nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://rpc.public.zkevm-test.net"]
        },
        public: {
          http: ["https://rpc.public.zkevm-test.net"]
        }
      },
      blockExplorers: {
        blockscout: {
          name: "Blockscout",
          url: "https://explorer.public.zkevm-test.net"
        },
        default: {
          name: "PolygonScan",
          url: "https://testnet-zkevm.polygonscan.com"
        }
      },
      testnet: true,
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 525686
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/polygonZkEvm.js
var require_polygonZkEvm = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/polygonZkEvm.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.polygonZkEvm = void 0;
    var chain_js_1 = require_chain2();
    exports.polygonZkEvm = (0, chain_js_1.defineChain)({
      id: 1101,
      name: "Polygon zkEVM",
      network: "polygon-zkevm",
      nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://zkevm-rpc.com"]
        },
        public: {
          http: ["https://zkevm-rpc.com"]
        }
      },
      blockExplorers: {
        default: {
          name: "PolygonScan",
          url: "https://zkevm.polygonscan.com"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 57746
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/pulsechain.js
var require_pulsechain = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/pulsechain.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pulsechain = void 0;
    var chain_js_1 = require_chain2();
    exports.pulsechain = (0, chain_js_1.defineChain)({
      id: 369,
      network: "pulsechain",
      name: "PulseChain",
      nativeCurrency: { name: "Pulse", symbol: "PLS", decimals: 18 },
      testnet: false,
      rpcUrls: {
        default: {
          http: ["https://rpc.pulsechain.com"],
          webSocket: ["wss://ws.pulsechain.com"]
        },
        public: {
          http: ["https://rpc.pulsechain.com"],
          webSocket: ["wss://ws.pulsechain.com"]
        }
      },
      blockExplorers: {
        default: {
          name: "PulseScan",
          url: "https://scan.pulsechain.com"
        }
      },
      contracts: {
        ensRegistry: {
          address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
        },
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 14353601
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/pulsechainV4.js
var require_pulsechainV4 = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/pulsechainV4.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pulsechainV4 = void 0;
    var chain_js_1 = require_chain2();
    exports.pulsechainV4 = (0, chain_js_1.defineChain)({
      id: 943,
      network: "pulsechainV4",
      name: "PulseChain V4",
      testnet: true,
      nativeCurrency: { name: "V4 Pulse", symbol: "v4PLS", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://rpc.v4.testnet.pulsechain.com"],
          webSocket: ["wss://ws.v4.testnet.pulsechain.com"]
        },
        public: {
          http: ["https://rpc.v4.testnet.pulsechain.com"],
          webSocket: ["wss://ws.v4.testnet.pulsechain.com"]
        }
      },
      blockExplorers: {
        default: {
          name: "PulseScan",
          url: "https://scan.v4.testnet.pulsechain.com"
        }
      },
      contracts: {
        ensRegistry: {
          address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
        },
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 14353601
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/qMainnet.js
var require_qMainnet = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/qMainnet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.qMainnet = void 0;
    var chain_js_1 = require_chain2();
    exports.qMainnet = (0, chain_js_1.defineChain)({
      id: 35441,
      name: "Q Mainnet",
      network: "q-mainnet",
      nativeCurrency: {
        decimals: 18,
        name: "Q",
        symbol: "Q"
      },
      rpcUrls: {
        default: { http: ["https://rpc.q.org"] },
        public: { http: ["https://rpc.q.org"] }
      },
      blockExplorers: {
        default: {
          name: "Q Mainnet Explorer",
          url: "https://explorer.q.org"
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/qTestnet.js
var require_qTestnet = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/qTestnet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.qTestnet = void 0;
    var chain_js_1 = require_chain2();
    exports.qTestnet = (0, chain_js_1.defineChain)({
      id: 35443,
      name: "Q Testnet",
      network: "q-testnet",
      nativeCurrency: {
        decimals: 18,
        name: "Q",
        symbol: "Q"
      },
      rpcUrls: {
        default: { http: ["https://rpc.qtestnet.org"] },
        public: { http: ["https://rpc.qtestnet.org"] }
      },
      blockExplorers: {
        default: {
          name: "Q Testnet Explorer",
          url: "https://explorer.qtestnet.org"
        }
      },
      testnet: true
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/rollux.js
var require_rollux = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/rollux.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rollux = void 0;
    var chain_js_1 = require_chain2();
    exports.rollux = (0, chain_js_1.defineChain)({
      id: 570,
      name: "Rollux Mainnet",
      network: "rollux",
      nativeCurrency: {
        decimals: 18,
        name: "Syscoin",
        symbol: "SYS"
      },
      rpcUrls: {
        default: {
          http: ["https://rpc.rollux.com"],
          webSocket: ["wss://rpc.rollux.com/wss"]
        },
        public: { http: ["https://rollux.public-rpc.com"] }
      },
      blockExplorers: {
        default: { name: "RolluxExplorer", url: "https://explorer.rollux.com" }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 119222
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/rolluxTestnet.js
var require_rolluxTestnet = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/rolluxTestnet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rolluxTestnet = void 0;
    var chain_js_1 = require_chain2();
    exports.rolluxTestnet = (0, chain_js_1.defineChain)({
      id: 57e3,
      name: "Rollux Testnet",
      network: "rollux-testnet",
      nativeCurrency: {
        decimals: 18,
        name: "Syscoin",
        symbol: "SYS"
      },
      rpcUrls: {
        default: {
          http: ["https://rpc-tanenbaum.rollux.com/"],
          webSocket: ["wss://rpc-tanenbaum.rollux.com/wss"]
        },
        public: { http: ["https://rpc-tanenbaum.rollux.com/"] }
      },
      blockExplorers: {
        default: {
          name: "RolluxTestnetExplorer",
          url: "https://rollux.tanenbaum.io"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 1813675
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/ronin.js
var require_ronin = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/ronin.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ronin = void 0;
    var chain_js_1 = require_chain2();
    exports.ronin = (0, chain_js_1.defineChain)({
      id: 2020,
      name: "Ronin",
      network: "ronin",
      nativeCurrency: { name: "RON", symbol: "RON", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://api.roninchain.com/rpc"]
        },
        public: {
          http: ["https://api.roninchain.com/rpc"]
        }
      },
      blockExplorers: {
        default: { name: "Ronin Explorer", url: "https://app.roninchain.com" }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 26023535
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/saigon.js
var require_saigon = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/saigon.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.saigon = void 0;
    var chain_js_1 = require_chain2();
    exports.saigon = (0, chain_js_1.defineChain)({
      id: 2021,
      name: "Saigon Testnet",
      network: "saigon",
      nativeCurrency: { name: "RON", symbol: "RON", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://saigon-testnet.roninchain.com/rpc"]
        },
        public: {
          http: ["https://saigon-testnet.roninchain.com/rpc"]
        }
      },
      blockExplorers: {
        default: {
          name: "Saigon Explorer",
          url: "https://saigon-explorer.roninchain.com"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 18736871
        }
      },
      testnet: true
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/scrollSepolia.js
var require_scrollSepolia = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/scrollSepolia.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.scrollSepolia = void 0;
    var chain_js_1 = require_chain2();
    exports.scrollSepolia = (0, chain_js_1.defineChain)({
      id: 534351,
      name: "Scroll Sepolia",
      network: "scroll-sepolia",
      nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://sepolia-rpc.scroll.io"],
          webSocket: ["wss://sepolia-rpc.scroll.io/ws"]
        },
        public: {
          http: ["https://sepolia-rpc.scroll.io"],
          webSocket: ["wss://sepolia-rpc.scroll.io/ws"]
        }
      },
      blockExplorers: {
        default: {
          name: "Blockscout",
          url: "https://sepolia-blockscout.scroll.io"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 9473
        }
      },
      testnet: true
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/scrollTestnet.js
var require_scrollTestnet = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/scrollTestnet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.scrollTestnet = void 0;
    var chain_js_1 = require_chain2();
    exports.scrollTestnet = (0, chain_js_1.defineChain)({
      id: 534353,
      name: "Scroll Testnet",
      network: "scroll-testnet",
      nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://alpha-rpc.scroll.io/l2"],
          webSocket: ["wss://alpha-rpc.scroll.io/l2/ws"]
        },
        public: {
          http: ["https://alpha-rpc.scroll.io/l2"],
          webSocket: ["wss://alpha-rpc.scroll.io/l2/ws"]
        }
      },
      blockExplorers: {
        default: {
          name: "Blockscout",
          url: "https://blockscout.scroll.io"
        }
      },
      testnet: true
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/sepolia.js
var require_sepolia = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/sepolia.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sepolia = void 0;
    var chain_js_1 = require_chain2();
    exports.sepolia = (0, chain_js_1.defineChain)({
      id: 11155111,
      network: "sepolia",
      name: "Sepolia",
      nativeCurrency: { name: "Sepolia Ether", symbol: "SEP", decimals: 18 },
      rpcUrls: {
        alchemy: {
          http: ["https://eth-sepolia.g.alchemy.com/v2"],
          webSocket: ["wss://eth-sepolia.g.alchemy.com/v2"]
        },
        infura: {
          http: ["https://sepolia.infura.io/v3"],
          webSocket: ["wss://sepolia.infura.io/ws/v3"]
        },
        default: {
          http: ["https://rpc.sepolia.org"]
        },
        public: {
          http: ["https://rpc.sepolia.org"]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "Etherscan",
          url: "https://sepolia.etherscan.io"
        },
        default: {
          name: "Etherscan",
          url: "https://sepolia.etherscan.io"
        }
      },
      contracts: {
        multicall3: {
          address: "0xca11bde05977b3631167028862be2a173976ca11",
          blockCreated: 6507670
        },
        ensRegistry: { address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e" },
        ensUniversalResolver: {
          address: "0x21B000Fd62a880b2125A61e36a284BB757b76025",
          blockCreated: 3914906
        }
      },
      testnet: true
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/skale/brawl.js
var require_brawl = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/skale/brawl.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skaleBlockBrawlers = void 0;
    var chain_js_1 = require_chain2();
    exports.skaleBlockBrawlers = (0, chain_js_1.defineChain)({
      id: 391845894,
      name: "SKALE | Block Brawlers",
      network: "skale-brawl",
      nativeCurrency: { name: "BRAWL", symbol: "BRAWL", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://mainnet.skalenodes.com/v1/frayed-decent-antares"],
          webSocket: ["wss://mainnet.skalenodes.com/v1/ws/frayed-decent-antares"]
        },
        public: {
          http: ["https://mainnet.skalenodes.com/v1/frayed-decent-antares"],
          webSocket: ["wss://mainnet.skalenodes.com/v1/ws/frayed-decent-antares"]
        }
      },
      blockExplorers: {
        blockscout: {
          name: "SKALE Explorer",
          url: "https://frayed-decent-antares.explorer.mainnet.skalenodes.com"
        },
        default: {
          name: "SKALE Explorer",
          url: "https://frayed-decent-antares.explorer.mainnet.skalenodes.com"
        }
      },
      contracts: {}
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/skale/calypso.js
var require_calypso = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/skale/calypso.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skaleCalypso = void 0;
    var chain_js_1 = require_chain2();
    exports.skaleCalypso = (0, chain_js_1.defineChain)({
      id: 1564830818,
      name: "SKALE | Calypso NFT Hub",
      network: "skale-calypso",
      nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://mainnet.skalenodes.com/v1/honorable-steel-rasalhague"],
          webSocket: [
            "wss://mainnet.skalenodes.com/v1/ws/honorable-steel-rasalhague"
          ]
        },
        public: {
          http: ["https://mainnet.skalenodes.com/v1/honorable-steel-rasalhague"],
          webSocket: [
            "wss://mainnet.skalenodes.com/v1/ws/honorable-steel-rasalhague"
          ]
        }
      },
      blockExplorers: {
        blockscout: {
          name: "SKALE Explorer",
          url: "https://honorable-steel-rasalhague.explorer.mainnet.skalenodes.com"
        },
        default: {
          name: "SKALE Explorer",
          url: "https://honorable-steel-rasalhague.explorer.mainnet.skalenodes.com"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 3107626
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/skale/calypsoTestnet.js
var require_calypsoTestnet = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/skale/calypsoTestnet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skaleCalypsoTestnet = void 0;
    var chain_js_1 = require_chain2();
    exports.skaleCalypsoTestnet = (0, chain_js_1.defineChain)({
      id: 344106930,
      name: "SKALE | Calypso NFT Hub Testnet",
      network: "skale-calypso-testnet",
      nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
      rpcUrls: {
        default: {
          http: [
            "https://staging-v3.skalenodes.com/v1/staging-utter-unripe-menkar"
          ],
          webSocket: [
            "wss://staging-v3.skalenodes.com/v1/ws/staging-utter-unripe-menkar"
          ]
        },
        public: {
          http: [
            "https://staging-v3.skalenodes.com/v1/staging-utter-unripe-menkar"
          ],
          webSocket: [
            "wss://staging-v3.skalenodes.com/v1/ws/staging-utter-unripe-menkar"
          ]
        }
      },
      blockExplorers: {
        blockscout: {
          name: "SKALE Explorer",
          url: "https://staging-utter-unripe-menkar.explorer.staging-v3.skalenodes.com"
        },
        default: {
          name: "SKALE Explorer",
          url: "https://staging-utter-unripe-menkar.explorer.staging-v3.skalenodes.com"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 2131424
        }
      },
      testnet: true
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/skale/chaosTestnet.js
var require_chaosTestnet = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/skale/chaosTestnet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skaleChaosTestnet = void 0;
    var chain_js_1 = require_chain2();
    exports.skaleChaosTestnet = (0, chain_js_1.defineChain)({
      id: 1351057110,
      name: "SKALE | Chaos Testnet",
      network: "skale-chaos-testnet",
      nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
      rpcUrls: {
        default: {
          http: [
            "https://staging-v3.skalenodes.com/v1/staging-fast-active-bellatrix"
          ],
          webSocket: [
            "wss://staging-v3.skalenodes.com/v1/ws/staging-fast-active-bellatrix"
          ]
        },
        public: {
          http: [
            "https://staging-v3.skalenodes.com/v1/staging-fast-active-bellatrix"
          ],
          webSocket: [
            "wss://staging-v3.skalenodes.com/v1/ws/staging-fast-active-bellatrix"
          ]
        }
      },
      blockExplorers: {
        blockscout: {
          name: "SKALE Explorer",
          url: "https://staging-fast-active-bellatrix.explorer.staging-v3.skalenodes.com"
        },
        default: {
          name: "SKALE Explorer",
          url: "https://staging-fast-active-bellatrix.explorer.staging-v3.skalenodes.com"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 1192202
        }
      },
      testnet: true
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/skale/cryptoBlades.js
var require_cryptoBlades = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/skale/cryptoBlades.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skaleCryptoBlades = void 0;
    var chain_js_1 = require_chain2();
    exports.skaleCryptoBlades = (0, chain_js_1.defineChain)({
      id: 1026062157,
      name: "SKALE | CryptoBlades",
      network: "skale-cryptoblades",
      nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://mainnet.skalenodes.com/v1/affectionate-immediate-pollux"],
          webSocket: [
            "wss://mainnet.skalenodes.com/v1/ws/affectionate-immediate-pollux"
          ]
        },
        public: {
          http: ["https://mainnet.skalenodes.com/v1/affectionate-immediate-pollux"],
          webSocket: [
            "wss://mainnet.skalenodes.com/v1/ws/affectionate-immediate-pollux"
          ]
        }
      },
      blockExplorers: {
        blockscout: {
          name: "SKALE Explorer",
          url: "https://affectionate-immediate-pollux.explorer.mainnet.skalenodes.com"
        },
        default: {
          name: "SKALE Explorer",
          url: "https://affectionate-immediate-pollux.explorer.mainnet.skalenodes.com"
        }
      },
      contracts: {}
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/skale/cryptoColosseum.js
var require_cryptoColosseum = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/skale/cryptoColosseum.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skaleCryptoColosseum = void 0;
    var chain_js_1 = require_chain2();
    exports.skaleCryptoColosseum = (0, chain_js_1.defineChain)({
      id: 2046399126,
      name: "SKALE | Crypto Colosseum",
      network: "skale-crypto-coloseeum",
      nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://mainnet.skalenodes.com/v1/haunting-devoted-deneb"],
          webSocket: ["wss://mainnet.skalenodes.com/v1/ws/haunting-devoted-deneb"]
        },
        public: {
          http: ["https://mainnet.skalenodes.com/v1/haunting-devoted-deneb"],
          webSocket: ["wss://mainnet.skalenodes.com/v1/ws/haunting-devoted-deneb"]
        }
      },
      blockExplorers: {
        blockscout: {
          name: "SKALE Explorer",
          url: "https://haunting-devoted-deneb.explorer.mainnet.skalenodes.com"
        },
        default: {
          name: "SKALE Explorer",
          url: "https://haunting-devoted-deneb.explorer.mainnet.skalenodes.com"
        }
      },
      contracts: {}
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/skale/europa.js
var require_europa = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/skale/europa.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skaleEuropa = void 0;
    var chain_js_1 = require_chain2();
    exports.skaleEuropa = (0, chain_js_1.defineChain)({
      id: 2046399126,
      name: "SKALE | Europa Liquidity Hub",
      network: "skale-europa",
      nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://mainnet.skalenodes.com/v1/elated-tan-skat"],
          webSocket: ["wss://mainnet.skalenodes.com/v1/ws/elated-tan-skat"]
        },
        public: {
          http: ["https://mainnet.skalenodes.com/v1/elated-tan-skat"],
          webSocket: ["wss://mainnet.skalenodes.com/v1/ws/elated-tan-skat"]
        }
      },
      blockExplorers: {
        blockscout: {
          name: "SKALE Explorer",
          url: "https://elated-tan-skat.explorer.mainnet.skalenodes.com"
        },
        default: {
          name: "SKALE Explorer",
          url: "https://elated-tan-skat.explorer.mainnet.skalenodes.com"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 3113495
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/skale/europaTestnet.js
var require_europaTestnet = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/skale/europaTestnet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skaleEuropaTestnet = void 0;
    var chain_js_1 = require_chain2();
    exports.skaleEuropaTestnet = (0, chain_js_1.defineChain)({
      id: 476158412,
      name: "SKALE | Europa Liquidity Hub Testnet",
      network: "skale-europa-testnet",
      nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://staging-v3.skalenodes.com/v1/staging-legal-crazy-castor"],
          webSocket: [
            "wss://staging-v3.skalenodes.com/v1/ws/staging-legal-crazy-castor"
          ]
        },
        public: {
          http: ["https://staging-v3.skalenodes.com/v1/staging-legal-crazy-castor"],
          webSocket: [
            "wss://staging-v3.skalenodes.com/v1/ws/staging-legal-crazy-castor"
          ]
        }
      },
      blockExplorers: {
        blockscout: {
          name: "SKALE Explorer",
          url: "https://staging-legal-crazy-castor.explorer.staging-v3.skalenodes.com"
        },
        default: {
          name: "SKALE Explorer",
          url: "https://staging-legal-crazy-castor.explorer.staging-v3.skalenodes.com"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 2071911
        }
      },
      testnet: true
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/skale/exorde.js
var require_exorde = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/skale/exorde.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skaleExorde = void 0;
    var chain_js_1 = require_chain2();
    exports.skaleExorde = (0, chain_js_1.defineChain)({
      id: 2139927552,
      name: "SKALE | Exorde",
      network: "skale-exorde",
      nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://mainnet.skalenodes.com/v1/light-vast-diphda"],
          webSocket: ["wss://mainnet.skalenodes.com/v1/ws/light-vast-diphda"]
        },
        public: {
          http: ["https://mainnet.skalenodes.com/v1/light-vast-diphda"],
          webSocket: ["wss://mainnet.skalenodes.com/v1/ws/light-vast-diphda"]
        }
      },
      blockExplorers: {
        blockscout: {
          name: "SKALE Explorer",
          url: "https://light-vast-diphda.explorer.mainnet.skalenodes.com"
        },
        default: {
          name: "SKALE Explorer",
          url: "https://light-vast-diphda.explorer.mainnet.skalenodes.com"
        }
      },
      contracts: {}
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/skale/humanProtocol.js
var require_humanProtocol = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/skale/humanProtocol.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skaleHumanProtocol = void 0;
    var chain_js_1 = require_chain2();
    exports.skaleHumanProtocol = (0, chain_js_1.defineChain)({
      id: 1273227453,
      name: "SKALE | Human Protocol",
      network: "skale-human-protocol",
      nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://mainnet.skalenodes.com/v1/wan-red-ain"],
          webSocket: ["wss://mainnet.skalenodes.com/v1/ws/wan-red-ain"]
        },
        public: {
          http: ["https://mainnet.skalenodes.com/v1/wan-red-ain"],
          webSocket: ["wss://mainnet.skalenodes.com/v1/ws/wan-red-ain"]
        }
      },
      blockExplorers: {
        blockscout: {
          name: "SKALE Explorer",
          url: "https://wan-red-ain.explorer.mainnet.skalenodes.com"
        },
        default: {
          name: "SKALE Explorer",
          url: "https://wan-red-ain.explorer.mainnet.skalenodes.com"
        }
      },
      contracts: {}
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/skale/nebula.js
var require_nebula = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/skale/nebula.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skaleNebula = void 0;
    var chain_js_1 = require_chain2();
    exports.skaleNebula = (0, chain_js_1.defineChain)({
      id: 1482601649,
      name: "SKALE | Nebula Gaming Hub",
      network: "skale-nebula",
      nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://mainnet.skalenodes.com/v1/green-giddy-denebola"],
          webSocket: ["wss://mainnet.skalenodes.com/v1/ws/green-giddy-denebola"]
        },
        public: {
          http: ["https://mainnet.skalenodes.com/v1/green-giddy-denebola"],
          webSocket: ["wss://mainnet.skalenodes.com/v1/ws/green-giddy-denebola"]
        }
      },
      blockExplorers: {
        blockscout: {
          name: "SKALE Explorer",
          url: "https://green-giddy-denebola.explorer.mainnet.skalenodes.com"
        },
        default: {
          name: "SKALE Explorer",
          url: "https://green-giddy-denebola.explorer.mainnet.skalenodes.com"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 2372986
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/skale/nebulaTestnet.js
var require_nebulaTestnet = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/skale/nebulaTestnet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skaleNebulaTestnet = void 0;
    var chain_js_1 = require_chain2();
    exports.skaleNebulaTestnet = (0, chain_js_1.defineChain)({
      id: 503129905,
      name: "SKALE | Nebula Gaming Hub Testnet",
      network: "skale-nebula-testnet",
      nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://staging-v3.skalenodes.com/v1/staging-faint-slimy-achird"],
          webSocket: [
            "wss://staging-v3.skalenodes.com/v1/ws/staging-faint-slimy-achird"
          ]
        },
        public: {
          http: ["https://staging-v3.skalenodes.com/v1/staging-faint-slimy-achird"],
          webSocket: [
            "wss://staging-v3.skalenodes.com/v1/ws/staging-faint-slimy-achird"
          ]
        }
      },
      blockExplorers: {
        blockscout: {
          name: "SKALE Explorer",
          url: "https://staging-faint-slimy-achird.explorer.staging-v3.skalenodes.com"
        },
        default: {
          name: "SKALE Explorer",
          url: "https://staging-faint-slimy-achird.explorer.staging-v3.skalenodes.com"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 2205882
        }
      },
      testnet: true
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/skale/razor.js
var require_razor = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/skale/razor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skaleRazor = void 0;
    var chain_js_1 = require_chain2();
    exports.skaleRazor = (0, chain_js_1.defineChain)({
      id: 278611351,
      name: "SKALE | Razor Network",
      network: "skale-razor",
      nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://mainnet.skalenodes.com/v1/turbulent-unique-scheat"],
          webSocket: ["wss://mainnet.skalenodes.com/v1/ws/turbulent-unique-scheat"]
        },
        public: {
          http: ["https://mainnet.skalenodes.com/v1/turbulent-unique-scheat"],
          webSocket: ["wss://mainnet.skalenodes.com/v1/ws/turbulent-unique-scheat"]
        }
      },
      blockExplorers: {
        blockscout: {
          name: "SKALE Explorer",
          url: "https://turbulent-unique-scheat.explorer.mainnet.skalenodes.com"
        },
        default: {
          name: "SKALE Explorer",
          url: "https://turbulent-unique-scheat.explorer.mainnet.skalenodes.com"
        }
      },
      contracts: {}
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/skale/titan.js
var require_titan = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/skale/titan.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skaleTitan = void 0;
    var chain_js_1 = require_chain2();
    exports.skaleTitan = (0, chain_js_1.defineChain)({
      id: 1350216234,
      name: "SKALE | Titan Community Hub",
      network: "skale-titan",
      nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://mainnet.skalenodes.com/v1/parallel-stormy-spica"],
          webSocket: ["wss://mainnet.skalenodes.com/v1/ws/parallel-stormy-spica"]
        },
        public: {
          http: ["https://mainnet.skalenodes.com/v1/parallel-stormy-spica"],
          webSocket: ["wss://mainnet.skalenodes.com/v1/ws/parallel-stormy-spica"]
        }
      },
      blockExplorers: {
        blockscout: {
          name: "SKALE Explorer",
          url: "https://parallel-stormy-spica.explorer.mainnet.skalenodes.com"
        },
        default: {
          name: "SKALE Explorer",
          url: "https://parallel-stormy-spica.explorer.mainnet.skalenodes.com"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 2076458
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/skale/titanTestnet.js
var require_titanTestnet = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/skale/titanTestnet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.skaleTitanTestnet = void 0;
    var chain_js_1 = require_chain2();
    exports.skaleTitanTestnet = (0, chain_js_1.defineChain)({
      id: 1517929550,
      name: "SKALE | Titan Community Hub Testnet",
      network: "skale-titan-testnet",
      nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
      rpcUrls: {
        default: {
          http: [
            "https://staging-v3.skalenodes.com/v1/staging-aware-chief-gianfar"
          ],
          webSocket: [
            "wss://staging-v3.skalenodes.com/v1/ws/staging-aware-chief-gianfar"
          ]
        },
        public: {
          http: [
            "https://staging-v3.skalenodes.com/v1/staging-aware-chief-gianfar"
          ],
          webSocket: [
            "wss://staging-v3.skalenodes.com/v1/ws/staging-aware-chief-gianfar"
          ]
        }
      },
      blockExplorers: {
        blockscout: {
          name: "SKALE Explorer",
          url: "https://staging-aware-chief-gianfar.explorer.staging-v3.skalenodes.com"
        },
        default: {
          name: "SKALE Explorer",
          url: "https://staging-aware-chief-gianfar.explorer.staging-v3.skalenodes.com"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 2085155
        }
      },
      testnet: true
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/songbird.js
var require_songbird = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/songbird.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.songbird = void 0;
    var chain_js_1 = require_chain2();
    exports.songbird = (0, chain_js_1.defineChain)({
      id: 19,
      name: "Songbird Mainnet",
      network: "songbird-mainnet",
      nativeCurrency: {
        decimals: 18,
        name: "songbird",
        symbol: "SGB"
      },
      rpcUrls: {
        default: { http: ["https://songbird-api.flare.network/ext/C/rpc"] },
        public: { http: ["https://songbird-api.flare.network/ext/C/rpc"] }
      },
      blockExplorers: {
        default: {
          name: "Songbird Explorer",
          url: "https://songbird-explorer.flare.network"
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/songbirdTestnet.js
var require_songbirdTestnet = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/songbirdTestnet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.songbirdTestnet = void 0;
    var chain_js_1 = require_chain2();
    exports.songbirdTestnet = (0, chain_js_1.defineChain)({
      id: 16,
      name: "Coston",
      network: "coston",
      nativeCurrency: {
        decimals: 18,
        name: "costonflare",
        symbol: "CFLR"
      },
      rpcUrls: {
        default: { http: ["https://coston-api.flare.network/ext/C/rpc"] },
        public: { http: ["https://coston-api.flare.network/ext/C/rpc"] }
      },
      blockExplorers: {
        default: {
          name: "Coston Explorer",
          url: "https://coston-explorer.flare.network"
        }
      },
      testnet: true
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/shardeumSphinx.js
var require_shardeumSphinx = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/shardeumSphinx.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shardeumSphinx = void 0;
    var chain_js_1 = require_chain2();
    exports.shardeumSphinx = (0, chain_js_1.defineChain)({
      id: 8082,
      name: "Shardeum Sphinx",
      network: "shmSphinx",
      nativeCurrency: { name: "SHARDEUM", symbol: "SHM", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://sphinx.shardeum.org"]
        },
        public: {
          http: ["https://sphinx.shardeum.org"]
        }
      },
      blockExplorers: {
        default: {
          name: "Shardeum Explorer",
          url: "https://explorer-sphinx.shardeum.org"
        }
      },
      testnet: true
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/syscoin.js
var require_syscoin = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/syscoin.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.syscoin = void 0;
    var chain_js_1 = require_chain2();
    exports.syscoin = (0, chain_js_1.defineChain)({
      id: 57,
      name: "Syscoin Mainnet",
      network: "syscoin",
      nativeCurrency: {
        decimals: 18,
        name: "Syscoin",
        symbol: "SYS"
      },
      rpcUrls: {
        default: {
          http: ["https://rpc.syscoin.org"],
          webSocket: ["wss://rpc.syscoin.org/wss"]
        },
        public: {
          http: ["https://rpc.syscoin.org"],
          webSocket: ["wss://rpc.syscoin.org/wss"]
        }
      },
      blockExplorers: {
        default: { name: "SyscoinExplorer", url: "https://explorer.syscoin.org" }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 287139
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/syscoinTestnet.js
var require_syscoinTestnet = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/syscoinTestnet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.syscoinTestnet = void 0;
    var chain_js_1 = require_chain2();
    exports.syscoinTestnet = (0, chain_js_1.defineChain)({
      id: 5700,
      name: "Syscoin Tanenbaum Testnet",
      network: "syscoin-testnet",
      nativeCurrency: {
        decimals: 18,
        name: "Syscoin",
        symbol: "SYS"
      },
      rpcUrls: {
        default: {
          http: ["https://rpc.tanenbaum.io"],
          webSocket: ["wss://rpc.tanenbaum.io/wss"]
        },
        public: {
          http: ["https://rpc.tanenbaum.io"],
          webSocket: ["wss://rpc.tanenbaum.io/wss"]
        }
      },
      blockExplorers: {
        default: { name: "SyscoinTestnetExplorer", url: "https://tanenbaum.io" }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 271288
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/taraxa.js
var require_taraxa = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/taraxa.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.taraxa = void 0;
    var chain_js_1 = require_chain2();
    exports.taraxa = (0, chain_js_1.defineChain)({
      id: 841,
      name: "Taraxa Mainnet",
      network: "taraxa",
      nativeCurrency: { name: "Tara", symbol: "TARA", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://rpc.mainnet.taraxa.io"]
        },
        public: {
          http: ["https://rpc.mainnet.taraxa.io"]
        }
      },
      blockExplorers: {
        default: {
          name: "Taraxa Explorer",
          url: "https://explorer.mainnet.taraxa.io"
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/taikoJolnir.js
var require_taikoJolnir = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/taikoJolnir.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.taikoJolnir = void 0;
    var chain_js_1 = require_chain2();
    exports.taikoJolnir = (0, chain_js_1.defineChain)({
      id: 167007,
      name: "Taiko Jolnir L2",
      network: "tko-jolnir",
      nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://jolnir.taiko.xyz"]
        },
        public: {
          http: ["https://jolnir.taiko.xyz"]
        }
      },
      blockExplorers: {
        default: {
          name: "blockscout",
          url: "https://explorer.jolnir.taiko.xyz"
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/taikoTestnetSepolia.js
var require_taikoTestnetSepolia = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/taikoTestnetSepolia.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.taikoTestnetSepolia = void 0;
    var chain_js_1 = require_chain2();
    exports.taikoTestnetSepolia = (0, chain_js_1.defineChain)({
      id: 167005,
      name: "Taiko (Alpha-3 Testnet)",
      network: "taiko-sepolia",
      nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://rpc.test.taiko.xyz"]
        },
        public: {
          http: ["https://rpc.test.taiko.xyz"]
        }
      },
      blockExplorers: {
        default: {
          name: "blockscout",
          url: "https://explorer.test.taiko.xyz"
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/taraxaTestnet.js
var require_taraxaTestnet = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/taraxaTestnet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.taraxaTestnet = void 0;
    var chain_js_1 = require_chain2();
    exports.taraxaTestnet = (0, chain_js_1.defineChain)({
      id: 842,
      name: "Taraxa Testnet",
      network: "taraxa-testnet",
      nativeCurrency: { name: "Tara", symbol: "TARA", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://rpc.testnet.taraxa.io"]
        },
        public: {
          http: ["https://rpc.testnet.taraxa.io"]
        }
      },
      blockExplorers: {
        default: {
          name: "Taraxa Explorer",
          url: "https://explorer.testnet.taraxa.io"
        }
      },
      testnet: true
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/telos.js
var require_telos = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/telos.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.telos = void 0;
    var chain_js_1 = require_chain2();
    exports.telos = (0, chain_js_1.defineChain)({
      id: 40,
      name: "Telos",
      network: "telos",
      nativeCurrency: {
        decimals: 18,
        name: "Telos",
        symbol: "TLOS"
      },
      rpcUrls: {
        default: { http: ["https://mainnet.telos.net/evm"] },
        public: { http: ["https://mainnet.telos.net/evm"] }
      },
      blockExplorers: {
        default: {
          name: "Teloscan",
          url: "https://www.teloscan.io/"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 246530709
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/telosTestnet.js
var require_telosTestnet = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/telosTestnet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.telosTestnet = void 0;
    var chain_js_1 = require_chain2();
    exports.telosTestnet = (0, chain_js_1.defineChain)({
      id: 41,
      name: "Telos",
      network: "telosTestnet",
      nativeCurrency: {
        decimals: 18,
        name: "Telos",
        symbol: "TLOS"
      },
      rpcUrls: {
        default: { http: ["https://testnet.telos.net/evm"] },
        public: { http: ["https://testnet.telos.net/evm"] }
      },
      blockExplorers: {
        default: {
          name: "Teloscan (testnet)",
          url: "https://testnet.teloscan.io/"
        }
      },
      testnet: true
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/thunderTestnet.js
var require_thunderTestnet = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/thunderTestnet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.thunderTestnet = void 0;
    var chain_js_1 = require_chain2();
    exports.thunderTestnet = (0, chain_js_1.defineChain)({
      id: 997,
      name: "5ireChain Thunder Testnet",
      network: "5ireChain",
      nativeCurrency: { name: "5ire Token", symbol: "5IRE", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://rpc-testnet.5ire.network"]
        },
        public: {
          http: ["https://rpc-testnet.5ire.network"]
        }
      },
      blockExplorers: {
        default: {
          name: "5ireChain Explorer",
          url: "https://explorer.5ire.network"
        }
      },
      testnet: true
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/vechain.js
var require_vechain = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/vechain.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.vechain = void 0;
    var chain_js_1 = require_chain2();
    exports.vechain = (0, chain_js_1.defineChain)({
      id: 100009,
      name: "Vechain",
      network: "vechain",
      nativeCurrency: { name: "VeChain", symbol: "VET", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://mainnet.vechain.org"]
        },
        public: {
          http: ["https://mainnet.vechain.org"]
        }
      },
      blockExplorers: {
        default: {
          name: "Vechain Explorer",
          url: "https://explore.vechain.org"
        },
        vechainStats: {
          name: "Vechain Stats",
          url: "https://vechainstats.com"
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/wanchain.js
var require_wanchain = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/wanchain.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wanchain = void 0;
    var chain_js_1 = require_chain2();
    exports.wanchain = (0, chain_js_1.defineChain)({
      id: 888,
      name: "Wanchain",
      network: "wanchain",
      nativeCurrency: { name: "WANCHAIN", symbol: "WAN", decimals: 18 },
      rpcUrls: {
        default: {
          http: [
            "https://gwan-ssl.wandevs.org:56891",
            "https://gwan2-ssl.wandevs.org"
          ]
        },
        public: {
          http: [
            "https://gwan-ssl.wandevs.org:56891",
            "https://gwan2-ssl.wandevs.org"
          ]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "WanScan",
          url: "https://wanscan.org"
        },
        default: {
          name: "WanScan",
          url: "https://wanscan.org"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcDF6A1566e78EB4594c86Fe73Fcdc82429e97fbB",
          blockCreated: 25312390
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/wanchainTestnet.js
var require_wanchainTestnet = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/wanchainTestnet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wanchainTestnet = void 0;
    var chain_js_1 = require_chain2();
    exports.wanchainTestnet = (0, chain_js_1.defineChain)({
      id: 999,
      name: "Wanchain Testnet",
      network: "wanchainTestnet",
      nativeCurrency: { name: "WANCHAIN", symbol: "WANt", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://gwan-ssl.wandevs.org:46891"]
        },
        public: {
          http: ["https://gwan-ssl.wandevs.org:46891"]
        }
      },
      blockExplorers: {
        etherscan: {
          name: "WanScanTest",
          url: "https://wanscan.org"
        },
        default: {
          name: "WanScanTest",
          url: "https://wanscan.org"
        }
      },
      contracts: {
        multicall3: {
          address: "0x11c89bF4496c39FB80535Ffb4c92715839CC5324",
          blockCreated: 24743448
        }
      },
      testnet: true
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/xdc.js
var require_xdc = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/xdc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.xdc = void 0;
    var chain_js_1 = require_chain2();
    exports.xdc = (0, chain_js_1.defineChain)({
      id: 50,
      name: "XinFin Network",
      network: "xdc",
      nativeCurrency: {
        decimals: 18,
        name: "XDC",
        symbol: "XDC"
      },
      rpcUrls: {
        default: { http: ["https://rpc.xinfin.network"] },
        public: { http: ["https://rpc.xinfin.network"] }
      },
      blockExplorers: {
        xinfin: { name: "XinFin", url: "https://explorer.xinfin.network" },
        default: { name: "Blocksscan", url: "https://xdc.blocksscan.io" }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/xdcTestnet.js
var require_xdcTestnet = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/xdcTestnet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.xdcTestnet = void 0;
    var chain_js_1 = require_chain2();
    exports.xdcTestnet = (0, chain_js_1.defineChain)({
      id: 51,
      name: "Apothem Network",
      network: "xdc-testnet",
      nativeCurrency: {
        decimals: 18,
        name: "TXDC",
        symbol: "TXDC"
      },
      rpcUrls: {
        default: { http: ["https://erpc.apothem.network"] },
        public: { http: ["https://erpc.apothem.network"] }
      },
      blockExplorers: {
        xinfin: { name: "XinFin", url: "https://explorer.apothem.network" },
        default: { name: "Blocksscan", url: "https://apothem.blocksscan.io" }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/zhejiang.js
var require_zhejiang = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/zhejiang.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zhejiang = void 0;
    var chain_js_1 = require_chain2();
    exports.zhejiang = (0, chain_js_1.defineChain)({
      id: 1337803,
      network: "zhejiang",
      name: "Zhejiang",
      nativeCurrency: { name: "Zhejiang Ether", symbol: "ZhejETH", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://rpc.zhejiang.ethpandaops.io"]
        },
        public: {
          http: ["https://rpc.zhejiang.ethpandaops.io"]
        }
      },
      blockExplorers: {
        beaconchain: {
          name: "Etherscan",
          url: "https://zhejiang.beaconcha.in"
        },
        blockscout: {
          name: "Blockscout",
          url: "https://blockscout.com/eth/zhejiang-testnet"
        },
        default: {
          name: "Beaconchain",
          url: "https://zhejiang.beaconcha.in"
        }
      },
      testnet: true
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/zkSync.js
var require_zkSync = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/zkSync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zkSync = void 0;
    var chain_js_1 = require_chain2();
    exports.zkSync = (0, chain_js_1.defineChain)({
      id: 324,
      name: "zkSync Era",
      network: "zksync-era",
      nativeCurrency: {
        decimals: 18,
        name: "Ether",
        symbol: "ETH"
      },
      rpcUrls: {
        default: {
          http: ["https://mainnet.era.zksync.io"],
          webSocket: ["wss://mainnet.era.zksync.io/ws"]
        },
        public: {
          http: ["https://mainnet.era.zksync.io"],
          webSocket: ["wss://mainnet.era.zksync.io/ws"]
        }
      },
      blockExplorers: {
        default: {
          name: "zkExplorer",
          url: "https://explorer.zksync.io"
        }
      },
      contracts: {
        multicall3: {
          address: "0xF9cda624FBC7e059355ce98a31693d299FACd963"
        }
      }
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/zkSyncTestnet.js
var require_zkSyncTestnet = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/zkSyncTestnet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zkSyncTestnet = void 0;
    var chain_js_1 = require_chain2();
    exports.zkSyncTestnet = (0, chain_js_1.defineChain)({
      id: 280,
      name: "zkSync Era Testnet",
      network: "zksync-era-testnet",
      nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
      rpcUrls: {
        default: {
          http: ["https://testnet.era.zksync.dev"],
          webSocket: ["wss://testnet.era.zksync.dev/ws"]
        },
        public: {
          http: ["https://testnet.era.zksync.dev"],
          webSocket: ["wss://testnet.era.zksync.dev/ws"]
        }
      },
      blockExplorers: {
        default: {
          name: "zkExplorer",
          url: "https://goerli.explorer.zksync.io"
        }
      },
      contracts: {
        multicall3: {
          address: "0xF9cda624FBC7e059355ce98a31693d299FACd963"
        }
      },
      testnet: true
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/zetachainAthensTestnet.js
var require_zetachainAthensTestnet = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/zetachainAthensTestnet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zetachainAthensTestnet = void 0;
    var chain_js_1 = require_chain2();
    exports.zetachainAthensTestnet = (0, chain_js_1.defineChain)({
      id: 7001,
      name: "ZetaChain Athens Testnet",
      network: "zetachain-athens-testnet",
      nativeCurrency: {
        decimals: 18,
        name: "Zeta",
        symbol: "aZETA"
      },
      rpcUrls: {
        public: {
          http: ["https://zetachain-athens-evm.blockpi.network/v1/rpc/public"]
        },
        default: {
          http: ["https://zetachain-athens-evm.blockpi.network/v1/rpc/public"]
        }
      },
      blockExplorers: {
        default: {
          name: "ZetaScan",
          url: "https://athens3.explorer.zetachain.com"
        }
      },
      testnet: true
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/zora.js
var require_zora = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/zora.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zora = void 0;
    var chain_js_1 = require_chain2();
    var formatters_js_1 = require_formatters();
    exports.zora = (0, chain_js_1.defineChain)({
      id: 7777777,
      name: "Zora",
      network: "zora",
      nativeCurrency: {
        decimals: 18,
        name: "Ether",
        symbol: "ETH"
      },
      rpcUrls: {
        default: {
          http: ["https://rpc.zora.energy"],
          webSocket: ["wss://rpc.zora.energy"]
        },
        public: {
          http: ["https://rpc.zora.energy"],
          webSocket: ["wss://rpc.zora.energy"]
        }
      },
      blockExplorers: {
        default: { name: "Explorer", url: "https://explorer.zora.energy" }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 5882
        }
      }
    }, {
      formatters: formatters_js_1.formattersOptimism
    });
  }
});

// node_modules/viem/_cjs/chains/definitions/zoraTestnet.js
var require_zoraTestnet = __commonJS({
  "node_modules/viem/_cjs/chains/definitions/zoraTestnet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zoraTestnet = void 0;
    var chain_js_1 = require_chain2();
    var formatters_js_1 = require_formatters();
    exports.zoraTestnet = (0, chain_js_1.defineChain)({
      id: 999,
      name: "Zora Goerli Testnet",
      network: "zora-testnet",
      nativeCurrency: {
        decimals: 18,
        name: "Zora Goerli",
        symbol: "ETH"
      },
      rpcUrls: {
        default: {
          http: ["https://testnet.rpc.zora.energy"],
          webSocket: ["wss://testnet.rpc.zora.energy"]
        },
        public: {
          http: ["https://testnet.rpc.zora.energy"],
          webSocket: ["wss://testnet.rpc.zora.energy"]
        }
      },
      blockExplorers: {
        default: {
          name: "Explorer",
          url: "https://testnet.explorer.zora.energy"
        }
      },
      contracts: {
        multicall3: {
          address: "0xcA11bde05977b3631167028862bE2a173976CA11",
          blockCreated: 189123
        }
      },
      testnet: true
    }, {
      formatters: formatters_js_1.formattersOptimism
    });
  }
});

// node_modules/viem/_cjs/chains/index.js
var require_chains = __commonJS({
  "node_modules/viem/_cjs/chains/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.iotexTestnet = exports.iotex = exports.fuseSparknet = exports.fuse = exports.foundry = exports.flareTestnet = exports.flare = exports.filecoinHyperspace = exports.filecoinCalibration = exports.filecoin = exports.fibo = exports.fantomTestnet = exports.fantom = exports.ektaTestnet = exports.ekta = exports.evmosTestnet = exports.evmos = exports.eosTestnet = exports.eos = exports.edgewareTestnet = exports.edgeware = exports.dogechain = exports.dfk = exports.crossbell = exports.cronosTestnet = exports.cronos = exports.confluxESpace = exports.classic = exports.celoCannoli = exports.celoAlfajores = exports.celo = exports.canto = exports.bxnTestnet = exports.bxn = exports.bscTestnet = exports.bsc = exports.bronosTestnet = exports.bronos = exports.boba = exports.bearNetworkChainTestnet = exports.bearNetworkChainMainnet = exports.baseGoerli = exports.base = exports.avalancheFuji = exports.avalanche = exports.auroraTestnet = exports.aurora = exports.arbitrumNova = exports.arbitrumGoerli = exports.arbitrum = void 0;
    exports.saigon = exports.ronin = exports.rolluxTestnet = exports.rollux = exports.qTestnet = exports.qMainnet = exports.pulsechainV4 = exports.pulsechain = exports.polygonZkEvm = exports.polygonZkEvmTestnet = exports.polygonMumbai = exports.polygon = exports.plinga = exports.opBNBTestnet = exports.opBNB = exports.optimismGoerli = exports.optimism = exports.okc = exports.oasys = exports.nexilix = exports.nexi = exports.neonDevnet = exports.moonriver = exports.moonbeam = exports.moonbaseAlpha = exports.modeTestnet = exports.mevTestnet = exports.mev = exports.metisGoerli = exports.metis = exports.meterTestnet = exports.meter = exports.mantleTestnet = exports.mantle = exports.mainnet = exports.localhost = exports.lineaTestnet = exports.linea = exports.kromaSepolia = exports.kroma = exports.klaytn = exports.holesky = exports.haqqTestedge2 = exports.haqqMainnet = exports.harmonyOne = exports.hardhat = exports.gnosisChiado = exports.gnosis = exports.goerli = exports.gobi = void 0;
    exports.zoraTestnet = exports.zora = exports.zetachainAthensTestnet = exports.zkSyncTestnet = exports.zkSync = exports.zhejiang = exports.xdcTestnet = exports.xdc = exports.wanchainTestnet = exports.wanchain = exports.vechain = exports.thunderTestnet = exports.telosTestnet = exports.telos = exports.taraxaTestnet = exports.taikoTestnetSepolia = exports.taikoJolnir = exports.taraxa = exports.syscoinTestnet = exports.syscoin = exports.shardeumSphinx = exports.songbirdTestnet = exports.songbird = exports.skaleTitanTestnet = exports.skaleTitan = exports.skaleRazor = exports.skaleNebulaTestnet = exports.skaleNebula = exports.skaleHumanProtocol = exports.skaleExorde = exports.skaleEuropaTestnet = exports.skaleEuropa = exports.skaleCryptoColosseum = exports.skaleCryptoBlades = exports.skaleChaosTestnet = exports.skaleCalypsoTestnet = exports.skaleCalypso = exports.skaleBlockBrawlers = exports.sepolia = exports.scrollTestnet = exports.scrollSepolia = void 0;
    var arbitrum_js_1 = require_arbitrum();
    Object.defineProperty(exports, "arbitrum", { enumerable: true, get: function() {
      return arbitrum_js_1.arbitrum;
    } });
    var arbitrumGoerli_js_1 = require_arbitrumGoerli();
    Object.defineProperty(exports, "arbitrumGoerli", { enumerable: true, get: function() {
      return arbitrumGoerli_js_1.arbitrumGoerli;
    } });
    var arbitrumNova_js_1 = require_arbitrumNova();
    Object.defineProperty(exports, "arbitrumNova", { enumerable: true, get: function() {
      return arbitrumNova_js_1.arbitrumNova;
    } });
    var aurora_js_1 = require_aurora();
    Object.defineProperty(exports, "aurora", { enumerable: true, get: function() {
      return aurora_js_1.aurora;
    } });
    var auroraTestnet_js_1 = require_auroraTestnet();
    Object.defineProperty(exports, "auroraTestnet", { enumerable: true, get: function() {
      return auroraTestnet_js_1.auroraTestnet;
    } });
    var avalanche_js_1 = require_avalanche();
    Object.defineProperty(exports, "avalanche", { enumerable: true, get: function() {
      return avalanche_js_1.avalanche;
    } });
    var avalancheFuji_js_1 = require_avalancheFuji();
    Object.defineProperty(exports, "avalancheFuji", { enumerable: true, get: function() {
      return avalancheFuji_js_1.avalancheFuji;
    } });
    var base_js_1 = require_base2();
    Object.defineProperty(exports, "base", { enumerable: true, get: function() {
      return base_js_1.base;
    } });
    var baseGoerli_js_1 = require_baseGoerli();
    Object.defineProperty(exports, "baseGoerli", { enumerable: true, get: function() {
      return baseGoerli_js_1.baseGoerli;
    } });
    var bearNetworkChainMainnet_js_1 = require_bearNetworkChainMainnet();
    Object.defineProperty(exports, "bearNetworkChainMainnet", { enumerable: true, get: function() {
      return bearNetworkChainMainnet_js_1.bearNetworkChainMainnet;
    } });
    var bearNetworkChainTestnet_js_1 = require_bearNetworkChainTestnet();
    Object.defineProperty(exports, "bearNetworkChainTestnet", { enumerable: true, get: function() {
      return bearNetworkChainTestnet_js_1.bearNetworkChainTestnet;
    } });
    var boba_js_1 = require_boba();
    Object.defineProperty(exports, "boba", { enumerable: true, get: function() {
      return boba_js_1.boba;
    } });
    var bronos_js_1 = require_bronos();
    Object.defineProperty(exports, "bronos", { enumerable: true, get: function() {
      return bronos_js_1.bronos;
    } });
    var bronosTestnet_js_1 = require_bronosTestnet();
    Object.defineProperty(exports, "bronosTestnet", { enumerable: true, get: function() {
      return bronosTestnet_js_1.bronosTestnet;
    } });
    var bsc_js_1 = require_bsc();
    Object.defineProperty(exports, "bsc", { enumerable: true, get: function() {
      return bsc_js_1.bsc;
    } });
    var bscTestnet_js_1 = require_bscTestnet();
    Object.defineProperty(exports, "bscTestnet", { enumerable: true, get: function() {
      return bscTestnet_js_1.bscTestnet;
    } });
    var bxn_js_1 = require_bxn();
    Object.defineProperty(exports, "bxn", { enumerable: true, get: function() {
      return bxn_js_1.bxn;
    } });
    var bxnTestnet_js_1 = require_bxnTestnet();
    Object.defineProperty(exports, "bxnTestnet", { enumerable: true, get: function() {
      return bxnTestnet_js_1.bxnTestnet;
    } });
    var canto_js_1 = require_canto();
    Object.defineProperty(exports, "canto", { enumerable: true, get: function() {
      return canto_js_1.canto;
    } });
    var celo_js_1 = require_celo();
    Object.defineProperty(exports, "celo", { enumerable: true, get: function() {
      return celo_js_1.celo;
    } });
    var celoAlfajores_js_1 = require_celoAlfajores();
    Object.defineProperty(exports, "celoAlfajores", { enumerable: true, get: function() {
      return celoAlfajores_js_1.celoAlfajores;
    } });
    var celoCannoli_js_1 = require_celoCannoli();
    Object.defineProperty(exports, "celoCannoli", { enumerable: true, get: function() {
      return celoCannoli_js_1.celoCannoli;
    } });
    var classic_js_1 = require_classic();
    Object.defineProperty(exports, "classic", { enumerable: true, get: function() {
      return classic_js_1.classic;
    } });
    var confluxESpace_js_1 = require_confluxESpace();
    Object.defineProperty(exports, "confluxESpace", { enumerable: true, get: function() {
      return confluxESpace_js_1.confluxESpace;
    } });
    var cronos_js_1 = require_cronos();
    Object.defineProperty(exports, "cronos", { enumerable: true, get: function() {
      return cronos_js_1.cronos;
    } });
    var cronosTestnet_js_1 = require_cronosTestnet();
    Object.defineProperty(exports, "cronosTestnet", { enumerable: true, get: function() {
      return cronosTestnet_js_1.cronosTestnet;
    } });
    var crossbell_js_1 = require_crossbell();
    Object.defineProperty(exports, "crossbell", { enumerable: true, get: function() {
      return crossbell_js_1.crossbell;
    } });
    var dfk_js_1 = require_dfk();
    Object.defineProperty(exports, "dfk", { enumerable: true, get: function() {
      return dfk_js_1.dfk;
    } });
    var dogechain_js_1 = require_dogechain();
    Object.defineProperty(exports, "dogechain", { enumerable: true, get: function() {
      return dogechain_js_1.dogechain;
    } });
    var edgeware_js_1 = require_edgeware();
    Object.defineProperty(exports, "edgeware", { enumerable: true, get: function() {
      return edgeware_js_1.edgeware;
    } });
    var edgewareTestnet_js_1 = require_edgewareTestnet();
    Object.defineProperty(exports, "edgewareTestnet", { enumerable: true, get: function() {
      return edgewareTestnet_js_1.edgewareTestnet;
    } });
    var eos_js_1 = require_eos();
    Object.defineProperty(exports, "eos", { enumerable: true, get: function() {
      return eos_js_1.eos;
    } });
    var eosTestnet_js_1 = require_eosTestnet();
    Object.defineProperty(exports, "eosTestnet", { enumerable: true, get: function() {
      return eosTestnet_js_1.eosTestnet;
    } });
    var evmos_js_1 = require_evmos();
    Object.defineProperty(exports, "evmos", { enumerable: true, get: function() {
      return evmos_js_1.evmos;
    } });
    var evmosTestnet_js_1 = require_evmosTestnet();
    Object.defineProperty(exports, "evmosTestnet", { enumerable: true, get: function() {
      return evmosTestnet_js_1.evmosTestnet;
    } });
    var ekta_js_1 = require_ekta();
    Object.defineProperty(exports, "ekta", { enumerable: true, get: function() {
      return ekta_js_1.ekta;
    } });
    var ektaTestnet_js_1 = require_ektaTestnet();
    Object.defineProperty(exports, "ektaTestnet", { enumerable: true, get: function() {
      return ektaTestnet_js_1.ektaTestnet;
    } });
    var fantom_js_1 = require_fantom();
    Object.defineProperty(exports, "fantom", { enumerable: true, get: function() {
      return fantom_js_1.fantom;
    } });
    var fantomTestnet_js_1 = require_fantomTestnet();
    Object.defineProperty(exports, "fantomTestnet", { enumerable: true, get: function() {
      return fantomTestnet_js_1.fantomTestnet;
    } });
    var fibo_js_1 = require_fibo();
    Object.defineProperty(exports, "fibo", { enumerable: true, get: function() {
      return fibo_js_1.fibo;
    } });
    var filecoin_js_1 = require_filecoin();
    Object.defineProperty(exports, "filecoin", { enumerable: true, get: function() {
      return filecoin_js_1.filecoin;
    } });
    var filecoinCalibration_js_1 = require_filecoinCalibration();
    Object.defineProperty(exports, "filecoinCalibration", { enumerable: true, get: function() {
      return filecoinCalibration_js_1.filecoinCalibration;
    } });
    var filecoinHyperspace_js_1 = require_filecoinHyperspace();
    Object.defineProperty(exports, "filecoinHyperspace", { enumerable: true, get: function() {
      return filecoinHyperspace_js_1.filecoinHyperspace;
    } });
    var flare_js_1 = require_flare();
    Object.defineProperty(exports, "flare", { enumerable: true, get: function() {
      return flare_js_1.flare;
    } });
    var flareTestnet_js_1 = require_flareTestnet();
    Object.defineProperty(exports, "flareTestnet", { enumerable: true, get: function() {
      return flareTestnet_js_1.flareTestnet;
    } });
    var foundry_js_1 = require_foundry();
    Object.defineProperty(exports, "foundry", { enumerable: true, get: function() {
      return foundry_js_1.foundry;
    } });
    var fuse_js_1 = require_fuse();
    Object.defineProperty(exports, "fuse", { enumerable: true, get: function() {
      return fuse_js_1.fuse;
    } });
    var fuseSparknet_js_1 = require_fuseSparknet();
    Object.defineProperty(exports, "fuseSparknet", { enumerable: true, get: function() {
      return fuseSparknet_js_1.fuseSparknet;
    } });
    var iotex_js_1 = require_iotex();
    Object.defineProperty(exports, "iotex", { enumerable: true, get: function() {
      return iotex_js_1.iotex;
    } });
    var iotexTestnet_js_1 = require_iotexTestnet();
    Object.defineProperty(exports, "iotexTestnet", { enumerable: true, get: function() {
      return iotexTestnet_js_1.iotexTestnet;
    } });
    var gobi_js_1 = require_gobi();
    Object.defineProperty(exports, "gobi", { enumerable: true, get: function() {
      return gobi_js_1.gobi;
    } });
    var goerli_js_1 = require_goerli();
    Object.defineProperty(exports, "goerli", { enumerable: true, get: function() {
      return goerli_js_1.goerli;
    } });
    var gnosis_js_1 = require_gnosis();
    Object.defineProperty(exports, "gnosis", { enumerable: true, get: function() {
      return gnosis_js_1.gnosis;
    } });
    var gnosisChiado_js_1 = require_gnosisChiado();
    Object.defineProperty(exports, "gnosisChiado", { enumerable: true, get: function() {
      return gnosisChiado_js_1.gnosisChiado;
    } });
    var hardhat_js_1 = require_hardhat();
    Object.defineProperty(exports, "hardhat", { enumerable: true, get: function() {
      return hardhat_js_1.hardhat;
    } });
    var harmonyOne_js_1 = require_harmonyOne();
    Object.defineProperty(exports, "harmonyOne", { enumerable: true, get: function() {
      return harmonyOne_js_1.harmonyOne;
    } });
    var haqqMainnet_js_1 = require_haqqMainnet();
    Object.defineProperty(exports, "haqqMainnet", { enumerable: true, get: function() {
      return haqqMainnet_js_1.haqqMainnet;
    } });
    var haqqTestedge2_js_1 = require_haqqTestedge2();
    Object.defineProperty(exports, "haqqTestedge2", { enumerable: true, get: function() {
      return haqqTestedge2_js_1.haqqTestedge2;
    } });
    var holesky_js_1 = require_holesky();
    Object.defineProperty(exports, "holesky", { enumerable: true, get: function() {
      return holesky_js_1.holesky;
    } });
    var klaytn_js_1 = require_klaytn();
    Object.defineProperty(exports, "klaytn", { enumerable: true, get: function() {
      return klaytn_js_1.klaytn;
    } });
    var kroma_js_1 = require_kroma();
    Object.defineProperty(exports, "kroma", { enumerable: true, get: function() {
      return kroma_js_1.kroma;
    } });
    var kromaSepolia_js_1 = require_kromaSepolia();
    Object.defineProperty(exports, "kromaSepolia", { enumerable: true, get: function() {
      return kromaSepolia_js_1.kromaSepolia;
    } });
    var linea_js_1 = require_linea();
    Object.defineProperty(exports, "linea", { enumerable: true, get: function() {
      return linea_js_1.linea;
    } });
    var lineaTestnet_js_1 = require_lineaTestnet();
    Object.defineProperty(exports, "lineaTestnet", { enumerable: true, get: function() {
      return lineaTestnet_js_1.lineaTestnet;
    } });
    var localhost_js_1 = require_localhost();
    Object.defineProperty(exports, "localhost", { enumerable: true, get: function() {
      return localhost_js_1.localhost;
    } });
    var mainnet_js_1 = require_mainnet();
    Object.defineProperty(exports, "mainnet", { enumerable: true, get: function() {
      return mainnet_js_1.mainnet;
    } });
    var mantle_js_1 = require_mantle();
    Object.defineProperty(exports, "mantle", { enumerable: true, get: function() {
      return mantle_js_1.mantle;
    } });
    var mantleTestnet_js_1 = require_mantleTestnet();
    Object.defineProperty(exports, "mantleTestnet", { enumerable: true, get: function() {
      return mantleTestnet_js_1.mantleTestnet;
    } });
    var meter_js_1 = require_meter();
    Object.defineProperty(exports, "meter", { enumerable: true, get: function() {
      return meter_js_1.meter;
    } });
    var meterTestnet_js_1 = require_meterTestnet();
    Object.defineProperty(exports, "meterTestnet", { enumerable: true, get: function() {
      return meterTestnet_js_1.meterTestnet;
    } });
    var metis_js_1 = require_metis();
    Object.defineProperty(exports, "metis", { enumerable: true, get: function() {
      return metis_js_1.metis;
    } });
    var metisGoerli_js_1 = require_metisGoerli();
    Object.defineProperty(exports, "metisGoerli", { enumerable: true, get: function() {
      return metisGoerli_js_1.metisGoerli;
    } });
    var mev_js_1 = require_mev();
    Object.defineProperty(exports, "mev", { enumerable: true, get: function() {
      return mev_js_1.mev;
    } });
    var mevTestnet_js_1 = require_mevTestnet();
    Object.defineProperty(exports, "mevTestnet", { enumerable: true, get: function() {
      return mevTestnet_js_1.mevTestnet;
    } });
    var modeTestnet_js_1 = require_modeTestnet();
    Object.defineProperty(exports, "modeTestnet", { enumerable: true, get: function() {
      return modeTestnet_js_1.modeTestnet;
    } });
    var moonbaseAlpha_js_1 = require_moonbaseAlpha();
    Object.defineProperty(exports, "moonbaseAlpha", { enumerable: true, get: function() {
      return moonbaseAlpha_js_1.moonbaseAlpha;
    } });
    var moonbeam_js_1 = require_moonbeam();
    Object.defineProperty(exports, "moonbeam", { enumerable: true, get: function() {
      return moonbeam_js_1.moonbeam;
    } });
    var moonriver_js_1 = require_moonriver();
    Object.defineProperty(exports, "moonriver", { enumerable: true, get: function() {
      return moonriver_js_1.moonriver;
    } });
    var neonDevnet_js_1 = require_neonDevnet();
    Object.defineProperty(exports, "neonDevnet", { enumerable: true, get: function() {
      return neonDevnet_js_1.neonDevnet;
    } });
    var nexi_js_1 = require_nexi();
    Object.defineProperty(exports, "nexi", { enumerable: true, get: function() {
      return nexi_js_1.nexi;
    } });
    var nexilix_js_1 = require_nexilix();
    Object.defineProperty(exports, "nexilix", { enumerable: true, get: function() {
      return nexilix_js_1.nexilix;
    } });
    var oasys_js_1 = require_oasys();
    Object.defineProperty(exports, "oasys", { enumerable: true, get: function() {
      return oasys_js_1.oasys;
    } });
    var okc_js_1 = require_okc();
    Object.defineProperty(exports, "okc", { enumerable: true, get: function() {
      return okc_js_1.okc;
    } });
    var optimism_js_1 = require_optimism();
    Object.defineProperty(exports, "optimism", { enumerable: true, get: function() {
      return optimism_js_1.optimism;
    } });
    var optimismGoerli_js_1 = require_optimismGoerli();
    Object.defineProperty(exports, "optimismGoerli", { enumerable: true, get: function() {
      return optimismGoerli_js_1.optimismGoerli;
    } });
    var opBNB_js_1 = require_opBNB();
    Object.defineProperty(exports, "opBNB", { enumerable: true, get: function() {
      return opBNB_js_1.opBNB;
    } });
    var opBNBTestnet_js_1 = require_opBNBTestnet();
    Object.defineProperty(exports, "opBNBTestnet", { enumerable: true, get: function() {
      return opBNBTestnet_js_1.opBNBTestnet;
    } });
    var plinga_js_1 = require_plinga();
    Object.defineProperty(exports, "plinga", { enumerable: true, get: function() {
      return plinga_js_1.plinga;
    } });
    var polygon_js_1 = require_polygon();
    Object.defineProperty(exports, "polygon", { enumerable: true, get: function() {
      return polygon_js_1.polygon;
    } });
    var polygonMumbai_js_1 = require_polygonMumbai();
    Object.defineProperty(exports, "polygonMumbai", { enumerable: true, get: function() {
      return polygonMumbai_js_1.polygonMumbai;
    } });
    var polygonZkEvmTestnet_js_1 = require_polygonZkEvmTestnet();
    Object.defineProperty(exports, "polygonZkEvmTestnet", { enumerable: true, get: function() {
      return polygonZkEvmTestnet_js_1.polygonZkEvmTestnet;
    } });
    var polygonZkEvm_js_1 = require_polygonZkEvm();
    Object.defineProperty(exports, "polygonZkEvm", { enumerable: true, get: function() {
      return polygonZkEvm_js_1.polygonZkEvm;
    } });
    var pulsechain_js_1 = require_pulsechain();
    Object.defineProperty(exports, "pulsechain", { enumerable: true, get: function() {
      return pulsechain_js_1.pulsechain;
    } });
    var pulsechainV4_js_1 = require_pulsechainV4();
    Object.defineProperty(exports, "pulsechainV4", { enumerable: true, get: function() {
      return pulsechainV4_js_1.pulsechainV4;
    } });
    var qMainnet_js_1 = require_qMainnet();
    Object.defineProperty(exports, "qMainnet", { enumerable: true, get: function() {
      return qMainnet_js_1.qMainnet;
    } });
    var qTestnet_js_1 = require_qTestnet();
    Object.defineProperty(exports, "qTestnet", { enumerable: true, get: function() {
      return qTestnet_js_1.qTestnet;
    } });
    var rollux_js_1 = require_rollux();
    Object.defineProperty(exports, "rollux", { enumerable: true, get: function() {
      return rollux_js_1.rollux;
    } });
    var rolluxTestnet_js_1 = require_rolluxTestnet();
    Object.defineProperty(exports, "rolluxTestnet", { enumerable: true, get: function() {
      return rolluxTestnet_js_1.rolluxTestnet;
    } });
    var ronin_js_1 = require_ronin();
    Object.defineProperty(exports, "ronin", { enumerable: true, get: function() {
      return ronin_js_1.ronin;
    } });
    var saigon_js_1 = require_saigon();
    Object.defineProperty(exports, "saigon", { enumerable: true, get: function() {
      return saigon_js_1.saigon;
    } });
    var scrollSepolia_js_1 = require_scrollSepolia();
    Object.defineProperty(exports, "scrollSepolia", { enumerable: true, get: function() {
      return scrollSepolia_js_1.scrollSepolia;
    } });
    var scrollTestnet_js_1 = require_scrollTestnet();
    Object.defineProperty(exports, "scrollTestnet", { enumerable: true, get: function() {
      return scrollTestnet_js_1.scrollTestnet;
    } });
    var sepolia_js_1 = require_sepolia();
    Object.defineProperty(exports, "sepolia", { enumerable: true, get: function() {
      return sepolia_js_1.sepolia;
    } });
    var brawl_js_1 = require_brawl();
    Object.defineProperty(exports, "skaleBlockBrawlers", { enumerable: true, get: function() {
      return brawl_js_1.skaleBlockBrawlers;
    } });
    var calypso_js_1 = require_calypso();
    Object.defineProperty(exports, "skaleCalypso", { enumerable: true, get: function() {
      return calypso_js_1.skaleCalypso;
    } });
    var calypsoTestnet_js_1 = require_calypsoTestnet();
    Object.defineProperty(exports, "skaleCalypsoTestnet", { enumerable: true, get: function() {
      return calypsoTestnet_js_1.skaleCalypsoTestnet;
    } });
    var chaosTestnet_js_1 = require_chaosTestnet();
    Object.defineProperty(exports, "skaleChaosTestnet", { enumerable: true, get: function() {
      return chaosTestnet_js_1.skaleChaosTestnet;
    } });
    var cryptoBlades_js_1 = require_cryptoBlades();
    Object.defineProperty(exports, "skaleCryptoBlades", { enumerable: true, get: function() {
      return cryptoBlades_js_1.skaleCryptoBlades;
    } });
    var cryptoColosseum_js_1 = require_cryptoColosseum();
    Object.defineProperty(exports, "skaleCryptoColosseum", { enumerable: true, get: function() {
      return cryptoColosseum_js_1.skaleCryptoColosseum;
    } });
    var europa_js_1 = require_europa();
    Object.defineProperty(exports, "skaleEuropa", { enumerable: true, get: function() {
      return europa_js_1.skaleEuropa;
    } });
    var europaTestnet_js_1 = require_europaTestnet();
    Object.defineProperty(exports, "skaleEuropaTestnet", { enumerable: true, get: function() {
      return europaTestnet_js_1.skaleEuropaTestnet;
    } });
    var exorde_js_1 = require_exorde();
    Object.defineProperty(exports, "skaleExorde", { enumerable: true, get: function() {
      return exorde_js_1.skaleExorde;
    } });
    var humanProtocol_js_1 = require_humanProtocol();
    Object.defineProperty(exports, "skaleHumanProtocol", { enumerable: true, get: function() {
      return humanProtocol_js_1.skaleHumanProtocol;
    } });
    var nebula_js_1 = require_nebula();
    Object.defineProperty(exports, "skaleNebula", { enumerable: true, get: function() {
      return nebula_js_1.skaleNebula;
    } });
    var nebulaTestnet_js_1 = require_nebulaTestnet();
    Object.defineProperty(exports, "skaleNebulaTestnet", { enumerable: true, get: function() {
      return nebulaTestnet_js_1.skaleNebulaTestnet;
    } });
    var razor_js_1 = require_razor();
    Object.defineProperty(exports, "skaleRazor", { enumerable: true, get: function() {
      return razor_js_1.skaleRazor;
    } });
    var titan_js_1 = require_titan();
    Object.defineProperty(exports, "skaleTitan", { enumerable: true, get: function() {
      return titan_js_1.skaleTitan;
    } });
    var titanTestnet_js_1 = require_titanTestnet();
    Object.defineProperty(exports, "skaleTitanTestnet", { enumerable: true, get: function() {
      return titanTestnet_js_1.skaleTitanTestnet;
    } });
    var songbird_js_1 = require_songbird();
    Object.defineProperty(exports, "songbird", { enumerable: true, get: function() {
      return songbird_js_1.songbird;
    } });
    var songbirdTestnet_js_1 = require_songbirdTestnet();
    Object.defineProperty(exports, "songbirdTestnet", { enumerable: true, get: function() {
      return songbirdTestnet_js_1.songbirdTestnet;
    } });
    var shardeumSphinx_js_1 = require_shardeumSphinx();
    Object.defineProperty(exports, "shardeumSphinx", { enumerable: true, get: function() {
      return shardeumSphinx_js_1.shardeumSphinx;
    } });
    var syscoin_js_1 = require_syscoin();
    Object.defineProperty(exports, "syscoin", { enumerable: true, get: function() {
      return syscoin_js_1.syscoin;
    } });
    var syscoinTestnet_js_1 = require_syscoinTestnet();
    Object.defineProperty(exports, "syscoinTestnet", { enumerable: true, get: function() {
      return syscoinTestnet_js_1.syscoinTestnet;
    } });
    var taraxa_js_1 = require_taraxa();
    Object.defineProperty(exports, "taraxa", { enumerable: true, get: function() {
      return taraxa_js_1.taraxa;
    } });
    var taikoJolnir_js_1 = require_taikoJolnir();
    Object.defineProperty(exports, "taikoJolnir", { enumerable: true, get: function() {
      return taikoJolnir_js_1.taikoJolnir;
    } });
    var taikoTestnetSepolia_js_1 = require_taikoTestnetSepolia();
    Object.defineProperty(exports, "taikoTestnetSepolia", { enumerable: true, get: function() {
      return taikoTestnetSepolia_js_1.taikoTestnetSepolia;
    } });
    var taraxaTestnet_js_1 = require_taraxaTestnet();
    Object.defineProperty(exports, "taraxaTestnet", { enumerable: true, get: function() {
      return taraxaTestnet_js_1.taraxaTestnet;
    } });
    var telos_js_1 = require_telos();
    Object.defineProperty(exports, "telos", { enumerable: true, get: function() {
      return telos_js_1.telos;
    } });
    var telosTestnet_js_1 = require_telosTestnet();
    Object.defineProperty(exports, "telosTestnet", { enumerable: true, get: function() {
      return telosTestnet_js_1.telosTestnet;
    } });
    var thunderTestnet_js_1 = require_thunderTestnet();
    Object.defineProperty(exports, "thunderTestnet", { enumerable: true, get: function() {
      return thunderTestnet_js_1.thunderTestnet;
    } });
    var vechain_js_1 = require_vechain();
    Object.defineProperty(exports, "vechain", { enumerable: true, get: function() {
      return vechain_js_1.vechain;
    } });
    var wanchain_js_1 = require_wanchain();
    Object.defineProperty(exports, "wanchain", { enumerable: true, get: function() {
      return wanchain_js_1.wanchain;
    } });
    var wanchainTestnet_js_1 = require_wanchainTestnet();
    Object.defineProperty(exports, "wanchainTestnet", { enumerable: true, get: function() {
      return wanchainTestnet_js_1.wanchainTestnet;
    } });
    var xdc_js_1 = require_xdc();
    Object.defineProperty(exports, "xdc", { enumerable: true, get: function() {
      return xdc_js_1.xdc;
    } });
    var xdcTestnet_js_1 = require_xdcTestnet();
    Object.defineProperty(exports, "xdcTestnet", { enumerable: true, get: function() {
      return xdcTestnet_js_1.xdcTestnet;
    } });
    var zhejiang_js_1 = require_zhejiang();
    Object.defineProperty(exports, "zhejiang", { enumerable: true, get: function() {
      return zhejiang_js_1.zhejiang;
    } });
    var zkSync_js_1 = require_zkSync();
    Object.defineProperty(exports, "zkSync", { enumerable: true, get: function() {
      return zkSync_js_1.zkSync;
    } });
    var zkSyncTestnet_js_1 = require_zkSyncTestnet();
    Object.defineProperty(exports, "zkSyncTestnet", { enumerable: true, get: function() {
      return zkSyncTestnet_js_1.zkSyncTestnet;
    } });
    var zetachainAthensTestnet_js_1 = require_zetachainAthensTestnet();
    Object.defineProperty(exports, "zetachainAthensTestnet", { enumerable: true, get: function() {
      return zetachainAthensTestnet_js_1.zetachainAthensTestnet;
    } });
    var zora_js_1 = require_zora();
    Object.defineProperty(exports, "zora", { enumerable: true, get: function() {
      return zora_js_1.zora;
    } });
    var zoraTestnet_js_1 = require_zoraTestnet();
    Object.defineProperty(exports, "zoraTestnet", { enumerable: true, get: function() {
      return zoraTestnet_js_1.zoraTestnet;
    } });
  }
});

// node_modules/@wagmi/core/dist/chunk-4E64EZ7V.js
var require_chunk_4E64EZ7V = __commonJS({
  "node_modules/@wagmi/core/dist/chunk-4E64EZ7V.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _chains = require_chains();
    exports.mainnet = _chains.mainnet;
    exports.sepolia = _chains.sepolia;
  }
});

// node_modules/@wagmi/connectors/dist/chunk-UGBGYVBH.js
var require_chunk_UGBGYVBH = __commonJS({
  "node_modules/@wagmi/connectors/dist/chunk-UGBGYVBH.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ChainNotConfiguredForConnectorError = class extends Error {
      constructor({
        chainId,
        connectorId
      }) {
        super(`Chain "${chainId}" not configured for connector "${connectorId}".`);
        this.name = "ChainNotConfiguredForConnectorError";
      }
    };
    var ConnectorNotFoundError = class extends Error {
      constructor() {
        super(...arguments);
        this.name = "ConnectorNotFoundError";
        this.message = "Connector not found";
      }
    };
    exports.ChainNotConfiguredForConnectorError = ChainNotConfiguredForConnectorError;
    exports.ConnectorNotFoundError = ConnectorNotFoundError;
  }
});

// node_modules/@wagmi/connectors/dist/chunk-OQILYQDO.js
var require_chunk_OQILYQDO = __commonJS({
  "node_modules/@wagmi/connectors/dist/chunk-OQILYQDO.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function normalizeChainId(chainId) {
      if (typeof chainId === "string")
        return Number.parseInt(
          chainId,
          chainId.trim().substring(0, 2) === "0x" ? 16 : 10
        );
      if (typeof chainId === "bigint")
        return Number(chainId);
      return chainId;
    }
    exports.normalizeChainId = normalizeChainId;
  }
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0)
        return names;
      for (name in events = this._events) {
        if (has.call(events, name))
          names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.addListener = EventEmitter.prototype.on;
    EventEmitter.prefixed = prefix;
    EventEmitter.EventEmitter = EventEmitter;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter;
    }
  }
});

// node_modules/@wagmi/connectors/dist/chunk-W65LBPLT.js
var require_chunk_W65LBPLT = __commonJS({
  "node_modules/@wagmi/connectors/dist/chunk-W65LBPLT.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _nullishCoalesce(lhs, rhsFn) {
      if (lhs != null) {
        return lhs;
      } else {
        return rhsFn();
      }
    }
    var __accessCheck = (obj, member, msg) => {
      if (!member.has(obj))
        throw TypeError("Cannot " + msg);
    };
    var __privateGet = (obj, member, getter) => {
      __accessCheck(obj, member, "read from private field");
      return getter ? getter.call(obj) : member.get(obj);
    };
    var __privateAdd = (obj, member, value) => {
      if (member.has(obj))
        throw TypeError("Cannot add the same private member more than once");
      member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
    };
    var __privateSet = (obj, member, value, setter) => {
      __accessCheck(obj, member, "write to private field");
      setter ? setter.call(obj, value) : member.set(obj, value);
      return value;
    };
    var __privateMethod = (obj, member, method) => {
      __accessCheck(obj, member, "access private method");
      return method;
    };
    var _eventemitter3 = require_eventemitter3();
    var _eventemitter32 = _interopRequireDefault(_eventemitter3);
    var _chains = require_chains();
    var Connector = class extends _eventemitter32.default {
      constructor({
        chains = [_chains.mainnet, _chains.goerli],
        options
      }) {
        super();
        this.chains = chains;
        this.options = options;
      }
      getBlockExplorerUrls(chain) {
        const { default: blockExplorer, ...blockExplorers } = _nullishCoalesce(chain.blockExplorers, () => ({}));
        if (blockExplorer)
          return [
            blockExplorer.url,
            ...Object.values(blockExplorers).map((x) => x.url)
          ];
      }
      isChainUnsupported(chainId) {
        return !this.chains.some((x) => x.id === chainId);
      }
      setStorage(storage) {
        this.storage = storage;
      }
    };
    exports.__privateGet = __privateGet;
    exports.__privateAdd = __privateAdd;
    exports.__privateSet = __privateSet;
    exports.__privateMethod = __privateMethod;
    exports.Connector = Connector;
  }
});

// node_modules/@wagmi/connectors/dist/index.js
var require_dist = __commonJS({
  "node_modules/@wagmi/connectors/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _chunkUGBGYVBHjs = require_chunk_UGBGYVBH();
    var _chunkOQILYQDOjs = require_chunk_OQILYQDO();
    var _chunkW65LBPLTjs = require_chunk_W65LBPLT();
    exports.ChainNotConfiguredForConnectorError = _chunkUGBGYVBHjs.ChainNotConfiguredForConnectorError;
    exports.Connector = _chunkW65LBPLTjs.Connector;
    exports.ConnectorNotFoundError = _chunkUGBGYVBHjs.ConnectorNotFoundError;
    exports.normalizeChainId = _chunkOQILYQDOjs.normalizeChainId;
  }
});

// node_modules/viem/node_modules/abitype/dist/cjs/version.js
var require_version2 = __commonJS({
  "node_modules/viem/node_modules/abitype/dist/cjs/version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "0.9.8";
  }
});

// node_modules/viem/node_modules/abitype/dist/cjs/errors.js
var require_errors = __commonJS({
  "node_modules/viem/node_modules/abitype/dist/cjs/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaseError = void 0;
    var version_js_1 = require_version2();
    var BaseError = class extends Error {
      constructor(shortMessage, args = {}) {
        const details = args.cause instanceof BaseError ? args.cause.details : args.cause?.message ? args.cause.message : args.details;
        const docsPath = args.cause instanceof BaseError ? args.cause.docsPath || args.docsPath : args.docsPath;
        const message = [
          shortMessage || "An error occurred.",
          "",
          ...args.metaMessages ? [...args.metaMessages, ""] : [],
          ...docsPath ? [`Docs: https://abitype.dev${docsPath}`] : [],
          ...details ? [`Details: ${details}`] : [],
          `Version: abitype@${version_js_1.version}`
        ].join("\n");
        super(message);
        Object.defineProperty(this, "details", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "docsPath", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "metaMessages", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "shortMessage", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiTypeError"
        });
        if (args.cause)
          this.cause = args.cause;
        this.details = details;
        this.docsPath = docsPath;
        this.metaMessages = args.metaMessages;
        this.shortMessage = shortMessage;
      }
    };
    exports.BaseError = BaseError;
  }
});

// node_modules/viem/node_modules/abitype/dist/cjs/narrow.js
var require_narrow = __commonJS({
  "node_modules/viem/node_modules/abitype/dist/cjs/narrow.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.narrow = void 0;
    function narrow(value) {
      return value;
    }
    exports.narrow = narrow;
  }
});

// node_modules/viem/node_modules/abitype/dist/cjs/regex.js
var require_regex = __commonJS({
  "node_modules/viem/node_modules/abitype/dist/cjs/regex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isTupleRegex = exports.integerRegex = exports.bytesRegex = exports.execTyped = void 0;
    function execTyped(regex, string) {
      const match = regex.exec(string);
      return match?.groups;
    }
    exports.execTyped = execTyped;
    exports.bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
    exports.integerRegex = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
    exports.isTupleRegex = /^\(.+?\).*?$/;
  }
});

// node_modules/viem/node_modules/abitype/dist/cjs/human-readable/formatAbiParameter.js
var require_formatAbiParameter = __commonJS({
  "node_modules/viem/node_modules/abitype/dist/cjs/human-readable/formatAbiParameter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatAbiParameter = void 0;
    var regex_js_1 = require_regex();
    var tupleRegex = /^tuple(?<array>(\[(\d*)\])*)$/;
    function formatAbiParameter(abiParameter) {
      let type = abiParameter.type;
      if (tupleRegex.test(abiParameter.type) && "components" in abiParameter) {
        type = "(";
        const length = abiParameter.components.length;
        for (let i = 0; i < length; i++) {
          const component = abiParameter.components[i];
          type += formatAbiParameter(component);
          if (i < length - 1)
            type += ", ";
        }
        const result = (0, regex_js_1.execTyped)(tupleRegex, abiParameter.type);
        type += `)${result?.array ?? ""}`;
        return formatAbiParameter({
          ...abiParameter,
          type
        });
      }
      if ("indexed" in abiParameter && abiParameter.indexed)
        type = `${type} indexed`;
      if (abiParameter.name)
        return `${type} ${abiParameter.name}`;
      return type;
    }
    exports.formatAbiParameter = formatAbiParameter;
  }
});

// node_modules/viem/node_modules/abitype/dist/cjs/human-readable/formatAbiParameters.js
var require_formatAbiParameters = __commonJS({
  "node_modules/viem/node_modules/abitype/dist/cjs/human-readable/formatAbiParameters.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatAbiParameters = void 0;
    var formatAbiParameter_js_1 = require_formatAbiParameter();
    function formatAbiParameters(abiParameters) {
      let params = "";
      const length = abiParameters.length;
      for (let i = 0; i < length; i++) {
        const abiParameter = abiParameters[i];
        params += (0, formatAbiParameter_js_1.formatAbiParameter)(abiParameter);
        if (i !== length - 1)
          params += ", ";
      }
      return params;
    }
    exports.formatAbiParameters = formatAbiParameters;
  }
});

// node_modules/viem/node_modules/abitype/dist/cjs/human-readable/formatAbiItem.js
var require_formatAbiItem = __commonJS({
  "node_modules/viem/node_modules/abitype/dist/cjs/human-readable/formatAbiItem.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatAbiItem = void 0;
    var formatAbiParameters_js_1 = require_formatAbiParameters();
    function formatAbiItem(abiItem) {
      if (abiItem.type === "function")
        return `function ${abiItem.name}(${(0, formatAbiParameters_js_1.formatAbiParameters)(abiItem.inputs)})${abiItem.stateMutability && abiItem.stateMutability !== "nonpayable" ? ` ${abiItem.stateMutability}` : ""}${abiItem.outputs.length ? ` returns (${(0, formatAbiParameters_js_1.formatAbiParameters)(abiItem.outputs)})` : ""}`;
      else if (abiItem.type === "event")
        return `event ${abiItem.name}(${(0, formatAbiParameters_js_1.formatAbiParameters)(abiItem.inputs)})`;
      else if (abiItem.type === "error")
        return `error ${abiItem.name}(${(0, formatAbiParameters_js_1.formatAbiParameters)(abiItem.inputs)})`;
      else if (abiItem.type === "constructor")
        return `constructor(${(0, formatAbiParameters_js_1.formatAbiParameters)(abiItem.inputs)})${abiItem.stateMutability === "payable" ? " payable" : ""}`;
      else if (abiItem.type === "fallback")
        return "fallback()";
      return "receive() external payable";
    }
    exports.formatAbiItem = formatAbiItem;
  }
});

// node_modules/viem/node_modules/abitype/dist/cjs/human-readable/formatAbi.js
var require_formatAbi = __commonJS({
  "node_modules/viem/node_modules/abitype/dist/cjs/human-readable/formatAbi.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatAbi = void 0;
    var formatAbiItem_js_1 = require_formatAbiItem();
    function formatAbi(abi) {
      const signatures = [];
      const length = abi.length;
      for (let i = 0; i < length; i++) {
        const abiItem = abi[i];
        const signature = (0, formatAbiItem_js_1.formatAbiItem)(abiItem);
        signatures.push(signature);
      }
      return signatures;
    }
    exports.formatAbi = formatAbi;
  }
});

// node_modules/viem/node_modules/abitype/dist/cjs/human-readable/runtime/signatures.js
var require_signatures = __commonJS({
  "node_modules/viem/node_modules/abitype/dist/cjs/human-readable/runtime/signatures.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.functionModifiers = exports.eventModifiers = exports.modifiers = exports.isReceiveSignature = exports.isFallbackSignature = exports.execConstructorSignature = exports.isConstructorSignature = exports.execStructSignature = exports.isStructSignature = exports.execFunctionSignature = exports.isFunctionSignature = exports.execEventSignature = exports.isEventSignature = exports.execErrorSignature = exports.isErrorSignature = void 0;
    var regex_js_1 = require_regex();
    var errorSignatureRegex = /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
    function isErrorSignature(signature) {
      return errorSignatureRegex.test(signature);
    }
    exports.isErrorSignature = isErrorSignature;
    function execErrorSignature(signature) {
      return (0, regex_js_1.execTyped)(errorSignatureRegex, signature);
    }
    exports.execErrorSignature = execErrorSignature;
    var eventSignatureRegex = /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
    function isEventSignature(signature) {
      return eventSignatureRegex.test(signature);
    }
    exports.isEventSignature = isEventSignature;
    function execEventSignature(signature) {
      return (0, regex_js_1.execTyped)(eventSignatureRegex, signature);
    }
    exports.execEventSignature = execEventSignature;
    var functionSignatureRegex = /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\s?\((?<returns>.*?)\))?$/;
    function isFunctionSignature(signature) {
      return functionSignatureRegex.test(signature);
    }
    exports.isFunctionSignature = isFunctionSignature;
    function execFunctionSignature(signature) {
      return (0, regex_js_1.execTyped)(functionSignatureRegex, signature);
    }
    exports.execFunctionSignature = execFunctionSignature;
    var structSignatureRegex = /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \{(?<properties>.*?)\}$/;
    function isStructSignature(signature) {
      return structSignatureRegex.test(signature);
    }
    exports.isStructSignature = isStructSignature;
    function execStructSignature(signature) {
      return (0, regex_js_1.execTyped)(structSignatureRegex, signature);
    }
    exports.execStructSignature = execStructSignature;
    var constructorSignatureRegex = /^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable{1}))?$/;
    function isConstructorSignature(signature) {
      return constructorSignatureRegex.test(signature);
    }
    exports.isConstructorSignature = isConstructorSignature;
    function execConstructorSignature(signature) {
      return (0, regex_js_1.execTyped)(constructorSignatureRegex, signature);
    }
    exports.execConstructorSignature = execConstructorSignature;
    var fallbackSignatureRegex = /^fallback\(\)$/;
    function isFallbackSignature(signature) {
      return fallbackSignatureRegex.test(signature);
    }
    exports.isFallbackSignature = isFallbackSignature;
    var receiveSignatureRegex = /^receive\(\) external payable$/;
    function isReceiveSignature(signature) {
      return receiveSignatureRegex.test(signature);
    }
    exports.isReceiveSignature = isReceiveSignature;
    exports.modifiers = /* @__PURE__ */ new Set([
      "memory",
      "indexed",
      "storage",
      "calldata"
    ]);
    exports.eventModifiers = /* @__PURE__ */ new Set(["indexed"]);
    exports.functionModifiers = /* @__PURE__ */ new Set([
      "calldata",
      "memory",
      "storage"
    ]);
  }
});

// node_modules/viem/node_modules/abitype/dist/cjs/human-readable/errors/abiItem.js
var require_abiItem = __commonJS({
  "node_modules/viem/node_modules/abitype/dist/cjs/human-readable/errors/abiItem.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UnknownSolidityTypeError = exports.UnknownTypeError = exports.InvalidAbiItemError = void 0;
    var errors_js_1 = require_errors();
    var InvalidAbiItemError = class extends errors_js_1.BaseError {
      constructor({ signature }) {
        super("Failed to parse ABI item.", {
          details: `parseAbiItem(${JSON.stringify(signature, null, 2)})`,
          docsPath: "/api/human.html#parseabiitem-1"
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidAbiItemError"
        });
      }
    };
    exports.InvalidAbiItemError = InvalidAbiItemError;
    var UnknownTypeError = class extends errors_js_1.BaseError {
      constructor({ type }) {
        super("Unknown type.", {
          metaMessages: [
            `Type "${type}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "UnknownTypeError"
        });
      }
    };
    exports.UnknownTypeError = UnknownTypeError;
    var UnknownSolidityTypeError = class extends errors_js_1.BaseError {
      constructor({ type }) {
        super("Unknown type.", {
          metaMessages: [`Type "${type}" is not a valid ABI type.`]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "UnknownSolidityTypeError"
        });
      }
    };
    exports.UnknownSolidityTypeError = UnknownSolidityTypeError;
  }
});

// node_modules/viem/node_modules/abitype/dist/cjs/human-readable/errors/abiParameter.js
var require_abiParameter = __commonJS({
  "node_modules/viem/node_modules/abitype/dist/cjs/human-readable/errors/abiParameter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InvalidAbiTypeParameterError = exports.InvalidFunctionModifierError = exports.InvalidModifierError = exports.SolidityProtectedKeywordError = exports.InvalidParameterError = exports.InvalidAbiParametersError = exports.InvalidAbiParameterError = void 0;
    var errors_js_1 = require_errors();
    var InvalidAbiParameterError = class extends errors_js_1.BaseError {
      constructor({ param }) {
        super("Failed to parse ABI parameter.", {
          details: `parseAbiParameter(${JSON.stringify(param, null, 2)})`,
          docsPath: "/api/human.html#parseabiparameter-1"
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidAbiParameterError"
        });
      }
    };
    exports.InvalidAbiParameterError = InvalidAbiParameterError;
    var InvalidAbiParametersError = class extends errors_js_1.BaseError {
      constructor({ params }) {
        super("Failed to parse ABI parameters.", {
          details: `parseAbiParameters(${JSON.stringify(params, null, 2)})`,
          docsPath: "/api/human.html#parseabiparameters-1"
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidAbiParametersError"
        });
      }
    };
    exports.InvalidAbiParametersError = InvalidAbiParametersError;
    var InvalidParameterError = class extends errors_js_1.BaseError {
      constructor({ param }) {
        super("Invalid ABI parameter.", {
          details: param
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidParameterError"
        });
      }
    };
    exports.InvalidParameterError = InvalidParameterError;
    var SolidityProtectedKeywordError = class extends errors_js_1.BaseError {
      constructor({ param, name }) {
        super("Invalid ABI parameter.", {
          details: param,
          metaMessages: [
            `"${name}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "SolidityProtectedKeywordError"
        });
      }
    };
    exports.SolidityProtectedKeywordError = SolidityProtectedKeywordError;
    var InvalidModifierError = class extends errors_js_1.BaseError {
      constructor({ param, type, modifier }) {
        super("Invalid ABI parameter.", {
          details: param,
          metaMessages: [
            `Modifier "${modifier}" not allowed${type ? ` in "${type}" type` : ""}.`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidModifierError"
        });
      }
    };
    exports.InvalidModifierError = InvalidModifierError;
    var InvalidFunctionModifierError = class extends errors_js_1.BaseError {
      constructor({ param, type, modifier }) {
        super("Invalid ABI parameter.", {
          details: param,
          metaMessages: [
            `Modifier "${modifier}" not allowed${type ? ` in "${type}" type` : ""}.`,
            `Data location can only be specified for array, struct, or mapping types, but "${modifier}" was given.`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidFunctionModifierError"
        });
      }
    };
    exports.InvalidFunctionModifierError = InvalidFunctionModifierError;
    var InvalidAbiTypeParameterError = class extends errors_js_1.BaseError {
      constructor({ abiParameter }) {
        super("Invalid ABI parameter.", {
          details: JSON.stringify(abiParameter, null, 2),
          metaMessages: ["ABI parameter type is invalid."]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidAbiTypeParameterError"
        });
      }
    };
    exports.InvalidAbiTypeParameterError = InvalidAbiTypeParameterError;
  }
});

// node_modules/viem/node_modules/abitype/dist/cjs/human-readable/errors/signature.js
var require_signature = __commonJS({
  "node_modules/viem/node_modules/abitype/dist/cjs/human-readable/errors/signature.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InvalidStructSignatureError = exports.UnknownSignatureError = exports.InvalidSignatureError = void 0;
    var errors_js_1 = require_errors();
    var InvalidSignatureError = class extends errors_js_1.BaseError {
      constructor({ signature, type }) {
        super(`Invalid ${type} signature.`, {
          details: signature
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidSignatureError"
        });
      }
    };
    exports.InvalidSignatureError = InvalidSignatureError;
    var UnknownSignatureError = class extends errors_js_1.BaseError {
      constructor({ signature }) {
        super("Unknown signature.", {
          details: signature
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "UnknownSignatureError"
        });
      }
    };
    exports.UnknownSignatureError = UnknownSignatureError;
    var InvalidStructSignatureError = class extends errors_js_1.BaseError {
      constructor({ signature }) {
        super("Invalid struct signature.", {
          details: signature,
          metaMessages: ["No properties exist."]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidStructSignatureError"
        });
      }
    };
    exports.InvalidStructSignatureError = InvalidStructSignatureError;
  }
});

// node_modules/viem/node_modules/abitype/dist/cjs/human-readable/errors/struct.js
var require_struct = __commonJS({
  "node_modules/viem/node_modules/abitype/dist/cjs/human-readable/errors/struct.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CircularReferenceError = void 0;
    var errors_js_1 = require_errors();
    var CircularReferenceError = class extends errors_js_1.BaseError {
      constructor({ type }) {
        super("Circular reference detected.", {
          metaMessages: [`Struct "${type}" is a circular reference.`]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "CircularReferenceError"
        });
      }
    };
    exports.CircularReferenceError = CircularReferenceError;
  }
});

// node_modules/viem/node_modules/abitype/dist/cjs/human-readable/errors/splitParameters.js
var require_splitParameters = __commonJS({
  "node_modules/viem/node_modules/abitype/dist/cjs/human-readable/errors/splitParameters.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InvalidParenthesisError = void 0;
    var errors_js_1 = require_errors();
    var InvalidParenthesisError = class extends errors_js_1.BaseError {
      constructor({ current, depth }) {
        super("Unbalanced parentheses.", {
          metaMessages: [
            `"${current.trim()}" has too many ${depth > 0 ? "opening" : "closing"} parentheses.`
          ],
          details: `Depth "${depth}"`
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidParenthesisError"
        });
      }
    };
    exports.InvalidParenthesisError = InvalidParenthesisError;
  }
});

// node_modules/viem/node_modules/abitype/dist/cjs/human-readable/runtime/cache.js
var require_cache = __commonJS({
  "node_modules/viem/node_modules/abitype/dist/cjs/human-readable/runtime/cache.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parameterCache = exports.getParameterCacheKey = void 0;
    function getParameterCacheKey(param, type) {
      if (type)
        return `${type}:${param}`;
      return param;
    }
    exports.getParameterCacheKey = getParameterCacheKey;
    exports.parameterCache = /* @__PURE__ */ new Map([
      ["address", { type: "address" }],
      ["bool", { type: "bool" }],
      ["bytes", { type: "bytes" }],
      ["bytes32", { type: "bytes32" }],
      ["int", { type: "int256" }],
      ["int256", { type: "int256" }],
      ["string", { type: "string" }],
      ["uint", { type: "uint256" }],
      ["uint8", { type: "uint8" }],
      ["uint16", { type: "uint16" }],
      ["uint24", { type: "uint24" }],
      ["uint32", { type: "uint32" }],
      ["uint64", { type: "uint64" }],
      ["uint96", { type: "uint96" }],
      ["uint112", { type: "uint112" }],
      ["uint160", { type: "uint160" }],
      ["uint192", { type: "uint192" }],
      ["uint256", { type: "uint256" }],
      ["address owner", { type: "address", name: "owner" }],
      ["address to", { type: "address", name: "to" }],
      ["bool approved", { type: "bool", name: "approved" }],
      ["bytes _data", { type: "bytes", name: "_data" }],
      ["bytes data", { type: "bytes", name: "data" }],
      ["bytes signature", { type: "bytes", name: "signature" }],
      ["bytes32 hash", { type: "bytes32", name: "hash" }],
      ["bytes32 r", { type: "bytes32", name: "r" }],
      ["bytes32 root", { type: "bytes32", name: "root" }],
      ["bytes32 s", { type: "bytes32", name: "s" }],
      ["string name", { type: "string", name: "name" }],
      ["string symbol", { type: "string", name: "symbol" }],
      ["string tokenURI", { type: "string", name: "tokenURI" }],
      ["uint tokenId", { type: "uint256", name: "tokenId" }],
      ["uint8 v", { type: "uint8", name: "v" }],
      ["uint256 balance", { type: "uint256", name: "balance" }],
      ["uint256 tokenId", { type: "uint256", name: "tokenId" }],
      ["uint256 value", { type: "uint256", name: "value" }],
      [
        "event:address indexed from",
        { type: "address", name: "from", indexed: true }
      ],
      ["event:address indexed to", { type: "address", name: "to", indexed: true }],
      [
        "event:uint indexed tokenId",
        { type: "uint256", name: "tokenId", indexed: true }
      ],
      [
        "event:uint256 indexed tokenId",
        { type: "uint256", name: "tokenId", indexed: true }
      ]
    ]);
  }
});

// node_modules/viem/node_modules/abitype/dist/cjs/human-readable/runtime/utils.js
var require_utils4 = __commonJS({
  "node_modules/viem/node_modules/abitype/dist/cjs/human-readable/runtime/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isValidDataLocation = exports.isSolidityKeyword = exports.isSolidityType = exports.splitParameters = exports.parseAbiParameter = exports.parseSignature = void 0;
    var regex_js_1 = require_regex();
    var abiItem_js_1 = require_abiItem();
    var abiParameter_js_1 = require_abiParameter();
    var signature_js_1 = require_signature();
    var splitParameters_js_1 = require_splitParameters();
    var cache_js_1 = require_cache();
    var signatures_js_1 = require_signatures();
    function parseSignature(signature, structs = {}) {
      if ((0, signatures_js_1.isFunctionSignature)(signature)) {
        const match = (0, signatures_js_1.execFunctionSignature)(signature);
        if (!match)
          throw new signature_js_1.InvalidSignatureError({ signature, type: "function" });
        const inputParams = splitParameters(match.parameters);
        const inputs = [];
        const inputLength = inputParams.length;
        for (let i = 0; i < inputLength; i++) {
          inputs.push(parseAbiParameter(inputParams[i], {
            modifiers: signatures_js_1.functionModifiers,
            structs,
            type: "function"
          }));
        }
        const outputs = [];
        if (match.returns) {
          const outputParams = splitParameters(match.returns);
          const outputLength = outputParams.length;
          for (let i = 0; i < outputLength; i++) {
            outputs.push(parseAbiParameter(outputParams[i], {
              modifiers: signatures_js_1.functionModifiers,
              structs,
              type: "function"
            }));
          }
        }
        return {
          name: match.name,
          type: "function",
          stateMutability: match.stateMutability ?? "nonpayable",
          inputs,
          outputs
        };
      }
      if ((0, signatures_js_1.isEventSignature)(signature)) {
        const match = (0, signatures_js_1.execEventSignature)(signature);
        if (!match)
          throw new signature_js_1.InvalidSignatureError({ signature, type: "event" });
        const params = splitParameters(match.parameters);
        const abiParameters = [];
        const length = params.length;
        for (let i = 0; i < length; i++) {
          abiParameters.push(parseAbiParameter(params[i], {
            modifiers: signatures_js_1.eventModifiers,
            structs,
            type: "event"
          }));
        }
        return { name: match.name, type: "event", inputs: abiParameters };
      }
      if ((0, signatures_js_1.isErrorSignature)(signature)) {
        const match = (0, signatures_js_1.execErrorSignature)(signature);
        if (!match)
          throw new signature_js_1.InvalidSignatureError({ signature, type: "error" });
        const params = splitParameters(match.parameters);
        const abiParameters = [];
        const length = params.length;
        for (let i = 0; i < length; i++) {
          abiParameters.push(parseAbiParameter(params[i], { structs, type: "error" }));
        }
        return { name: match.name, type: "error", inputs: abiParameters };
      }
      if ((0, signatures_js_1.isConstructorSignature)(signature)) {
        const match = (0, signatures_js_1.execConstructorSignature)(signature);
        if (!match)
          throw new signature_js_1.InvalidSignatureError({ signature, type: "constructor" });
        const params = splitParameters(match.parameters);
        const abiParameters = [];
        const length = params.length;
        for (let i = 0; i < length; i++) {
          abiParameters.push(parseAbiParameter(params[i], { structs, type: "constructor" }));
        }
        return {
          type: "constructor",
          stateMutability: match.stateMutability ?? "nonpayable",
          inputs: abiParameters
        };
      }
      if ((0, signatures_js_1.isFallbackSignature)(signature))
        return { type: "fallback" };
      if ((0, signatures_js_1.isReceiveSignature)(signature))
        return {
          type: "receive",
          stateMutability: "payable"
        };
      throw new signature_js_1.UnknownSignatureError({ signature });
    }
    exports.parseSignature = parseSignature;
    var abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;
    var abiParameterWithTupleRegex = /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;
    var dynamicIntegerRegex = /^u?int$/;
    function parseAbiParameter(param, options) {
      const parameterCacheKey = (0, cache_js_1.getParameterCacheKey)(param, options?.type);
      if (cache_js_1.parameterCache.has(parameterCacheKey))
        return cache_js_1.parameterCache.get(parameterCacheKey);
      const isTuple = regex_js_1.isTupleRegex.test(param);
      const match = (0, regex_js_1.execTyped)(isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex, param);
      if (!match)
        throw new abiParameter_js_1.InvalidParameterError({ param });
      if (match.name && isSolidityKeyword(match.name))
        throw new abiParameter_js_1.SolidityProtectedKeywordError({ param, name: match.name });
      const name = match.name ? { name: match.name } : {};
      const indexed = match.modifier === "indexed" ? { indexed: true } : {};
      const structs = options?.structs ?? {};
      let type;
      let components = {};
      if (isTuple) {
        type = "tuple";
        const params = splitParameters(match.type);
        const components_ = [];
        const length = params.length;
        for (let i = 0; i < length; i++) {
          components_.push(parseAbiParameter(params[i], { structs }));
        }
        components = { components: components_ };
      } else if (match.type in structs) {
        type = "tuple";
        components = { components: structs[match.type] };
      } else if (dynamicIntegerRegex.test(match.type)) {
        type = `${match.type}256`;
      } else {
        type = match.type;
        if (!(options?.type === "struct") && !isSolidityType(type))
          throw new abiItem_js_1.UnknownSolidityTypeError({ type });
      }
      if (match.modifier) {
        if (!options?.modifiers?.has?.(match.modifier))
          throw new abiParameter_js_1.InvalidModifierError({
            param,
            type: options?.type,
            modifier: match.modifier
          });
        if (signatures_js_1.functionModifiers.has(match.modifier) && !isValidDataLocation(type, !!match.array))
          throw new abiParameter_js_1.InvalidFunctionModifierError({
            param,
            type: options?.type,
            modifier: match.modifier
          });
      }
      const abiParameter = {
        type: `${type}${match.array ?? ""}`,
        ...name,
        ...indexed,
        ...components
      };
      cache_js_1.parameterCache.set(parameterCacheKey, abiParameter);
      return abiParameter;
    }
    exports.parseAbiParameter = parseAbiParameter;
    function splitParameters(params, result = [], current = "", depth = 0) {
      if (params === "") {
        if (current === "")
          return result;
        if (depth !== 0)
          throw new splitParameters_js_1.InvalidParenthesisError({ current, depth });
        result.push(current.trim());
        return result;
      }
      const length = params.length;
      for (let i = 0; i < length; i++) {
        const char = params[i];
        const tail = params.slice(i + 1);
        switch (char) {
          case ",":
            return depth === 0 ? splitParameters(tail, [...result, current.trim()]) : splitParameters(tail, result, `${current}${char}`, depth);
          case "(":
            return splitParameters(tail, result, `${current}${char}`, depth + 1);
          case ")":
            return splitParameters(tail, result, `${current}${char}`, depth - 1);
          default:
            return splitParameters(tail, result, `${current}${char}`, depth);
        }
      }
      return [];
    }
    exports.splitParameters = splitParameters;
    function isSolidityType(type) {
      return type === "address" || type === "bool" || type === "function" || type === "string" || regex_js_1.bytesRegex.test(type) || regex_js_1.integerRegex.test(type);
    }
    exports.isSolidityType = isSolidityType;
    var protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;
    function isSolidityKeyword(name) {
      return name === "address" || name === "bool" || name === "function" || name === "string" || name === "tuple" || regex_js_1.bytesRegex.test(name) || regex_js_1.integerRegex.test(name) || protectedKeywordsRegex.test(name);
    }
    exports.isSolidityKeyword = isSolidityKeyword;
    function isValidDataLocation(type, isArray) {
      return isArray || type === "bytes" || type === "string" || type === "tuple";
    }
    exports.isValidDataLocation = isValidDataLocation;
  }
});

// node_modules/viem/node_modules/abitype/dist/cjs/human-readable/runtime/structs.js
var require_structs = __commonJS({
  "node_modules/viem/node_modules/abitype/dist/cjs/human-readable/runtime/structs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseStructs = void 0;
    var regex_js_1 = require_regex();
    var abiItem_js_1 = require_abiItem();
    var abiParameter_js_1 = require_abiParameter();
    var signature_js_1 = require_signature();
    var struct_js_1 = require_struct();
    var signatures_js_1 = require_signatures();
    var utils_js_1 = require_utils4();
    function parseStructs(signatures) {
      const shallowStructs = {};
      const signaturesLength = signatures.length;
      for (let i = 0; i < signaturesLength; i++) {
        const signature = signatures[i];
        if (!(0, signatures_js_1.isStructSignature)(signature))
          continue;
        const match = (0, signatures_js_1.execStructSignature)(signature);
        if (!match)
          throw new signature_js_1.InvalidSignatureError({ signature, type: "struct" });
        const properties = match.properties.split(";");
        const components = [];
        const propertiesLength = properties.length;
        for (let k = 0; k < propertiesLength; k++) {
          const property = properties[k];
          const trimmed = property.trim();
          if (!trimmed)
            continue;
          const abiParameter = (0, utils_js_1.parseAbiParameter)(trimmed, {
            type: "struct"
          });
          components.push(abiParameter);
        }
        if (!components.length)
          throw new signature_js_1.InvalidStructSignatureError({ signature });
        shallowStructs[match.name] = components;
      }
      const resolvedStructs = {};
      const entries = Object.entries(shallowStructs);
      const entriesLength = entries.length;
      for (let i = 0; i < entriesLength; i++) {
        const [name, parameters] = entries[i];
        resolvedStructs[name] = resolveStructs(parameters, shallowStructs);
      }
      return resolvedStructs;
    }
    exports.parseStructs = parseStructs;
    var typeWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/;
    function resolveStructs(abiParameters, structs, ancestors = /* @__PURE__ */ new Set()) {
      const components = [];
      const length = abiParameters.length;
      for (let i = 0; i < length; i++) {
        const abiParameter = abiParameters[i];
        const isTuple = regex_js_1.isTupleRegex.test(abiParameter.type);
        if (isTuple)
          components.push(abiParameter);
        else {
          const match = (0, regex_js_1.execTyped)(typeWithoutTupleRegex, abiParameter.type);
          if (!match?.type)
            throw new abiParameter_js_1.InvalidAbiTypeParameterError({ abiParameter });
          const { array, type } = match;
          if (type in structs) {
            if (ancestors.has(type))
              throw new struct_js_1.CircularReferenceError({ type });
            components.push({
              ...abiParameter,
              type: `tuple${array ?? ""}`,
              components: resolveStructs(structs[type] ?? [], structs, /* @__PURE__ */ new Set([...ancestors, type]))
            });
          } else {
            if ((0, utils_js_1.isSolidityType)(type))
              components.push(abiParameter);
            else
              throw new abiItem_js_1.UnknownTypeError({ type });
          }
        }
      }
      return components;
    }
  }
});

// node_modules/viem/node_modules/abitype/dist/cjs/human-readable/parseAbi.js
var require_parseAbi = __commonJS({
  "node_modules/viem/node_modules/abitype/dist/cjs/human-readable/parseAbi.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseAbi = void 0;
    var signatures_js_1 = require_signatures();
    var structs_js_1 = require_structs();
    var utils_js_1 = require_utils4();
    function parseAbi(signatures) {
      const structs = (0, structs_js_1.parseStructs)(signatures);
      const abi = [];
      const length = signatures.length;
      for (let i = 0; i < length; i++) {
        const signature = signatures[i];
        if ((0, signatures_js_1.isStructSignature)(signature))
          continue;
        abi.push((0, utils_js_1.parseSignature)(signature, structs));
      }
      return abi;
    }
    exports.parseAbi = parseAbi;
  }
});

// node_modules/viem/node_modules/abitype/dist/cjs/human-readable/parseAbiItem.js
var require_parseAbiItem = __commonJS({
  "node_modules/viem/node_modules/abitype/dist/cjs/human-readable/parseAbiItem.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseAbiItem = void 0;
    var index_js_1 = require_cjs();
    var signatures_js_1 = require_signatures();
    var structs_js_1 = require_structs();
    var utils_js_1 = require_utils4();
    function parseAbiItem(signature) {
      let abiItem;
      if (typeof signature === "string")
        abiItem = (0, utils_js_1.parseSignature)(signature);
      else {
        const structs = (0, structs_js_1.parseStructs)(signature);
        const length = signature.length;
        for (let i = 0; i < length; i++) {
          const signature_ = signature[i];
          if ((0, signatures_js_1.isStructSignature)(signature_))
            continue;
          abiItem = (0, utils_js_1.parseSignature)(signature_, structs);
          break;
        }
      }
      if (!abiItem)
        throw new index_js_1.InvalidAbiItemError({ signature });
      return abiItem;
    }
    exports.parseAbiItem = parseAbiItem;
  }
});

// node_modules/viem/node_modules/abitype/dist/cjs/human-readable/parseAbiParameter.js
var require_parseAbiParameter = __commonJS({
  "node_modules/viem/node_modules/abitype/dist/cjs/human-readable/parseAbiParameter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseAbiParameter = void 0;
    var index_js_1 = require_cjs();
    var signatures_js_1 = require_signatures();
    var structs_js_1 = require_structs();
    var utils_js_1 = require_utils4();
    function parseAbiParameter(param) {
      let abiParameter;
      if (typeof param === "string")
        abiParameter = (0, utils_js_1.parseAbiParameter)(param, {
          modifiers: signatures_js_1.modifiers
        });
      else {
        const structs = (0, structs_js_1.parseStructs)(param);
        const length = param.length;
        for (let i = 0; i < length; i++) {
          const signature = param[i];
          if ((0, signatures_js_1.isStructSignature)(signature))
            continue;
          abiParameter = (0, utils_js_1.parseAbiParameter)(signature, { modifiers: signatures_js_1.modifiers, structs });
          break;
        }
      }
      if (!abiParameter)
        throw new index_js_1.InvalidAbiParameterError({ param });
      return abiParameter;
    }
    exports.parseAbiParameter = parseAbiParameter;
  }
});

// node_modules/viem/node_modules/abitype/dist/cjs/human-readable/parseAbiParameters.js
var require_parseAbiParameters = __commonJS({
  "node_modules/viem/node_modules/abitype/dist/cjs/human-readable/parseAbiParameters.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseAbiParameters = void 0;
    var index_js_1 = require_cjs();
    var signatures_js_1 = require_signatures();
    var structs_js_1 = require_structs();
    var utils_js_1 = require_utils4();
    var utils_js_2 = require_utils4();
    function parseAbiParameters(params) {
      const abiParameters = [];
      if (typeof params === "string") {
        const parameters = (0, utils_js_1.splitParameters)(params);
        const length = parameters.length;
        for (let i = 0; i < length; i++) {
          abiParameters.push((0, utils_js_2.parseAbiParameter)(parameters[i], { modifiers: signatures_js_1.modifiers }));
        }
      } else {
        const structs = (0, structs_js_1.parseStructs)(params);
        const length = params.length;
        for (let i = 0; i < length; i++) {
          const signature = params[i];
          if ((0, signatures_js_1.isStructSignature)(signature))
            continue;
          const parameters = (0, utils_js_1.splitParameters)(signature);
          const length2 = parameters.length;
          for (let k = 0; k < length2; k++) {
            abiParameters.push((0, utils_js_2.parseAbiParameter)(parameters[k], { modifiers: signatures_js_1.modifiers, structs }));
          }
        }
      }
      if (abiParameters.length === 0)
        throw new index_js_1.InvalidAbiParametersError({ params });
      return abiParameters;
    }
    exports.parseAbiParameters = parseAbiParameters;
  }
});

// node_modules/viem/node_modules/abitype/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/viem/node_modules/abitype/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CircularReferenceError = exports.InvalidParenthesisError = exports.UnknownSignatureError = exports.InvalidSignatureError = exports.InvalidStructSignatureError = exports.InvalidAbiParameterError = exports.InvalidAbiParametersError = exports.InvalidParameterError = exports.SolidityProtectedKeywordError = exports.InvalidModifierError = exports.InvalidFunctionModifierError = exports.InvalidAbiTypeParameterError = exports.UnknownSolidityTypeError = exports.InvalidAbiItemError = exports.UnknownTypeError = exports.parseAbiParameters = exports.parseAbiParameter = exports.parseAbiItem = exports.parseAbi = exports.formatAbiParameters = exports.formatAbiParameter = exports.formatAbiItem = exports.formatAbi = exports.narrow = exports.BaseError = void 0;
    var errors_js_1 = require_errors();
    Object.defineProperty(exports, "BaseError", { enumerable: true, get: function() {
      return errors_js_1.BaseError;
    } });
    var narrow_js_1 = require_narrow();
    Object.defineProperty(exports, "narrow", { enumerable: true, get: function() {
      return narrow_js_1.narrow;
    } });
    var formatAbi_js_1 = require_formatAbi();
    Object.defineProperty(exports, "formatAbi", { enumerable: true, get: function() {
      return formatAbi_js_1.formatAbi;
    } });
    var formatAbiItem_js_1 = require_formatAbiItem();
    Object.defineProperty(exports, "formatAbiItem", { enumerable: true, get: function() {
      return formatAbiItem_js_1.formatAbiItem;
    } });
    var formatAbiParameter_js_1 = require_formatAbiParameter();
    Object.defineProperty(exports, "formatAbiParameter", { enumerable: true, get: function() {
      return formatAbiParameter_js_1.formatAbiParameter;
    } });
    var formatAbiParameters_js_1 = require_formatAbiParameters();
    Object.defineProperty(exports, "formatAbiParameters", { enumerable: true, get: function() {
      return formatAbiParameters_js_1.formatAbiParameters;
    } });
    var parseAbi_js_1 = require_parseAbi();
    Object.defineProperty(exports, "parseAbi", { enumerable: true, get: function() {
      return parseAbi_js_1.parseAbi;
    } });
    var parseAbiItem_js_1 = require_parseAbiItem();
    Object.defineProperty(exports, "parseAbiItem", { enumerable: true, get: function() {
      return parseAbiItem_js_1.parseAbiItem;
    } });
    var parseAbiParameter_js_1 = require_parseAbiParameter();
    Object.defineProperty(exports, "parseAbiParameter", { enumerable: true, get: function() {
      return parseAbiParameter_js_1.parseAbiParameter;
    } });
    var parseAbiParameters_js_1 = require_parseAbiParameters();
    Object.defineProperty(exports, "parseAbiParameters", { enumerable: true, get: function() {
      return parseAbiParameters_js_1.parseAbiParameters;
    } });
    var abiItem_js_1 = require_abiItem();
    Object.defineProperty(exports, "UnknownTypeError", { enumerable: true, get: function() {
      return abiItem_js_1.UnknownTypeError;
    } });
    Object.defineProperty(exports, "InvalidAbiItemError", { enumerable: true, get: function() {
      return abiItem_js_1.InvalidAbiItemError;
    } });
    Object.defineProperty(exports, "UnknownSolidityTypeError", { enumerable: true, get: function() {
      return abiItem_js_1.UnknownSolidityTypeError;
    } });
    var abiParameter_js_1 = require_abiParameter();
    Object.defineProperty(exports, "InvalidAbiTypeParameterError", { enumerable: true, get: function() {
      return abiParameter_js_1.InvalidAbiTypeParameterError;
    } });
    Object.defineProperty(exports, "InvalidFunctionModifierError", { enumerable: true, get: function() {
      return abiParameter_js_1.InvalidFunctionModifierError;
    } });
    Object.defineProperty(exports, "InvalidModifierError", { enumerable: true, get: function() {
      return abiParameter_js_1.InvalidModifierError;
    } });
    Object.defineProperty(exports, "SolidityProtectedKeywordError", { enumerable: true, get: function() {
      return abiParameter_js_1.SolidityProtectedKeywordError;
    } });
    Object.defineProperty(exports, "InvalidParameterError", { enumerable: true, get: function() {
      return abiParameter_js_1.InvalidParameterError;
    } });
    Object.defineProperty(exports, "InvalidAbiParametersError", { enumerable: true, get: function() {
      return abiParameter_js_1.InvalidAbiParametersError;
    } });
    Object.defineProperty(exports, "InvalidAbiParameterError", { enumerable: true, get: function() {
      return abiParameter_js_1.InvalidAbiParameterError;
    } });
    var signature_js_1 = require_signature();
    Object.defineProperty(exports, "InvalidStructSignatureError", { enumerable: true, get: function() {
      return signature_js_1.InvalidStructSignatureError;
    } });
    Object.defineProperty(exports, "InvalidSignatureError", { enumerable: true, get: function() {
      return signature_js_1.InvalidSignatureError;
    } });
    Object.defineProperty(exports, "UnknownSignatureError", { enumerable: true, get: function() {
      return signature_js_1.UnknownSignatureError;
    } });
    var splitParameters_js_1 = require_splitParameters();
    Object.defineProperty(exports, "InvalidParenthesisError", { enumerable: true, get: function() {
      return splitParameters_js_1.InvalidParenthesisError;
    } });
    var struct_js_1 = require_struct();
    Object.defineProperty(exports, "CircularReferenceError", { enumerable: true, get: function() {
      return struct_js_1.CircularReferenceError;
    } });
  }
});

// node_modules/viem/_cjs/utils/abi/formatAbiItem.js
var require_formatAbiItem2 = __commonJS({
  "node_modules/viem/_cjs/utils/abi/formatAbiItem.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatAbiParams = exports.formatAbiItem = void 0;
    var abi_js_1 = require_abi();
    function formatAbiItem(abiItem, { includeName = false } = {}) {
      if (abiItem.type !== "function" && abiItem.type !== "event" && abiItem.type !== "error")
        throw new abi_js_1.InvalidDefinitionTypeError(abiItem.type);
      return `${abiItem.name}(${formatAbiParams(abiItem.inputs, { includeName })})`;
    }
    exports.formatAbiItem = formatAbiItem;
    function formatAbiParams(params, { includeName = false } = {}) {
      if (!params)
        return "";
      return params.map((param) => formatAbiParam(param, { includeName })).join(includeName ? ", " : ",");
    }
    exports.formatAbiParams = formatAbiParams;
    function formatAbiParam(param, { includeName }) {
      if (param.type.startsWith("tuple")) {
        return `(${formatAbiParams(param.components, { includeName })})${param.type.slice("tuple".length)}`;
      }
      return param.type + (includeName && param.name ? ` ${param.name}` : "");
    }
  }
});

// node_modules/viem/_cjs/errors/abi.js
var require_abi = __commonJS({
  "node_modules/viem/_cjs/errors/abi.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UnsupportedPackedAbiType = exports.InvalidDefinitionTypeError = exports.InvalidArrayError = exports.InvalidAbiDecodingTypeError = exports.InvalidAbiEncodingTypeError = exports.DecodeLogTopicsMismatch = exports.DecodeLogDataMismatch = exports.BytesSizeMismatchError = exports.AbiFunctionSignatureNotFoundError = exports.AbiFunctionOutputsNotFoundError = exports.AbiFunctionNotFoundError = exports.AbiEventNotFoundError = exports.AbiEventSignatureNotFoundError = exports.AbiEventSignatureEmptyTopicsError = exports.AbiErrorSignatureNotFoundError = exports.AbiErrorNotFoundError = exports.AbiErrorInputsNotFoundError = exports.AbiEncodingLengthMismatchError = exports.AbiEncodingBytesSizeMismatchError = exports.AbiEncodingArrayLengthMismatchError = exports.AbiDecodingZeroDataError = exports.AbiDecodingDataSizeTooSmallError = exports.AbiDecodingDataSizeInvalidError = exports.AbiConstructorParamsNotFoundError = exports.AbiConstructorNotFoundError = void 0;
    var formatAbiItem_js_1 = require_formatAbiItem2();
    var size_js_1 = require_size();
    var base_js_1 = require_base();
    var AbiConstructorNotFoundError = class extends base_js_1.BaseError {
      constructor({ docsPath }) {
        super([
          "A constructor was not found on the ABI.",
          "Make sure you are using the correct ABI and that the constructor exists on it."
        ].join("\n"), {
          docsPath
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiConstructorNotFoundError"
        });
      }
    };
    exports.AbiConstructorNotFoundError = AbiConstructorNotFoundError;
    var AbiConstructorParamsNotFoundError = class extends base_js_1.BaseError {
      constructor({ docsPath }) {
        super([
          "Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.",
          "Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists."
        ].join("\n"), {
          docsPath
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiConstructorParamsNotFoundError"
        });
      }
    };
    exports.AbiConstructorParamsNotFoundError = AbiConstructorParamsNotFoundError;
    var AbiDecodingDataSizeInvalidError = class extends base_js_1.BaseError {
      constructor({ data, size }) {
        super([
          `Data size of ${size} bytes is invalid.`,
          "Size must be in increments of 32 bytes (size % 32 === 0)."
        ].join("\n"), { metaMessages: [`Data: ${data} (${size} bytes)`] });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiDecodingDataSizeInvalidError"
        });
      }
    };
    exports.AbiDecodingDataSizeInvalidError = AbiDecodingDataSizeInvalidError;
    var AbiDecodingDataSizeTooSmallError = class extends base_js_1.BaseError {
      constructor({ data, params, size }) {
        super([`Data size of ${size} bytes is too small for given parameters.`].join("\n"), {
          metaMessages: [
            `Params: (${(0, formatAbiItem_js_1.formatAbiParams)(params, { includeName: true })})`,
            `Data:   ${data} (${size} bytes)`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiDecodingDataSizeTooSmallError"
        });
        Object.defineProperty(this, "data", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "params", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "size", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.data = data;
        this.params = params;
        this.size = size;
      }
    };
    exports.AbiDecodingDataSizeTooSmallError = AbiDecodingDataSizeTooSmallError;
    var AbiDecodingZeroDataError = class extends base_js_1.BaseError {
      constructor() {
        super('Cannot decode zero data ("0x") with ABI parameters.');
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiDecodingZeroDataError"
        });
      }
    };
    exports.AbiDecodingZeroDataError = AbiDecodingZeroDataError;
    var AbiEncodingArrayLengthMismatchError = class extends base_js_1.BaseError {
      constructor({ expectedLength, givenLength, type }) {
        super([
          `ABI encoding array length mismatch for type ${type}.`,
          `Expected length: ${expectedLength}`,
          `Given length: ${givenLength}`
        ].join("\n"));
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiEncodingArrayLengthMismatchError"
        });
      }
    };
    exports.AbiEncodingArrayLengthMismatchError = AbiEncodingArrayLengthMismatchError;
    var AbiEncodingBytesSizeMismatchError = class extends base_js_1.BaseError {
      constructor({ expectedSize, value }) {
        super(`Size of bytes "${value}" (bytes${(0, size_js_1.size)(value)}) does not match expected size (bytes${expectedSize}).`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiEncodingBytesSizeMismatchError"
        });
      }
    };
    exports.AbiEncodingBytesSizeMismatchError = AbiEncodingBytesSizeMismatchError;
    var AbiEncodingLengthMismatchError = class extends base_js_1.BaseError {
      constructor({ expectedLength, givenLength }) {
        super([
          "ABI encoding params/values length mismatch.",
          `Expected length (params): ${expectedLength}`,
          `Given length (values): ${givenLength}`
        ].join("\n"));
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiEncodingLengthMismatchError"
        });
      }
    };
    exports.AbiEncodingLengthMismatchError = AbiEncodingLengthMismatchError;
    var AbiErrorInputsNotFoundError = class extends base_js_1.BaseError {
      constructor(errorName, { docsPath }) {
        super([
          `Arguments (\`args\`) were provided to "${errorName}", but "${errorName}" on the ABI does not contain any parameters (\`inputs\`).`,
          "Cannot encode error result without knowing what the parameter types are.",
          "Make sure you are using the correct ABI and that the inputs exist on it."
        ].join("\n"), {
          docsPath
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiErrorInputsNotFoundError"
        });
      }
    };
    exports.AbiErrorInputsNotFoundError = AbiErrorInputsNotFoundError;
    var AbiErrorNotFoundError = class extends base_js_1.BaseError {
      constructor(errorName, { docsPath } = {}) {
        super([
          `Error ${errorName ? `"${errorName}" ` : ""}not found on ABI.`,
          "Make sure you are using the correct ABI and that the error exists on it."
        ].join("\n"), {
          docsPath
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiErrorNotFoundError"
        });
      }
    };
    exports.AbiErrorNotFoundError = AbiErrorNotFoundError;
    var AbiErrorSignatureNotFoundError = class extends base_js_1.BaseError {
      constructor(signature, { docsPath }) {
        super([
          `Encoded error signature "${signature}" not found on ABI.`,
          "Make sure you are using the correct ABI and that the error exists on it.",
          `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`
        ].join("\n"), {
          docsPath
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiErrorSignatureNotFoundError"
        });
        Object.defineProperty(this, "signature", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.signature = signature;
      }
    };
    exports.AbiErrorSignatureNotFoundError = AbiErrorSignatureNotFoundError;
    var AbiEventSignatureEmptyTopicsError = class extends base_js_1.BaseError {
      constructor({ docsPath }) {
        super("Cannot extract event signature from empty topics.", {
          docsPath
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiEventSignatureEmptyTopicsError"
        });
      }
    };
    exports.AbiEventSignatureEmptyTopicsError = AbiEventSignatureEmptyTopicsError;
    var AbiEventSignatureNotFoundError = class extends base_js_1.BaseError {
      constructor(signature, { docsPath }) {
        super([
          `Encoded event signature "${signature}" not found on ABI.`,
          "Make sure you are using the correct ABI and that the event exists on it.",
          `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`
        ].join("\n"), {
          docsPath
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiEventSignatureNotFoundError"
        });
      }
    };
    exports.AbiEventSignatureNotFoundError = AbiEventSignatureNotFoundError;
    var AbiEventNotFoundError = class extends base_js_1.BaseError {
      constructor(eventName, { docsPath } = {}) {
        super([
          `Event ${eventName ? `"${eventName}" ` : ""}not found on ABI.`,
          "Make sure you are using the correct ABI and that the event exists on it."
        ].join("\n"), {
          docsPath
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiEventNotFoundError"
        });
      }
    };
    exports.AbiEventNotFoundError = AbiEventNotFoundError;
    var AbiFunctionNotFoundError = class extends base_js_1.BaseError {
      constructor(functionName, { docsPath } = {}) {
        super([
          `Function ${functionName ? `"${functionName}" ` : ""}not found on ABI.`,
          "Make sure you are using the correct ABI and that the function exists on it."
        ].join("\n"), {
          docsPath
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiFunctionNotFoundError"
        });
      }
    };
    exports.AbiFunctionNotFoundError = AbiFunctionNotFoundError;
    var AbiFunctionOutputsNotFoundError = class extends base_js_1.BaseError {
      constructor(functionName, { docsPath }) {
        super([
          `Function "${functionName}" does not contain any \`outputs\` on ABI.`,
          "Cannot decode function result without knowing what the parameter types are.",
          "Make sure you are using the correct ABI and that the function exists on it."
        ].join("\n"), {
          docsPath
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiFunctionOutputsNotFoundError"
        });
      }
    };
    exports.AbiFunctionOutputsNotFoundError = AbiFunctionOutputsNotFoundError;
    var AbiFunctionSignatureNotFoundError = class extends base_js_1.BaseError {
      constructor(signature, { docsPath }) {
        super([
          `Encoded function signature "${signature}" not found on ABI.`,
          "Make sure you are using the correct ABI and that the function exists on it.",
          `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`
        ].join("\n"), {
          docsPath
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AbiFunctionSignatureNotFoundError"
        });
      }
    };
    exports.AbiFunctionSignatureNotFoundError = AbiFunctionSignatureNotFoundError;
    var BytesSizeMismatchError = class extends base_js_1.BaseError {
      constructor({ expectedSize, givenSize }) {
        super(`Expected bytes${expectedSize}, got bytes${givenSize}.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "BytesSizeMismatchError"
        });
      }
    };
    exports.BytesSizeMismatchError = BytesSizeMismatchError;
    var DecodeLogDataMismatch = class extends base_js_1.BaseError {
      constructor({ abiItem, data, params, size }) {
        super([
          `Data size of ${size} bytes is too small for non-indexed event parameters.`
        ].join("\n"), {
          metaMessages: [
            `Params: (${(0, formatAbiItem_js_1.formatAbiParams)(params, { includeName: true })})`,
            `Data:   ${data} (${size} bytes)`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "DecodeLogDataMismatch"
        });
        Object.defineProperty(this, "abiItem", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "data", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "params", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "size", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.abiItem = abiItem;
        this.data = data;
        this.params = params;
        this.size = size;
      }
    };
    exports.DecodeLogDataMismatch = DecodeLogDataMismatch;
    var DecodeLogTopicsMismatch = class extends base_js_1.BaseError {
      constructor({ abiItem, param }) {
        super([
          `Expected a topic for indexed event parameter${param.name ? ` "${param.name}"` : ""} on event "${(0, formatAbiItem_js_1.formatAbiItem)(abiItem, { includeName: true })}".`
        ].join("\n"));
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "DecodeLogTopicsMismatch"
        });
        Object.defineProperty(this, "abiItem", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.abiItem = abiItem;
      }
    };
    exports.DecodeLogTopicsMismatch = DecodeLogTopicsMismatch;
    var InvalidAbiEncodingTypeError = class extends base_js_1.BaseError {
      constructor(type, { docsPath }) {
        super([
          `Type "${type}" is not a valid encoding type.`,
          "Please provide a valid ABI type."
        ].join("\n"), { docsPath });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidAbiEncodingType"
        });
      }
    };
    exports.InvalidAbiEncodingTypeError = InvalidAbiEncodingTypeError;
    var InvalidAbiDecodingTypeError = class extends base_js_1.BaseError {
      constructor(type, { docsPath }) {
        super([
          `Type "${type}" is not a valid decoding type.`,
          "Please provide a valid ABI type."
        ].join("\n"), { docsPath });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidAbiDecodingType"
        });
      }
    };
    exports.InvalidAbiDecodingTypeError = InvalidAbiDecodingTypeError;
    var InvalidArrayError = class extends base_js_1.BaseError {
      constructor(value) {
        super([`Value "${value}" is not a valid array.`].join("\n"));
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidArrayError"
        });
      }
    };
    exports.InvalidArrayError = InvalidArrayError;
    var InvalidDefinitionTypeError = class extends base_js_1.BaseError {
      constructor(type) {
        super([
          `"${type}" is not a valid definition type.`,
          'Valid types: "function", "event", "error"'
        ].join("\n"));
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidDefinitionTypeError"
        });
      }
    };
    exports.InvalidDefinitionTypeError = InvalidDefinitionTypeError;
    var UnsupportedPackedAbiType = class extends base_js_1.BaseError {
      constructor(type) {
        super(`Type "${type}" is not supported for packed encoding.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "UnsupportedPackedAbiType"
        });
      }
    };
    exports.UnsupportedPackedAbiType = UnsupportedPackedAbiType;
  }
});

// node_modules/viem/_cjs/errors/log.js
var require_log2 = __commonJS({
  "node_modules/viem/_cjs/errors/log.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FilterTypeNotSupportedError = void 0;
    var base_js_1 = require_base();
    var FilterTypeNotSupportedError = class extends base_js_1.BaseError {
      constructor(type) {
        super(`Filter type "${type}" is not supported.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "FilterTypeNotSupportedError"
        });
      }
    };
    exports.FilterTypeNotSupportedError = FilterTypeNotSupportedError;
  }
});

// node_modules/viem/_cjs/utils/contract/extractFunctionParts.js
var require_extractFunctionParts = __commonJS({
  "node_modules/viem/_cjs/utils/contract/extractFunctionParts.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extractFunctionType = exports.extractFunctionParams = exports.extractFunctionName = exports.extractFunctionParts = void 0;
    var paramsRegex = /((function|event)\s)?(.*)(\((.*)\))/;
    function extractFunctionParts(def) {
      const parts = def.match(paramsRegex);
      const type = parts?.[2] || void 0;
      const name = parts?.[3];
      const params = parts?.[5] || void 0;
      return { type, name, params };
    }
    exports.extractFunctionParts = extractFunctionParts;
    function extractFunctionName(def) {
      return extractFunctionParts(def).name;
    }
    exports.extractFunctionName = extractFunctionName;
    function extractFunctionParams(def) {
      const params = extractFunctionParts(def).params;
      const splitParams = params?.split(",").map((x) => x.trim().split(" "));
      return splitParams?.map((param) => ({
        type: param[0],
        name: param[1] === "indexed" ? param[2] : param[1],
        ...param[1] === "indexed" ? { indexed: true } : {}
      }));
    }
    exports.extractFunctionParams = extractFunctionParams;
    function extractFunctionType(def) {
      return extractFunctionParts(def).type;
    }
    exports.extractFunctionType = extractFunctionType;
  }
});

// node_modules/@noble/hashes/_assert.js
var require_assert = __commonJS({
  "node_modules/@noble/hashes/_assert.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;
    function number(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`Wrong positive integer: ${n}`);
    }
    exports.number = number;
    function bool(b) {
      if (typeof b !== "boolean")
        throw new Error(`Expected boolean, not ${b}`);
    }
    exports.bool = bool;
    function bytes(b, ...lengths) {
      if (!(b instanceof Uint8Array))
        throw new Error("Expected Uint8Array");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
    }
    exports.bytes = bytes;
    function hash(hash2) {
      if (typeof hash2 !== "function" || typeof hash2.create !== "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      number(hash2.outputLen);
      number(hash2.blockLen);
    }
    exports.hash = hash;
    function exists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    exports.exists = exists;
    function output(out, instance) {
      bytes(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
      }
    }
    exports.output = output;
    var assert = { number, bool, bytes, hash, exists, output };
    exports.default = assert;
  }
});

// node_modules/@noble/hashes/_u64.js
var require_u64 = __commonJS({
  "node_modules/@noble/hashes/_u64.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.add5L = exports.add5H = exports.add4H = exports.add4L = exports.add3H = exports.add3L = exports.add = exports.rotlBL = exports.rotlBH = exports.rotlSL = exports.rotlSH = exports.rotr32L = exports.rotr32H = exports.rotrBL = exports.rotrBH = exports.rotrSL = exports.rotrSH = exports.shrSL = exports.shrSH = exports.toBig = exports.split = exports.fromBig = void 0;
    var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
    var _32n = /* @__PURE__ */ BigInt(32);
    function fromBig(n, le = false) {
      if (le)
        return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
      return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
    }
    exports.fromBig = fromBig;
    function split(lst, le = false) {
      let Ah = new Uint32Array(lst.length);
      let Al = new Uint32Array(lst.length);
      for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
      }
      return [Ah, Al];
    }
    exports.split = split;
    var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
    exports.toBig = toBig;
    var shrSH = (h, _l, s) => h >>> s;
    exports.shrSH = shrSH;
    var shrSL = (h, l, s) => h << 32 - s | l >>> s;
    exports.shrSL = shrSL;
    var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
    exports.rotrSH = rotrSH;
    var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
    exports.rotrSL = rotrSL;
    var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
    exports.rotrBH = rotrBH;
    var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
    exports.rotrBL = rotrBL;
    var rotr32H = (_h, l) => l;
    exports.rotr32H = rotr32H;
    var rotr32L = (h, _l) => h;
    exports.rotr32L = rotr32L;
    var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
    exports.rotlSH = rotlSH;
    var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
    exports.rotlSL = rotlSL;
    var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
    exports.rotlBH = rotlBH;
    var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
    exports.rotlBL = rotlBL;
    function add(Ah, Al, Bh, Bl) {
      const l = (Al >>> 0) + (Bl >>> 0);
      return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
    }
    exports.add = add;
    var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
    exports.add3L = add3L;
    var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
    exports.add3H = add3H;
    var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    exports.add4L = add4L;
    var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
    exports.add4H = add4H;
    var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    exports.add5L = add5L;
    var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
    exports.add5H = add5H;
    var u64 = {
      fromBig,
      split,
      toBig,
      shrSH,
      shrSL,
      rotrSH,
      rotrSL,
      rotrBH,
      rotrBL,
      rotr32H,
      rotr32L,
      rotlSH,
      rotlSL,
      rotlBH,
      rotlBL,
      add,
      add3L,
      add3H,
      add4L,
      add4H,
      add5H,
      add5L
    };
    exports.default = u64;
  }
});

// node_modules/@noble/hashes/crypto.js
var require_crypto = __commonJS({
  "node_modules/@noble/hashes/crypto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = void 0;
    exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// node_modules/@noble/hashes/utils.js
var require_utils5 = __commonJS({
  "node_modules/@noble/hashes/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
    var crypto_1 = require_crypto();
    var u8a = (a) => a instanceof Uint8Array;
    var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.u8 = u8;
    var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    exports.u32 = u32;
    var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.createView = createView;
    var rotr = (word, shift) => word << 32 - shift | word >>> shift;
    exports.rotr = rotr;
    exports.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    if (!exports.isLE)
      throw new Error("Non little-endian hardware is not supported");
    var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      if (!u8a(bytes))
        throw new Error("Uint8Array expected");
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    exports.bytesToHex = bytesToHex;
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const len = hex.length;
      if (len % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + len);
      const array = new Uint8Array(len / 2);
      for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
          throw new Error("Invalid byte sequence");
        array[i] = byte;
      }
      return array;
    }
    exports.hexToBytes = hexToBytes;
    var nextTick = async () => {
    };
    exports.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i = 0; i < iters; i++) {
        cb(i);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports.nextTick)();
        ts += diff;
      }
    }
    exports.asyncLoop = asyncLoop;
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    exports.utf8ToBytes = utf8ToBytes;
    function toBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      if (!u8a(data))
        throw new Error(`expected Uint8Array, got ${typeof data}`);
      return data;
    }
    exports.toBytes = toBytes;
    function concatBytes(...arrays) {
      const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
      let pad = 0;
      arrays.forEach((a) => {
        if (!u8a(a))
          throw new Error("Uint8Array expected");
        r.set(a, pad);
        pad += a.length;
      });
      return r;
    }
    exports.concatBytes = concatBytes;
    var Hash = class {
      // Safe version that clones internal state
      clone() {
        return this._cloneInto();
      }
    };
    exports.Hash = Hash;
    var toStr = {}.toString;
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
        throw new Error("Options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    exports.checkOpts = checkOpts;
    function wrapConstructor(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    exports.wrapConstructor = wrapConstructor;
    function wrapConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
    function wrapXOFConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
    function randomBytes(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
    exports.randomBytes = randomBytes;
  }
});

// node_modules/@noble/hashes/sha3.js
var require_sha3 = __commonJS({
  "node_modules/@noble/hashes/sha3.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = void 0;
    var _assert_js_1 = require_assert();
    var _u64_js_1 = require_u64();
    var utils_js_1 = require_utils5();
    var [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
    var _0n = /* @__PURE__ */ BigInt(0);
    var _1n = /* @__PURE__ */ BigInt(1);
    var _2n = /* @__PURE__ */ BigInt(2);
    var _7n = /* @__PURE__ */ BigInt(7);
    var _256n = /* @__PURE__ */ BigInt(256);
    var _0x71n = /* @__PURE__ */ BigInt(113);
    for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
      [x, y] = [y, (2 * x + 3 * y) % 5];
      SHA3_PI.push(2 * (5 * y + x));
      SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
      let t = _0n;
      for (let j = 0; j < 7; j++) {
        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
        if (R & _2n)
          t ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;
      }
      _SHA3_IOTA.push(t);
    }
    var [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ (0, _u64_js_1.split)(_SHA3_IOTA, true);
    var rotlH = (h, l, s) => s > 32 ? (0, _u64_js_1.rotlBH)(h, l, s) : (0, _u64_js_1.rotlSH)(h, l, s);
    var rotlL = (h, l, s) => s > 32 ? (0, _u64_js_1.rotlBL)(h, l, s) : (0, _u64_js_1.rotlSL)(h, l, s);
    function keccakP(s, rounds = 24) {
      const B = new Uint32Array(5 * 2);
      for (let round = 24 - rounds; round < 24; round++) {
        for (let x = 0; x < 10; x++)
          B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
          const idx1 = (x + 8) % 10;
          const idx0 = (x + 2) % 10;
          const B0 = B[idx0];
          const B1 = B[idx0 + 1];
          const Th = rotlH(B0, B1, 1) ^ B[idx1];
          const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
          for (let y = 0; y < 50; y += 10) {
            s[x + y] ^= Th;
            s[x + y + 1] ^= Tl;
          }
        }
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
          const shift = SHA3_ROTL[t];
          const Th = rotlH(curH, curL, shift);
          const Tl = rotlL(curH, curL, shift);
          const PI = SHA3_PI[t];
          curH = s[PI];
          curL = s[PI + 1];
          s[PI] = Th;
          s[PI + 1] = Tl;
        }
        for (let y = 0; y < 50; y += 10) {
          for (let x = 0; x < 10; x++)
            B[x] = s[y + x];
          for (let x = 0; x < 10; x++)
            s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
      }
      B.fill(0);
    }
    exports.keccakP = keccakP;
    var Keccak = class extends utils_js_1.Hash {
      // NOTE: we accept arguments in bytes instead of bits here.
      constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        (0, _assert_js_1.number)(outputLen);
        if (0 >= this.blockLen || this.blockLen >= 200)
          throw new Error("Sha3 supports only keccak-f1600 function");
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_js_1.u32)(this.state);
      }
      keccak() {
        keccakP(this.state32, this.rounds);
        this.posOut = 0;
        this.pos = 0;
      }
      update(data) {
        (0, _assert_js_1.exists)(this);
        const { blockLen, state } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          for (let i = 0; i < take; i++)
            state[this.pos++] ^= data[pos++];
          if (this.pos === blockLen)
            this.keccak();
        }
        return this;
      }
      finish() {
        if (this.finished)
          return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        state[pos] ^= suffix;
        if ((suffix & 128) !== 0 && pos === blockLen - 1)
          this.keccak();
        state[blockLen - 1] ^= 128;
        this.keccak();
      }
      writeInto(out) {
        (0, _assert_js_1.exists)(this, false);
        (0, _assert_js_1.bytes)(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len; ) {
          if (this.posOut >= blockLen)
            this.keccak();
          const take = Math.min(blockLen - this.posOut, len - pos);
          out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
          this.posOut += take;
          pos += take;
        }
        return out;
      }
      xofInto(out) {
        if (!this.enableXOF)
          throw new Error("XOF is not possible for this instance");
        return this.writeInto(out);
      }
      xof(bytes) {
        (0, _assert_js_1.number)(bytes);
        return this.xofInto(new Uint8Array(bytes));
      }
      digestInto(out) {
        (0, _assert_js_1.output)(out, this);
        if (this.finished)
          throw new Error("digest() was already called");
        this.writeInto(out);
        this.destroy();
        return out;
      }
      digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
      }
      destroy() {
        this.destroyed = true;
        this.state.fill(0);
      }
      _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
      }
    };
    exports.Keccak = Keccak;
    var gen = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
    exports.sha3_224 = gen(6, 144, 224 / 8);
    exports.sha3_256 = gen(6, 136, 256 / 8);
    exports.sha3_384 = gen(6, 104, 384 / 8);
    exports.sha3_512 = gen(6, 72, 512 / 8);
    exports.keccak_224 = gen(1, 144, 224 / 8);
    exports.keccak_256 = gen(1, 136, 256 / 8);
    exports.keccak_384 = gen(1, 104, 384 / 8);
    exports.keccak_512 = gen(1, 72, 512 / 8);
    var genShake = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
    exports.shake128 = genShake(31, 168, 128 / 8);
    exports.shake256 = genShake(31, 136, 256 / 8);
  }
});

// node_modules/viem/_cjs/utils/hash/keccak256.js
var require_keccak256 = __commonJS({
  "node_modules/viem/_cjs/utils/hash/keccak256.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.keccak256 = void 0;
    var sha3_1 = require_sha3();
    var isHex_js_1 = require_isHex();
    var toBytes_js_1 = require_toBytes();
    var toHex_js_1 = require_toHex();
    function keccak256(value, to_) {
      const to = to_ || "hex";
      const bytes = (0, sha3_1.keccak_256)((0, isHex_js_1.isHex)(value, { strict: false }) ? (0, toBytes_js_1.toBytes)(value) : value);
      if (to === "bytes")
        return bytes;
      return (0, toHex_js_1.toHex)(bytes);
    }
    exports.keccak256 = keccak256;
  }
});

// node_modules/viem/_cjs/utils/hash/hashFunction.js
var require_hashFunction = __commonJS({
  "node_modules/viem/_cjs/utils/hash/hashFunction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashAbiItem = exports.hashFunction = void 0;
    var formatAbiItem_js_1 = require_formatAbiItem2();
    var extractFunctionParts_js_1 = require_extractFunctionParts();
    var toBytes_js_1 = require_toBytes();
    var keccak256_js_1 = require_keccak256();
    var hash = (value) => (0, keccak256_js_1.keccak256)((0, toBytes_js_1.toBytes)(value));
    function hashFunction(def) {
      const name = (0, extractFunctionParts_js_1.extractFunctionName)(def);
      const params = (0, extractFunctionParts_js_1.extractFunctionParams)(def) || [];
      return hash(`${name}(${params.map(({ type }) => type).join(",")})`);
    }
    exports.hashFunction = hashFunction;
    function hashAbiItem(abiItem) {
      return hash((0, formatAbiItem_js_1.formatAbiItem)(abiItem));
    }
    exports.hashAbiItem = hashAbiItem;
  }
});

// node_modules/viem/_cjs/utils/hash/getEventSelector.js
var require_getEventSelector = __commonJS({
  "node_modules/viem/_cjs/utils/hash/getEventSelector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEventSelector = void 0;
    var hashFunction_js_1 = require_hashFunction();
    var getEventSelector = (event) => {
      if (typeof event === "string")
        return (0, hashFunction_js_1.hashFunction)(event);
      return (0, hashFunction_js_1.hashAbiItem)(event);
    };
    exports.getEventSelector = getEventSelector;
  }
});

// node_modules/viem/_cjs/utils/data/slice.js
var require_slice = __commonJS({
  "node_modules/viem/_cjs/utils/data/slice.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sliceHex = exports.sliceBytes = exports.slice = void 0;
    var data_js_1 = require_data();
    var isHex_js_1 = require_isHex();
    var size_js_1 = require_size();
    function slice(value, start, end, { strict } = {}) {
      if ((0, isHex_js_1.isHex)(value, { strict: false }))
        return sliceHex(value, start, end, {
          strict
        });
      return sliceBytes(value, start, end, {
        strict
      });
    }
    exports.slice = slice;
    function assertStartOffset(value, start) {
      if (typeof start === "number" && start > 0 && start > (0, size_js_1.size)(value) - 1)
        throw new data_js_1.SliceOffsetOutOfBoundsError({
          offset: start,
          position: "start",
          size: (0, size_js_1.size)(value)
        });
    }
    function assertEndOffset(value, start, end) {
      if (typeof start === "number" && typeof end === "number" && (0, size_js_1.size)(value) !== end - start) {
        throw new data_js_1.SliceOffsetOutOfBoundsError({
          offset: end,
          position: "end",
          size: (0, size_js_1.size)(value)
        });
      }
    }
    function sliceBytes(value_, start, end, { strict } = {}) {
      assertStartOffset(value_, start);
      const value = value_.slice(start, end);
      if (strict)
        assertEndOffset(value, start, end);
      return value;
    }
    exports.sliceBytes = sliceBytes;
    function sliceHex(value_, start, end, { strict } = {}) {
      assertStartOffset(value_, start);
      const value = `0x${value_.replace("0x", "").slice((start ?? 0) * 2, (end ?? value_.length) * 2)}`;
      if (strict)
        assertEndOffset(value, start, end);
      return value;
    }
    exports.sliceHex = sliceHex;
  }
});

// node_modules/viem/_cjs/utils/abi/encodeAbiParameters.js
var require_encodeAbiParameters = __commonJS({
  "node_modules/viem/_cjs/utils/abi/encodeAbiParameters.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getArrayComponents = exports.encodeAbiParameters = void 0;
    var abi_js_1 = require_abi();
    var address_js_1 = require_address();
    var isAddress_js_1 = require_isAddress();
    var concat_js_1 = require_concat();
    var pad_js_1 = require_pad();
    var size_js_1 = require_size();
    var slice_js_1 = require_slice();
    var toHex_js_1 = require_toHex();
    function encodeAbiParameters(params, values) {
      if (params.length !== values.length)
        throw new abi_js_1.AbiEncodingLengthMismatchError({
          expectedLength: params.length,
          givenLength: values.length
        });
      const preparedParams = prepareParams({
        params,
        values
      });
      const data = encodeParams(preparedParams);
      if (data.length === 0)
        return "0x";
      return data;
    }
    exports.encodeAbiParameters = encodeAbiParameters;
    function prepareParams({ params, values }) {
      const preparedParams = [];
      for (let i = 0; i < params.length; i++) {
        preparedParams.push(prepareParam({ param: params[i], value: values[i] }));
      }
      return preparedParams;
    }
    function prepareParam({ param, value }) {
      const arrayComponents = getArrayComponents(param.type);
      if (arrayComponents) {
        const [length, type] = arrayComponents;
        return encodeArray(value, { length, param: { ...param, type } });
      }
      if (param.type === "tuple") {
        return encodeTuple(value, {
          param
        });
      }
      if (param.type === "address") {
        return encodeAddress(value);
      }
      if (param.type === "bool") {
        return encodeBool(value);
      }
      if (param.type.startsWith("uint") || param.type.startsWith("int")) {
        const signed = param.type.startsWith("int");
        return encodeNumber(value, { signed });
      }
      if (param.type.startsWith("bytes")) {
        return encodeBytes(value, { param });
      }
      if (param.type === "string") {
        return encodeString(value);
      }
      throw new abi_js_1.InvalidAbiEncodingTypeError(param.type, {
        docsPath: "/docs/contract/encodeAbiParameters"
      });
    }
    function encodeParams(preparedParams) {
      let staticSize = 0;
      for (let i = 0; i < preparedParams.length; i++) {
        const { dynamic, encoded } = preparedParams[i];
        if (dynamic)
          staticSize += 32;
        else
          staticSize += (0, size_js_1.size)(encoded);
      }
      const staticParams = [];
      const dynamicParams = [];
      let dynamicSize = 0;
      for (let i = 0; i < preparedParams.length; i++) {
        const { dynamic, encoded } = preparedParams[i];
        if (dynamic) {
          staticParams.push((0, toHex_js_1.numberToHex)(staticSize + dynamicSize, { size: 32 }));
          dynamicParams.push(encoded);
          dynamicSize += (0, size_js_1.size)(encoded);
        } else {
          staticParams.push(encoded);
        }
      }
      return (0, concat_js_1.concat)([...staticParams, ...dynamicParams]);
    }
    function encodeAddress(value) {
      if (!(0, isAddress_js_1.isAddress)(value))
        throw new address_js_1.InvalidAddressError({ address: value });
      return { dynamic: false, encoded: (0, pad_js_1.padHex)(value.toLowerCase()) };
    }
    function encodeArray(value, { length, param }) {
      const dynamic = length === null;
      if (!Array.isArray(value))
        throw new abi_js_1.InvalidArrayError(value);
      if (!dynamic && value.length !== length)
        throw new abi_js_1.AbiEncodingArrayLengthMismatchError({
          expectedLength: length,
          givenLength: value.length,
          type: `${param.type}[${length}]`
        });
      let dynamicChild = false;
      const preparedParams = [];
      for (let i = 0; i < value.length; i++) {
        const preparedParam = prepareParam({ param, value: value[i] });
        if (preparedParam.dynamic)
          dynamicChild = true;
        preparedParams.push(preparedParam);
      }
      if (dynamic || dynamicChild) {
        const data = encodeParams(preparedParams);
        if (dynamic) {
          const length2 = (0, toHex_js_1.numberToHex)(preparedParams.length, { size: 32 });
          return {
            dynamic: true,
            encoded: preparedParams.length > 0 ? (0, concat_js_1.concat)([length2, data]) : length2
          };
        }
        if (dynamicChild)
          return { dynamic: true, encoded: data };
      }
      return {
        dynamic: false,
        encoded: (0, concat_js_1.concat)(preparedParams.map(({ encoded }) => encoded))
      };
    }
    function encodeBytes(value, { param }) {
      const [, paramSize] = param.type.split("bytes");
      const bytesSize = (0, size_js_1.size)(value);
      if (!paramSize) {
        let value_ = value;
        if (bytesSize % 32 !== 0)
          value_ = (0, pad_js_1.padHex)(value_, {
            dir: "right",
            size: Math.ceil((value.length - 2) / 2 / 32) * 32
          });
        return {
          dynamic: true,
          encoded: (0, concat_js_1.concat)([(0, pad_js_1.padHex)((0, toHex_js_1.numberToHex)(bytesSize, { size: 32 })), value_])
        };
      }
      if (bytesSize !== parseInt(paramSize))
        throw new abi_js_1.AbiEncodingBytesSizeMismatchError({
          expectedSize: parseInt(paramSize),
          value
        });
      return { dynamic: false, encoded: (0, pad_js_1.padHex)(value, { dir: "right" }) };
    }
    function encodeBool(value) {
      return { dynamic: false, encoded: (0, pad_js_1.padHex)((0, toHex_js_1.boolToHex)(value)) };
    }
    function encodeNumber(value, { signed }) {
      return {
        dynamic: false,
        encoded: (0, toHex_js_1.numberToHex)(value, {
          size: 32,
          signed
        })
      };
    }
    function encodeString(value) {
      const hexValue = (0, toHex_js_1.stringToHex)(value);
      const partsLength = Math.ceil((0, size_js_1.size)(hexValue) / 32);
      const parts = [];
      for (let i = 0; i < partsLength; i++) {
        parts.push((0, pad_js_1.padHex)((0, slice_js_1.slice)(hexValue, i * 32, (i + 1) * 32), {
          dir: "right"
        }));
      }
      return {
        dynamic: true,
        encoded: (0, concat_js_1.concat)([
          (0, pad_js_1.padHex)((0, toHex_js_1.numberToHex)((0, size_js_1.size)(hexValue), { size: 32 })),
          ...parts
        ])
      };
    }
    function encodeTuple(value, { param }) {
      let dynamic = false;
      const preparedParams = [];
      for (let i = 0; i < param.components.length; i++) {
        const param_ = param.components[i];
        const index = Array.isArray(value) ? i : param_.name;
        const preparedParam = prepareParam({
          param: param_,
          value: value[index]
        });
        preparedParams.push(preparedParam);
        if (preparedParam.dynamic)
          dynamic = true;
      }
      return {
        dynamic,
        encoded: dynamic ? encodeParams(preparedParams) : (0, concat_js_1.concat)(preparedParams.map(({ encoded }) => encoded))
      };
    }
    function getArrayComponents(type) {
      const matches = type.match(/^(.*)\[(\d+)?\]$/);
      return matches ? [matches[2] ? Number(matches[2]) : null, matches[1]] : void 0;
    }
    exports.getArrayComponents = getArrayComponents;
  }
});

// node_modules/viem/_cjs/utils/hash/getFunctionSelector.js
var require_getFunctionSelector = __commonJS({
  "node_modules/viem/_cjs/utils/hash/getFunctionSelector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFunctionSelector = void 0;
    var slice_js_1 = require_slice();
    var hashFunction_js_1 = require_hashFunction();
    var getFunctionSelector = (fn) => {
      if (typeof fn === "string")
        return (0, slice_js_1.slice)((0, hashFunction_js_1.hashFunction)(fn), 0, 4);
      return (0, slice_js_1.slice)((0, hashFunction_js_1.hashAbiItem)(fn), 0, 4);
    };
    exports.getFunctionSelector = getFunctionSelector;
  }
});

// node_modules/viem/_cjs/utils/abi/getAbiItem.js
var require_getAbiItem = __commonJS({
  "node_modules/viem/_cjs/utils/abi/getAbiItem.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isArgOfType = exports.getAbiItem = void 0;
    var isHex_js_1 = require_isHex();
    var getEventSelector_js_1 = require_getEventSelector();
    var getFunctionSelector_js_1 = require_getFunctionSelector();
    var isAddress_js_1 = require_isAddress();
    function getAbiItem({ abi, args = [], name }) {
      const isSelector = (0, isHex_js_1.isHex)(name, { strict: false });
      const abiItems = abi.filter((abiItem) => {
        if (isSelector) {
          if (abiItem.type === "function")
            return (0, getFunctionSelector_js_1.getFunctionSelector)(abiItem) === name;
          if (abiItem.type === "event")
            return (0, getEventSelector_js_1.getEventSelector)(abiItem) === name;
          return false;
        }
        return "name" in abiItem && abiItem.name === name;
      });
      if (abiItems.length === 0)
        return void 0;
      if (abiItems.length === 1)
        return abiItems[0];
      for (const abiItem of abiItems) {
        if (!("inputs" in abiItem))
          continue;
        if (!args || args.length === 0) {
          if (!abiItem.inputs || abiItem.inputs.length === 0)
            return abiItem;
          continue;
        }
        if (!abiItem.inputs)
          continue;
        if (abiItem.inputs.length === 0)
          continue;
        if (abiItem.inputs.length !== args.length)
          continue;
        const matched = args.every((arg, index) => {
          const abiParameter = "inputs" in abiItem && abiItem.inputs[index];
          if (!abiParameter)
            return false;
          return isArgOfType(arg, abiParameter);
        });
        if (matched)
          return abiItem;
      }
      return abiItems[0];
    }
    exports.getAbiItem = getAbiItem;
    function isArgOfType(arg, abiParameter) {
      const argType = typeof arg;
      const abiParameterType = abiParameter.type;
      switch (abiParameterType) {
        case "address":
          return (0, isAddress_js_1.isAddress)(arg);
        case "bool":
          return argType === "boolean";
        case "function":
          return argType === "string";
        case "string":
          return argType === "string";
        default: {
          if (abiParameterType === "tuple" && "components" in abiParameter)
            return Object.values(abiParameter.components).every((component, index) => {
              return isArgOfType(Object.values(arg)[index], component);
            });
          if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))
            return argType === "number" || argType === "bigint";
          if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))
            return argType === "string" || arg instanceof Uint8Array;
          if (/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(abiParameterType)) {
            return Array.isArray(arg) && arg.every((x) => isArgOfType(x, {
              ...abiParameter,
              type: abiParameterType.replace(/(\[[0-9]{0,}\])$/, "")
            }));
          }
          return false;
        }
      }
    }
    exports.isArgOfType = isArgOfType;
  }
});

// node_modules/viem/_cjs/utils/abi/encodeEventTopics.js
var require_encodeEventTopics = __commonJS({
  "node_modules/viem/_cjs/utils/abi/encodeEventTopics.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeEventTopics = void 0;
    var abi_js_1 = require_abi();
    var log_js_1 = require_log2();
    var toBytes_js_1 = require_toBytes();
    var getEventSelector_js_1 = require_getEventSelector();
    var keccak256_js_1 = require_keccak256();
    var encodeAbiParameters_js_1 = require_encodeAbiParameters();
    var formatAbiItem_js_1 = require_formatAbiItem2();
    var getAbiItem_js_1 = require_getAbiItem();
    function encodeEventTopics({ abi, eventName, args }) {
      let abiItem = abi[0];
      if (eventName) {
        abiItem = (0, getAbiItem_js_1.getAbiItem)({
          abi,
          args,
          name: eventName
        });
        if (!abiItem)
          throw new abi_js_1.AbiEventNotFoundError(eventName, {
            docsPath: "/docs/contract/encodeEventTopics"
          });
      }
      if (abiItem.type !== "event")
        throw new abi_js_1.AbiEventNotFoundError(void 0, {
          docsPath: "/docs/contract/encodeEventTopics"
        });
      const definition = (0, formatAbiItem_js_1.formatAbiItem)(abiItem);
      const signature = (0, getEventSelector_js_1.getEventSelector)(definition);
      let topics = [];
      if (args && "inputs" in abiItem) {
        const indexedInputs = abiItem.inputs?.filter((param) => "indexed" in param && param.indexed);
        const args_ = Array.isArray(args) ? args : Object.values(args).length > 0 ? indexedInputs?.map((x) => args[x.name]) ?? [] : [];
        if (args_.length > 0) {
          topics = indexedInputs?.map((param, i) => Array.isArray(args_[i]) ? args_[i].map((_, j) => encodeArg({ param, value: args_[i][j] })) : args_[i] ? encodeArg({ param, value: args_[i] }) : null) ?? [];
        }
      }
      return [signature, ...topics];
    }
    exports.encodeEventTopics = encodeEventTopics;
    function encodeArg({ param, value }) {
      if (param.type === "string" || param.type === "bytes")
        return (0, keccak256_js_1.keccak256)((0, toBytes_js_1.toBytes)(value));
      if (param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
        throw new log_js_1.FilterTypeNotSupportedError(param.type);
      return (0, encodeAbiParameters_js_1.encodeAbiParameters)([param], [value]);
    }
  }
});

// node_modules/viem/_cjs/utils/filters/createFilterRequestScope.js
var require_createFilterRequestScope = __commonJS({
  "node_modules/viem/_cjs/utils/filters/createFilterRequestScope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createFilterRequestScope = void 0;
    function createFilterRequestScope(client, { method }) {
      const requestMap = {};
      if (client.transport.type === "fallback")
        client.transport.onResponse?.(({ method: method_, response: id, status, transport }) => {
          if (status === "success" && method === method_)
            requestMap[id] = transport.request;
        });
      return (id) => requestMap[id] || client.request;
    }
    exports.createFilterRequestScope = createFilterRequestScope;
  }
});

// node_modules/viem/_cjs/actions/public/createContractEventFilter.js
var require_createContractEventFilter = __commonJS({
  "node_modules/viem/_cjs/actions/public/createContractEventFilter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createContractEventFilter = void 0;
    var encodeEventTopics_js_1 = require_encodeEventTopics();
    var toHex_js_1 = require_toHex();
    var createFilterRequestScope_js_1 = require_createFilterRequestScope();
    async function createContractEventFilter(client, { address, abi, args, eventName, fromBlock, strict, toBlock }) {
      const getRequest = (0, createFilterRequestScope_js_1.createFilterRequestScope)(client, {
        method: "eth_newFilter"
      });
      const topics = eventName ? (0, encodeEventTopics_js_1.encodeEventTopics)({
        abi,
        args,
        eventName
      }) : void 0;
      const id = await client.request({
        method: "eth_newFilter",
        params: [
          {
            address,
            fromBlock: typeof fromBlock === "bigint" ? (0, toHex_js_1.numberToHex)(fromBlock) : fromBlock,
            toBlock: typeof toBlock === "bigint" ? (0, toHex_js_1.numberToHex)(toBlock) : toBlock,
            topics
          }
        ]
      });
      return {
        abi,
        args,
        eventName,
        id,
        request: getRequest(id),
        strict,
        type: "event"
      };
    }
    exports.createContractEventFilter = createContractEventFilter;
  }
});

// node_modules/viem/_cjs/accounts/utils/parseAccount.js
var require_parseAccount = __commonJS({
  "node_modules/viem/_cjs/accounts/utils/parseAccount.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseAccount = void 0;
    function parseAccount(account) {
      if (typeof account === "string")
        return { address: account, type: "json-rpc" };
      return account;
    }
    exports.parseAccount = parseAccount;
  }
});

// node_modules/viem/_cjs/utils/abi/encodeFunctionData.js
var require_encodeFunctionData = __commonJS({
  "node_modules/viem/_cjs/utils/abi/encodeFunctionData.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeFunctionData = void 0;
    var abi_js_1 = require_abi();
    var concat_js_1 = require_concat();
    var getFunctionSelector_js_1 = require_getFunctionSelector();
    var encodeAbiParameters_js_1 = require_encodeAbiParameters();
    var formatAbiItem_js_1 = require_formatAbiItem2();
    var getAbiItem_js_1 = require_getAbiItem();
    function encodeFunctionData({ abi, args, functionName }) {
      let abiItem = abi[0];
      if (functionName) {
        abiItem = (0, getAbiItem_js_1.getAbiItem)({
          abi,
          args,
          name: functionName
        });
        if (!abiItem)
          throw new abi_js_1.AbiFunctionNotFoundError(functionName, {
            docsPath: "/docs/contract/encodeFunctionData"
          });
      }
      if (abiItem.type !== "function")
        throw new abi_js_1.AbiFunctionNotFoundError(void 0, {
          docsPath: "/docs/contract/encodeFunctionData"
        });
      const definition = (0, formatAbiItem_js_1.formatAbiItem)(abiItem);
      const signature = (0, getFunctionSelector_js_1.getFunctionSelector)(definition);
      const data = "inputs" in abiItem && abiItem.inputs ? (0, encodeAbiParameters_js_1.encodeAbiParameters)(abiItem.inputs, args ?? []) : void 0;
      return (0, concat_js_1.concatHex)([signature, data ?? "0x"]);
    }
    exports.encodeFunctionData = encodeFunctionData;
  }
});

// node_modules/viem/_cjs/constants/solidity.js
var require_solidity = __commonJS({
  "node_modules/viem/_cjs/constants/solidity.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.solidityPanic = exports.solidityError = exports.panicReasons = void 0;
    exports.panicReasons = {
      1: "An `assert` condition failed.",
      17: "Arithmic operation resulted in underflow or overflow.",
      18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
      33: "Attempted to convert to an invalid type.",
      34: "Attempted to access a storage byte array that is incorrectly encoded.",
      49: "Performed `.pop()` on an empty array",
      50: "Array index is out of bounds.",
      65: "Allocated too much memory or created an array which is too large.",
      81: "Attempted to call a zero-initialized variable of internal function type."
    };
    exports.solidityError = {
      inputs: [
        {
          name: "message",
          type: "string"
        }
      ],
      name: "Error",
      type: "error"
    };
    exports.solidityPanic = {
      inputs: [
        {
          name: "reason",
          type: "uint256"
        }
      ],
      name: "Panic",
      type: "error"
    };
  }
});

// node_modules/viem/_cjs/utils/address/getAddress.js
var require_getAddress = __commonJS({
  "node_modules/viem/_cjs/utils/address/getAddress.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getAddress = exports.checksumAddress = void 0;
    var address_js_1 = require_address();
    var toBytes_js_1 = require_toBytes();
    var keccak256_js_1 = require_keccak256();
    var isAddress_js_1 = require_isAddress();
    function checksumAddress(address_, chainId) {
      const hexAddress = chainId ? `${chainId}${address_.toLowerCase()}` : address_.substring(2).toLowerCase();
      const hash = (0, keccak256_js_1.keccak256)((0, toBytes_js_1.stringToBytes)(hexAddress), "bytes");
      const address = (chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress).split("");
      for (let i = 0; i < 40; i += 2) {
        if (hash[i >> 1] >> 4 >= 8 && address[i]) {
          address[i] = address[i].toUpperCase();
        }
        if ((hash[i >> 1] & 15) >= 8 && address[i + 1]) {
          address[i + 1] = address[i + 1].toUpperCase();
        }
      }
      return `0x${address.join("")}`;
    }
    exports.checksumAddress = checksumAddress;
    function getAddress(address, chainId) {
      if (!(0, isAddress_js_1.isAddress)(address))
        throw new address_js_1.InvalidAddressError({ address });
      return checksumAddress(address, chainId);
    }
    exports.getAddress = getAddress;
  }
});

// node_modules/viem/_cjs/utils/abi/decodeAbiParameters.js
var require_decodeAbiParameters = __commonJS({
  "node_modules/viem/_cjs/utils/abi/decodeAbiParameters.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeAbiParameters = void 0;
    var abi_js_1 = require_abi();
    var getAddress_js_1 = require_getAddress();
    var size_js_1 = require_size();
    var slice_js_1 = require_slice();
    var trim_js_1 = require_trim();
    var fromHex_js_1 = require_fromHex();
    var encodeAbiParameters_js_1 = require_encodeAbiParameters();
    function decodeAbiParameters(params, data) {
      if (data === "0x" && params.length > 0)
        throw new abi_js_1.AbiDecodingZeroDataError();
      if ((0, size_js_1.size)(data) && (0, size_js_1.size)(data) < 32)
        throw new abi_js_1.AbiDecodingDataSizeTooSmallError({
          data,
          params,
          size: (0, size_js_1.size)(data)
        });
      return decodeParams({
        data,
        params
      });
    }
    exports.decodeAbiParameters = decodeAbiParameters;
    function decodeParams({ data, params }) {
      const decodedValues = [];
      let position = 0;
      for (let i = 0; i < params.length; i++) {
        if (position >= (0, size_js_1.size)(data))
          throw new abi_js_1.AbiDecodingDataSizeTooSmallError({
            data,
            params,
            size: (0, size_js_1.size)(data)
          });
        const param = params[i];
        const { consumed, value } = decodeParam({ data, param, position });
        decodedValues.push(value);
        position += consumed;
      }
      return decodedValues;
    }
    function decodeParam({ data, param, position }) {
      const arrayComponents = (0, encodeAbiParameters_js_1.getArrayComponents)(param.type);
      if (arrayComponents) {
        const [length, type] = arrayComponents;
        return decodeArray(data, {
          length,
          param: { ...param, type },
          position
        });
      }
      if (param.type === "tuple") {
        return decodeTuple(data, { param, position });
      }
      if (param.type === "string") {
        return decodeString(data, { position });
      }
      if (param.type.startsWith("bytes")) {
        return decodeBytes(data, { param, position });
      }
      const value = (0, slice_js_1.slice)(data, position, position + 32, { strict: true });
      if (param.type.startsWith("uint") || param.type.startsWith("int")) {
        return decodeNumber(value, { param });
      }
      if (param.type === "address") {
        return decodeAddress(value);
      }
      if (param.type === "bool") {
        return decodeBool(value);
      }
      throw new abi_js_1.InvalidAbiDecodingTypeError(param.type, {
        docsPath: "/docs/contract/decodeAbiParameters"
      });
    }
    function decodeAddress(value) {
      return { consumed: 32, value: (0, getAddress_js_1.checksumAddress)((0, slice_js_1.slice)(value, -20)) };
    }
    function decodeArray(data, { param, length, position }) {
      if (!length) {
        const offset = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(data, position, position + 32, { strict: true }));
        const length2 = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(data, offset, offset + 32, { strict: true }));
        let consumed2 = 0;
        const value2 = [];
        for (let i = 0; i < length2; ++i) {
          const decodedChild = decodeParam({
            data: (0, slice_js_1.slice)(data, offset + 32),
            param,
            position: consumed2
          });
          consumed2 += decodedChild.consumed;
          value2.push(decodedChild.value);
        }
        return { value: value2, consumed: 32 };
      }
      if (hasDynamicChild(param)) {
        const arrayComponents = (0, encodeAbiParameters_js_1.getArrayComponents)(param.type);
        const dynamicChild = !arrayComponents?.[0];
        let consumed2 = 0;
        const value2 = [];
        for (let i = 0; i < length; ++i) {
          const offset = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(data, position, position + 32, { strict: true }));
          const decodedChild = decodeParam({
            data: (0, slice_js_1.slice)(data, offset),
            param,
            position: dynamicChild ? consumed2 : i * 32
          });
          consumed2 += decodedChild.consumed;
          value2.push(decodedChild.value);
        }
        return { value: value2, consumed: 32 };
      }
      let consumed = 0;
      const value = [];
      for (let i = 0; i < length; ++i) {
        const decodedChild = decodeParam({
          data,
          param,
          position: position + consumed
        });
        consumed += decodedChild.consumed;
        value.push(decodedChild.value);
      }
      return { value, consumed };
    }
    function decodeBool(value) {
      return { consumed: 32, value: (0, fromHex_js_1.hexToBool)(value) };
    }
    function decodeBytes(data, { param, position }) {
      const [_, size] = param.type.split("bytes");
      if (!size) {
        const offset = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(data, position, position + 32, { strict: true }));
        const length = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(data, offset, offset + 32, { strict: true }));
        if (length === 0)
          return { consumed: 32, value: "0x" };
        const value2 = (0, slice_js_1.slice)(data, offset + 32, offset + 32 + length, {
          strict: true
        });
        return { consumed: 32, value: value2 };
      }
      const value = (0, slice_js_1.slice)(data, position, position + parseInt(size), {
        strict: true
      });
      return { consumed: 32, value };
    }
    function decodeNumber(value, { param }) {
      const signed = param.type.startsWith("int");
      const size = parseInt(param.type.split("int")[1] || "256");
      return {
        consumed: 32,
        value: size > 48 ? (0, fromHex_js_1.hexToBigInt)(value, { signed }) : (0, fromHex_js_1.hexToNumber)(value, { signed })
      };
    }
    function decodeString(data, { position }) {
      const offset = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(data, position, position + 32, { strict: true }));
      const length = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(data, offset, offset + 32, { strict: true }));
      if (length === 0)
        return { consumed: 32, value: "" };
      const value = (0, fromHex_js_1.hexToString)((0, trim_js_1.trim)((0, slice_js_1.slice)(data, offset + 32, offset + 32 + length, { strict: true })));
      return { consumed: 32, value };
    }
    function decodeTuple(data, { param, position }) {
      const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name }) => !name);
      const value = hasUnnamedChild ? [] : {};
      let consumed = 0;
      if (hasDynamicChild(param)) {
        const offset = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(data, position, position + 32, { strict: true }));
        for (let i = 0; i < param.components.length; ++i) {
          const component = param.components[i];
          const decodedChild = decodeParam({
            data: (0, slice_js_1.slice)(data, offset),
            param: component,
            position: consumed
          });
          consumed += decodedChild.consumed;
          value[hasUnnamedChild ? i : component?.name] = decodedChild.value;
        }
        return { consumed: 32, value };
      }
      for (let i = 0; i < param.components.length; ++i) {
        const component = param.components[i];
        const decodedChild = decodeParam({
          data,
          param: component,
          position: position + consumed
        });
        consumed += decodedChild.consumed;
        value[hasUnnamedChild ? i : component?.name] = decodedChild.value;
      }
      return { consumed, value };
    }
    function hasDynamicChild(param) {
      const { type } = param;
      if (type === "string")
        return true;
      if (type === "bytes")
        return true;
      if (type.endsWith("[]"))
        return true;
      if (type === "tuple")
        return param.components?.some(hasDynamicChild);
      const arrayComponents = (0, encodeAbiParameters_js_1.getArrayComponents)(param.type);
      if (arrayComponents && hasDynamicChild({ ...param, type: arrayComponents[1] }))
        return true;
      return false;
    }
  }
});

// node_modules/viem/_cjs/utils/abi/decodeErrorResult.js
var require_decodeErrorResult = __commonJS({
  "node_modules/viem/_cjs/utils/abi/decodeErrorResult.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeErrorResult = void 0;
    var solidity_js_1 = require_solidity();
    var abi_js_1 = require_abi();
    var slice_js_1 = require_slice();
    var getFunctionSelector_js_1 = require_getFunctionSelector();
    var decodeAbiParameters_js_1 = require_decodeAbiParameters();
    var formatAbiItem_js_1 = require_formatAbiItem2();
    function decodeErrorResult({ abi, data }) {
      const signature = (0, slice_js_1.slice)(data, 0, 4);
      if (signature === "0x")
        throw new abi_js_1.AbiDecodingZeroDataError();
      const abi_ = [...abi || [], solidity_js_1.solidityError, solidity_js_1.solidityPanic];
      const abiItem = abi_.find((x) => x.type === "error" && signature === (0, getFunctionSelector_js_1.getFunctionSelector)((0, formatAbiItem_js_1.formatAbiItem)(x)));
      if (!abiItem)
        throw new abi_js_1.AbiErrorSignatureNotFoundError(signature, {
          docsPath: "/docs/contract/decodeErrorResult"
        });
      return {
        abiItem,
        args: "inputs" in abiItem && abiItem.inputs && abiItem.inputs.length > 0 ? (0, decodeAbiParameters_js_1.decodeAbiParameters)(abiItem.inputs, (0, slice_js_1.slice)(data, 4)) : void 0,
        errorName: abiItem.name
      };
    }
    exports.decodeErrorResult = decodeErrorResult;
  }
});

// node_modules/viem/_cjs/utils/stringify.js
var require_stringify = __commonJS({
  "node_modules/viem/_cjs/utils/stringify.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringify = void 0;
    var stringify = (value, replacer, space) => JSON.stringify(value, (key, value_) => {
      const value2 = typeof value_ === "bigint" ? value_.toString() : value_;
      return typeof replacer === "function" ? replacer(key, value2) : value2;
    }, space);
    exports.stringify = stringify;
  }
});

// node_modules/viem/_cjs/utils/abi/formatAbiItemWithArgs.js
var require_formatAbiItemWithArgs = __commonJS({
  "node_modules/viem/_cjs/utils/abi/formatAbiItemWithArgs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatAbiItemWithArgs = void 0;
    var stringify_js_1 = require_stringify();
    function formatAbiItemWithArgs({ abiItem, args, includeFunctionName = true, includeName = false }) {
      if (!("name" in abiItem))
        return;
      if (!("inputs" in abiItem))
        return;
      if (!abiItem.inputs)
        return;
      return `${includeFunctionName ? abiItem.name : ""}(${abiItem.inputs.map((input, i) => `${includeName && input.name ? `${input.name}: ` : ""}${typeof args[i] === "object" ? (0, stringify_js_1.stringify)(args[i]) : args[i]}`).join(", ")})`;
    }
    exports.formatAbiItemWithArgs = formatAbiItemWithArgs;
  }
});

// node_modules/viem/_cjs/errors/contract.js
var require_contract = __commonJS({
  "node_modules/viem/_cjs/errors/contract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RawContractError = exports.ContractFunctionZeroDataError = exports.ContractFunctionRevertedError = exports.ContractFunctionExecutionError = exports.CallExecutionError = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var solidity_js_1 = require_solidity();
    var decodeErrorResult_js_1 = require_decodeErrorResult();
    var formatAbiItem_js_1 = require_formatAbiItem2();
    var formatAbiItemWithArgs_js_1 = require_formatAbiItemWithArgs();
    var getAbiItem_js_1 = require_getAbiItem();
    var formatEther_js_1 = require_formatEther();
    var formatGwei_js_1 = require_formatGwei();
    var abi_js_1 = require_abi();
    var base_js_1 = require_base();
    var transaction_js_1 = require_transaction2();
    var utils_js_1 = require_utils3();
    var CallExecutionError = class extends base_js_1.BaseError {
      constructor(cause, { account: account_, docsPath, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
        const account = account_ ? (0, parseAccount_js_1.parseAccount)(account_) : void 0;
        const prettyArgs = (0, transaction_js_1.prettyPrint)({
          from: account?.address,
          to,
          value: typeof value !== "undefined" && `${(0, formatEther_js_1.formatEther)(value)} ${chain?.nativeCurrency.symbol || "ETH"}`,
          data,
          gas,
          gasPrice: typeof gasPrice !== "undefined" && `${(0, formatGwei_js_1.formatGwei)(gasPrice)} gwei`,
          maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${(0, formatGwei_js_1.formatGwei)(maxFeePerGas)} gwei`,
          maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${(0, formatGwei_js_1.formatGwei)(maxPriorityFeePerGas)} gwei`,
          nonce
        });
        super(cause.shortMessage, {
          cause,
          docsPath,
          metaMessages: [
            ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
            "Raw Call Arguments:",
            prettyArgs
          ].filter(Boolean)
        });
        Object.defineProperty(this, "cause", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "CallExecutionError"
        });
        this.cause = cause;
      }
    };
    exports.CallExecutionError = CallExecutionError;
    var ContractFunctionExecutionError = class extends base_js_1.BaseError {
      constructor(cause, { abi, args, contractAddress, docsPath, functionName, sender }) {
        const abiItem = (0, getAbiItem_js_1.getAbiItem)({ abi, args, name: functionName });
        const formattedArgs = abiItem ? (0, formatAbiItemWithArgs_js_1.formatAbiItemWithArgs)({
          abiItem,
          args,
          includeFunctionName: false,
          includeName: false
        }) : void 0;
        const functionWithParams = abiItem ? (0, formatAbiItem_js_1.formatAbiItem)(abiItem, { includeName: true }) : void 0;
        const prettyArgs = (0, transaction_js_1.prettyPrint)({
          address: contractAddress && (0, utils_js_1.getContractAddress)(contractAddress),
          function: functionWithParams,
          args: formattedArgs && formattedArgs !== "()" && `${[...Array(functionName?.length ?? 0).keys()].map(() => " ").join("")}${formattedArgs}`,
          sender
        });
        super(cause.shortMessage || `An unknown error occurred while executing the contract function "${functionName}".`, {
          cause,
          docsPath,
          metaMessages: [
            ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
            "Contract Call:",
            prettyArgs
          ].filter(Boolean)
        });
        Object.defineProperty(this, "abi", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "args", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "cause", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "contractAddress", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "formattedArgs", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "functionName", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "sender", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ContractFunctionExecutionError"
        });
        this.abi = abi;
        this.args = args;
        this.cause = cause;
        this.contractAddress = contractAddress;
        this.functionName = functionName;
        this.sender = sender;
      }
    };
    exports.ContractFunctionExecutionError = ContractFunctionExecutionError;
    var ContractFunctionRevertedError = class extends base_js_1.BaseError {
      constructor({ abi, data, functionName, message }) {
        let cause;
        let decodedData = void 0;
        let metaMessages;
        let reason;
        if (data && data !== "0x") {
          try {
            decodedData = (0, decodeErrorResult_js_1.decodeErrorResult)({ abi, data });
            const { abiItem, errorName, args: errorArgs } = decodedData;
            if (errorName === "Error") {
              reason = errorArgs[0];
            } else if (errorName === "Panic") {
              const [firstArg] = errorArgs;
              reason = solidity_js_1.panicReasons[firstArg];
            } else {
              const errorWithParams = abiItem ? (0, formatAbiItem_js_1.formatAbiItem)(abiItem, { includeName: true }) : void 0;
              const formattedArgs = abiItem && errorArgs ? (0, formatAbiItemWithArgs_js_1.formatAbiItemWithArgs)({
                abiItem,
                args: errorArgs,
                includeFunctionName: false,
                includeName: false
              }) : void 0;
              metaMessages = [
                errorWithParams ? `Error: ${errorWithParams}` : "",
                formattedArgs && formattedArgs !== "()" ? `       ${[...Array(errorName?.length ?? 0).keys()].map(() => " ").join("")}${formattedArgs}` : ""
              ];
            }
          } catch (err) {
            cause = err;
          }
        } else if (message)
          reason = message;
        let signature;
        if (cause instanceof abi_js_1.AbiErrorSignatureNotFoundError) {
          signature = cause.signature;
          metaMessages = [
            `Unable to decode signature "${signature}" as it was not found on the provided ABI.`,
            "Make sure you are using the correct ABI and that the error exists on it.",
            `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`
          ];
        }
        super(reason && reason !== "execution reverted" || signature ? [
          `The contract function "${functionName}" reverted with the following ${signature ? "signature" : "reason"}:`,
          reason || signature
        ].join("\n") : `The contract function "${functionName}" reverted.`, {
          cause,
          metaMessages
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ContractFunctionRevertedError"
        });
        Object.defineProperty(this, "data", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "reason", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "signature", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.data = decodedData;
        this.reason = reason;
        this.signature = signature;
      }
    };
    exports.ContractFunctionRevertedError = ContractFunctionRevertedError;
    var ContractFunctionZeroDataError = class extends base_js_1.BaseError {
      constructor({ functionName }) {
        super(`The contract function "${functionName}" returned no data ("0x").`, {
          metaMessages: [
            "This could be due to any of the following:",
            `  - The contract does not have the function "${functionName}",`,
            "  - The parameters passed to the contract function may be invalid, or",
            "  - The address is not a contract."
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ContractFunctionZeroDataError"
        });
      }
    };
    exports.ContractFunctionZeroDataError = ContractFunctionZeroDataError;
    var RawContractError = class extends base_js_1.BaseError {
      constructor({ data, message }) {
        super(message || "");
        Object.defineProperty(this, "code", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: 3
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "RawContractError"
        });
        Object.defineProperty(this, "data", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.data = data;
      }
    };
    exports.RawContractError = RawContractError;
  }
});

// node_modules/viem/_cjs/errors/request.js
var require_request = __commonJS({
  "node_modules/viem/_cjs/errors/request.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TimeoutError = exports.RpcRequestError = exports.WebSocketRequestError = exports.HttpRequestError = void 0;
    var stringify_js_1 = require_stringify();
    var base_js_1 = require_base();
    var utils_js_1 = require_utils3();
    var HttpRequestError = class extends base_js_1.BaseError {
      constructor({ body, details, headers, status, url }) {
        super("HTTP request failed.", {
          details,
          metaMessages: [
            status && `Status: ${status}`,
            `URL: ${(0, utils_js_1.getUrl)(url)}`,
            body && `Request body: ${(0, stringify_js_1.stringify)(body)}`
          ].filter(Boolean)
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "HttpRequestError"
        });
        Object.defineProperty(this, "body", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "headers", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "status", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "url", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.body = body;
        this.headers = headers;
        this.status = status;
        this.url = url;
      }
    };
    exports.HttpRequestError = HttpRequestError;
    var WebSocketRequestError = class extends base_js_1.BaseError {
      constructor({ body, details, url }) {
        super("WebSocket request failed.", {
          details,
          metaMessages: [`URL: ${(0, utils_js_1.getUrl)(url)}`, `Request body: ${(0, stringify_js_1.stringify)(body)}`]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "WebSocketRequestError"
        });
      }
    };
    exports.WebSocketRequestError = WebSocketRequestError;
    var RpcRequestError = class extends base_js_1.BaseError {
      constructor({ body, error, url }) {
        super("RPC Request failed.", {
          cause: error,
          details: error.message,
          metaMessages: [`URL: ${(0, utils_js_1.getUrl)(url)}`, `Request body: ${(0, stringify_js_1.stringify)(body)}`]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "RpcRequestError"
        });
        Object.defineProperty(this, "code", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.code = error.code;
      }
    };
    exports.RpcRequestError = RpcRequestError;
    var TimeoutError = class extends base_js_1.BaseError {
      constructor({ body, url }) {
        super("The request took too long to respond.", {
          details: "The request timed out.",
          metaMessages: [`URL: ${(0, utils_js_1.getUrl)(url)}`, `Request body: ${(0, stringify_js_1.stringify)(body)}`]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "TimeoutError"
        });
      }
    };
    exports.TimeoutError = TimeoutError;
  }
});

// node_modules/viem/_cjs/errors/rpc.js
var require_rpc = __commonJS({
  "node_modules/viem/_cjs/errors/rpc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UnknownRpcError = exports.SwitchChainError = exports.ChainDisconnectedError = exports.ProviderDisconnectedError = exports.UnsupportedProviderMethodError = exports.UnauthorizedProviderError = exports.UserRejectedRequestError = exports.JsonRpcVersionUnsupportedError = exports.LimitExceededRpcError = exports.MethodNotSupportedRpcError = exports.TransactionRejectedRpcError = exports.ResourceUnavailableRpcError = exports.ResourceNotFoundRpcError = exports.InvalidInputRpcError = exports.InternalRpcError = exports.InvalidParamsRpcError = exports.MethodNotFoundRpcError = exports.InvalidRequestRpcError = exports.ParseRpcError = exports.ProviderRpcError = exports.RpcError = void 0;
    var base_js_1 = require_base();
    var request_js_1 = require_request();
    var unknownErrorCode = -1;
    var RpcError = class extends base_js_1.BaseError {
      constructor(cause, { code, docsPath, metaMessages, shortMessage }) {
        super(shortMessage, {
          cause,
          docsPath,
          metaMessages: metaMessages || cause?.metaMessages
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "RpcError"
        });
        Object.defineProperty(this, "code", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.name = cause.name;
        this.code = cause instanceof request_js_1.RpcRequestError ? cause.code : code ?? unknownErrorCode;
      }
    };
    exports.RpcError = RpcError;
    var ProviderRpcError = class extends RpcError {
      constructor(cause, options) {
        super(cause, options);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ProviderRpcError"
        });
        Object.defineProperty(this, "data", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.data = options.data;
      }
    };
    exports.ProviderRpcError = ProviderRpcError;
    var ParseRpcError = class extends RpcError {
      constructor(cause) {
        super(cause, {
          code: ParseRpcError.code,
          shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ParseRpcError"
        });
      }
    };
    exports.ParseRpcError = ParseRpcError;
    Object.defineProperty(ParseRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32700
    });
    var InvalidRequestRpcError = class extends RpcError {
      constructor(cause) {
        super(cause, {
          code: InvalidRequestRpcError.code,
          shortMessage: "JSON is not a valid request object."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidRequestRpcError"
        });
      }
    };
    exports.InvalidRequestRpcError = InvalidRequestRpcError;
    Object.defineProperty(InvalidRequestRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32600
    });
    var MethodNotFoundRpcError = class extends RpcError {
      constructor(cause) {
        super(cause, {
          code: MethodNotFoundRpcError.code,
          shortMessage: "The method does not exist / is not available."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "MethodNotFoundRpcError"
        });
      }
    };
    exports.MethodNotFoundRpcError = MethodNotFoundRpcError;
    Object.defineProperty(MethodNotFoundRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32601
    });
    var InvalidParamsRpcError = class extends RpcError {
      constructor(cause) {
        super(cause, {
          code: InvalidParamsRpcError.code,
          shortMessage: [
            "Invalid parameters were provided to the RPC method.",
            "Double check you have provided the correct parameters."
          ].join("\n")
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidParamsRpcError"
        });
      }
    };
    exports.InvalidParamsRpcError = InvalidParamsRpcError;
    Object.defineProperty(InvalidParamsRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32602
    });
    var InternalRpcError = class extends RpcError {
      constructor(cause) {
        super(cause, {
          code: InternalRpcError.code,
          shortMessage: "An internal error was received."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InternalRpcError"
        });
      }
    };
    exports.InternalRpcError = InternalRpcError;
    Object.defineProperty(InternalRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32603
    });
    var InvalidInputRpcError = class extends RpcError {
      constructor(cause) {
        super(cause, {
          code: InvalidInputRpcError.code,
          shortMessage: [
            "Missing or invalid parameters.",
            "Double check you have provided the correct parameters."
          ].join("\n")
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "InvalidInputRpcError"
        });
      }
    };
    exports.InvalidInputRpcError = InvalidInputRpcError;
    Object.defineProperty(InvalidInputRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32e3
    });
    var ResourceNotFoundRpcError = class extends RpcError {
      constructor(cause) {
        super(cause, {
          code: ResourceNotFoundRpcError.code,
          shortMessage: "Requested resource not found."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ResourceNotFoundRpcError"
        });
      }
    };
    exports.ResourceNotFoundRpcError = ResourceNotFoundRpcError;
    Object.defineProperty(ResourceNotFoundRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32001
    });
    var ResourceUnavailableRpcError = class extends RpcError {
      constructor(cause) {
        super(cause, {
          code: ResourceUnavailableRpcError.code,
          shortMessage: "Requested resource not available."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ResourceUnavailableRpcError"
        });
      }
    };
    exports.ResourceUnavailableRpcError = ResourceUnavailableRpcError;
    Object.defineProperty(ResourceUnavailableRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32002
    });
    var TransactionRejectedRpcError = class extends RpcError {
      constructor(cause) {
        super(cause, {
          code: TransactionRejectedRpcError.code,
          shortMessage: "Transaction creation failed."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "TransactionRejectedRpcError"
        });
      }
    };
    exports.TransactionRejectedRpcError = TransactionRejectedRpcError;
    Object.defineProperty(TransactionRejectedRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32003
    });
    var MethodNotSupportedRpcError = class extends RpcError {
      constructor(cause) {
        super(cause, {
          code: MethodNotSupportedRpcError.code,
          shortMessage: "Method is not implemented."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "MethodNotSupportedRpcError"
        });
      }
    };
    exports.MethodNotSupportedRpcError = MethodNotSupportedRpcError;
    Object.defineProperty(MethodNotSupportedRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32004
    });
    var LimitExceededRpcError = class extends RpcError {
      constructor(cause) {
        super(cause, {
          code: LimitExceededRpcError.code,
          shortMessage: "Request exceeds defined limit."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "LimitExceededRpcError"
        });
      }
    };
    exports.LimitExceededRpcError = LimitExceededRpcError;
    Object.defineProperty(LimitExceededRpcError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32005
    });
    var JsonRpcVersionUnsupportedError = class extends RpcError {
      constructor(cause) {
        super(cause, {
          code: JsonRpcVersionUnsupportedError.code,
          shortMessage: "Version of JSON-RPC protocol is not supported."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "JsonRpcVersionUnsupportedError"
        });
      }
    };
    exports.JsonRpcVersionUnsupportedError = JsonRpcVersionUnsupportedError;
    Object.defineProperty(JsonRpcVersionUnsupportedError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32006
    });
    var UserRejectedRequestError = class extends ProviderRpcError {
      constructor(cause) {
        super(cause, {
          code: UserRejectedRequestError.code,
          shortMessage: "User rejected the request."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "UserRejectedRequestError"
        });
      }
    };
    exports.UserRejectedRequestError = UserRejectedRequestError;
    Object.defineProperty(UserRejectedRequestError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4001
    });
    var UnauthorizedProviderError = class extends ProviderRpcError {
      constructor(cause) {
        super(cause, {
          code: UnauthorizedProviderError.code,
          shortMessage: "The requested method and/or account has not been authorized by the user."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "UnauthorizedProviderError"
        });
      }
    };
    exports.UnauthorizedProviderError = UnauthorizedProviderError;
    Object.defineProperty(UnauthorizedProviderError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4100
    });
    var UnsupportedProviderMethodError = class extends ProviderRpcError {
      constructor(cause) {
        super(cause, {
          code: UnsupportedProviderMethodError.code,
          shortMessage: "The Provider does not support the requested method."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "UnsupportedProviderMethodError"
        });
      }
    };
    exports.UnsupportedProviderMethodError = UnsupportedProviderMethodError;
    Object.defineProperty(UnsupportedProviderMethodError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4200
    });
    var ProviderDisconnectedError = class extends ProviderRpcError {
      constructor(cause) {
        super(cause, {
          code: ProviderDisconnectedError.code,
          shortMessage: "The Provider is disconnected from all chains."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ProviderDisconnectedError"
        });
      }
    };
    exports.ProviderDisconnectedError = ProviderDisconnectedError;
    Object.defineProperty(ProviderDisconnectedError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4900
    });
    var ChainDisconnectedError = class extends ProviderRpcError {
      constructor(cause) {
        super(cause, {
          code: ChainDisconnectedError.code,
          shortMessage: "The Provider is not connected to the requested chain."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "ChainDisconnectedError"
        });
      }
    };
    exports.ChainDisconnectedError = ChainDisconnectedError;
    Object.defineProperty(ChainDisconnectedError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4901
    });
    var SwitchChainError = class extends ProviderRpcError {
      constructor(cause) {
        super(cause, {
          code: SwitchChainError.code,
          shortMessage: "An error occurred when attempting to switch chain."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "SwitchChainError"
        });
      }
    };
    exports.SwitchChainError = SwitchChainError;
    Object.defineProperty(SwitchChainError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4902
    });
    var UnknownRpcError = class extends RpcError {
      constructor(cause) {
        super(cause, {
          shortMessage: "An unknown RPC error occurred."
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "UnknownRpcError"
        });
      }
    };
    exports.UnknownRpcError = UnknownRpcError;
  }
});

// node_modules/viem/_cjs/utils/errors/getContractError.js
var require_getContractError = __commonJS({
  "node_modules/viem/_cjs/utils/errors/getContractError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getContractError = void 0;
    var abi_js_1 = require_abi();
    var base_js_1 = require_base();
    var contract_js_1 = require_contract();
    var rpc_js_1 = require_rpc();
    var EXECUTION_REVERTED_ERROR_CODE = 3;
    function getContractError(err, { abi, address, args, docsPath, functionName, sender }) {
      const { code, data, message, shortMessage } = err instanceof contract_js_1.RawContractError ? err : err instanceof base_js_1.BaseError ? err.walk((err2) => "data" in err2) || err.walk() : {};
      let cause = err;
      if (err instanceof abi_js_1.AbiDecodingZeroDataError) {
        cause = new contract_js_1.ContractFunctionZeroDataError({ functionName });
      } else if ([EXECUTION_REVERTED_ERROR_CODE, rpc_js_1.InternalRpcError.code].includes(code) && (data || message || shortMessage)) {
        cause = new contract_js_1.ContractFunctionRevertedError({
          abi,
          data: typeof data === "object" ? data.data : data,
          functionName,
          message: shortMessage ?? message
        });
      }
      return new contract_js_1.ContractFunctionExecutionError(cause, {
        abi,
        args,
        contractAddress: address,
        docsPath,
        functionName,
        sender
      });
    }
    exports.getContractError = getContractError;
  }
});

// node_modules/viem/_cjs/errors/account.js
var require_account = __commonJS({
  "node_modules/viem/_cjs/errors/account.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AccountNotFoundError = void 0;
    var base_js_1 = require_base();
    var AccountNotFoundError = class extends base_js_1.BaseError {
      constructor({ docsPath } = {}) {
        super([
          "Could not find an Account to execute with this Action.",
          "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the WalletClient."
        ].join("\n"), {
          docsPath,
          docsSlug: "account"
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "AccountNotFoundError"
        });
      }
    };
    exports.AccountNotFoundError = AccountNotFoundError;
  }
});

// node_modules/viem/_cjs/errors/estimateGas.js
var require_estimateGas = __commonJS({
  "node_modules/viem/_cjs/errors/estimateGas.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EstimateGasExecutionError = void 0;
    var formatEther_js_1 = require_formatEther();
    var formatGwei_js_1 = require_formatGwei();
    var base_js_1 = require_base();
    var transaction_js_1 = require_transaction2();
    var EstimateGasExecutionError = class extends base_js_1.BaseError {
      constructor(cause, { account, docsPath, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
        const prettyArgs = (0, transaction_js_1.prettyPrint)({
          from: account?.address,
          to,
          value: typeof value !== "undefined" && `${(0, formatEther_js_1.formatEther)(value)} ${chain?.nativeCurrency.symbol || "ETH"}`,
          data,
          gas,
          gasPrice: typeof gasPrice !== "undefined" && `${(0, formatGwei_js_1.formatGwei)(gasPrice)} gwei`,
          maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${(0, formatGwei_js_1.formatGwei)(maxFeePerGas)} gwei`,
          maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${(0, formatGwei_js_1.formatGwei)(maxPriorityFeePerGas)} gwei`,
          nonce
        });
        super(cause.shortMessage, {
          cause,
          docsPath,
          metaMessages: [
            ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
            "Estimate Gas Arguments:",
            prettyArgs
          ].filter(Boolean)
        });
        Object.defineProperty(this, "cause", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "EstimateGasExecutionError"
        });
        this.cause = cause;
      }
    };
    exports.EstimateGasExecutionError = EstimateGasExecutionError;
  }
});

// node_modules/viem/_cjs/utils/errors/getNodeError.js
var require_getNodeError = __commonJS({
  "node_modules/viem/_cjs/utils/errors/getNodeError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getNodeError = exports.containsNodeError = void 0;
    var base_js_1 = require_base();
    var node_js_1 = require_node();
    var request_js_1 = require_request();
    var rpc_js_1 = require_rpc();
    function containsNodeError(err) {
      return err instanceof rpc_js_1.TransactionRejectedRpcError || err instanceof rpc_js_1.InvalidInputRpcError || err instanceof request_js_1.RpcRequestError && err.code === node_js_1.ExecutionRevertedError.code;
    }
    exports.containsNodeError = containsNodeError;
    function getNodeError(err, args) {
      const message = (err.details || "").toLowerCase();
      const executionRevertedError = err.walk((e) => e.code === node_js_1.ExecutionRevertedError.code);
      if (executionRevertedError instanceof base_js_1.BaseError) {
        return new node_js_1.ExecutionRevertedError({
          cause: err,
          message: executionRevertedError.details
        });
      } else if (node_js_1.ExecutionRevertedError.nodeMessage.test(message))
        return new node_js_1.ExecutionRevertedError({
          cause: err,
          message: err.details
        });
      else if (node_js_1.FeeCapTooHighError.nodeMessage.test(message))
        return new node_js_1.FeeCapTooHighError({
          cause: err,
          maxFeePerGas: args?.maxFeePerGas
        });
      else if (node_js_1.FeeCapTooLowError.nodeMessage.test(message))
        return new node_js_1.FeeCapTooLowError({
          cause: err,
          maxFeePerGas: args?.maxFeePerGas
        });
      else if (node_js_1.NonceTooHighError.nodeMessage.test(message))
        return new node_js_1.NonceTooHighError({ cause: err, nonce: args?.nonce });
      else if (node_js_1.NonceTooLowError.nodeMessage.test(message))
        return new node_js_1.NonceTooLowError({ cause: err, nonce: args?.nonce });
      else if (node_js_1.NonceMaxValueError.nodeMessage.test(message))
        return new node_js_1.NonceMaxValueError({ cause: err, nonce: args?.nonce });
      else if (node_js_1.InsufficientFundsError.nodeMessage.test(message))
        return new node_js_1.InsufficientFundsError({ cause: err });
      else if (node_js_1.IntrinsicGasTooHighError.nodeMessage.test(message))
        return new node_js_1.IntrinsicGasTooHighError({ cause: err, gas: args?.gas });
      else if (node_js_1.IntrinsicGasTooLowError.nodeMessage.test(message))
        return new node_js_1.IntrinsicGasTooLowError({ cause: err, gas: args?.gas });
      else if (node_js_1.TransactionTypeNotSupportedError.nodeMessage.test(message))
        return new node_js_1.TransactionTypeNotSupportedError({ cause: err });
      else if (node_js_1.TipAboveFeeCapError.nodeMessage.test(message))
        return new node_js_1.TipAboveFeeCapError({
          cause: err,
          maxFeePerGas: args?.maxFeePerGas,
          maxPriorityFeePerGas: args?.maxPriorityFeePerGas
        });
      return new node_js_1.UnknownNodeError({
        cause: err
      });
    }
    exports.getNodeError = getNodeError;
  }
});

// node_modules/viem/_cjs/utils/errors/getEstimateGasError.js
var require_getEstimateGasError = __commonJS({
  "node_modules/viem/_cjs/utils/errors/getEstimateGasError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEstimateGasError = void 0;
    var estimateGas_js_1 = require_estimateGas();
    var node_js_1 = require_node();
    var getNodeError_js_1 = require_getNodeError();
    function getEstimateGasError(err, { docsPath, ...args }) {
      let cause = (0, getNodeError_js_1.getNodeError)(err, args);
      if (cause instanceof node_js_1.UnknownNodeError)
        cause = err;
      return new estimateGas_js_1.EstimateGasExecutionError(cause, {
        docsPath,
        ...args
      });
    }
    exports.getEstimateGasError = getEstimateGasError;
  }
});

// node_modules/viem/_cjs/utils/formatters/extract.js
var require_extract = __commonJS({
  "node_modules/viem/_cjs/utils/formatters/extract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extract = void 0;
    function extract(value, { format }) {
      if (!format)
        return {};
      const keys = Object.keys(format({}));
      return keys.reduce((data, key) => {
        if (value?.hasOwnProperty(key)) {
          data[key] = value[key];
        }
        return data;
      }, {});
    }
    exports.extract = extract;
  }
});

// node_modules/viem/_cjs/utils/transaction/assertRequest.js
var require_assertRequest = __commonJS({
  "node_modules/viem/_cjs/utils/transaction/assertRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assertRequest = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var address_js_1 = require_address();
    var node_js_1 = require_node();
    var transaction_js_1 = require_transaction2();
    var isAddress_js_1 = require_isAddress();
    function assertRequest(args) {
      const { account: account_, gasPrice, maxFeePerGas, maxPriorityFeePerGas, to } = args;
      const account = account_ ? (0, parseAccount_js_1.parseAccount)(account_) : void 0;
      if (account && !(0, isAddress_js_1.isAddress)(account.address))
        throw new address_js_1.InvalidAddressError({ address: account.address });
      if (to && !(0, isAddress_js_1.isAddress)(to))
        throw new address_js_1.InvalidAddressError({ address: to });
      if (typeof gasPrice !== "undefined" && (typeof maxFeePerGas !== "undefined" || typeof maxPriorityFeePerGas !== "undefined"))
        throw new transaction_js_1.FeeConflictError();
      if (maxFeePerGas && maxFeePerGas > 2n ** 256n - 1n)
        throw new node_js_1.FeeCapTooHighError({ maxFeePerGas });
      if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
        throw new node_js_1.TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
    }
    exports.assertRequest = assertRequest;
  }
});

// node_modules/viem/_cjs/errors/fee.js
var require_fee = __commonJS({
  "node_modules/viem/_cjs/errors/fee.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MaxFeePerGasTooLowError = exports.Eip1559FeesNotSupportedError = exports.BaseFeeScalarError = void 0;
    var formatGwei_js_1 = require_formatGwei();
    var base_js_1 = require_base();
    var BaseFeeScalarError = class extends base_js_1.BaseError {
      constructor() {
        super("`baseFeeMultiplier` must be greater than 1.");
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "BaseFeeScalarError"
        });
      }
    };
    exports.BaseFeeScalarError = BaseFeeScalarError;
    var Eip1559FeesNotSupportedError = class extends base_js_1.BaseError {
      constructor() {
        super("Chain does not support EIP-1559 fees.");
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "Eip1559FeesNotSupportedError"
        });
      }
    };
    exports.Eip1559FeesNotSupportedError = Eip1559FeesNotSupportedError;
    var MaxFeePerGasTooLowError = class extends base_js_1.BaseError {
      constructor({ maxPriorityFeePerGas }) {
        super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${(0, formatGwei_js_1.formatGwei)(maxPriorityFeePerGas)} gwei).`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "MaxFeePerGasTooLowError"
        });
      }
    };
    exports.MaxFeePerGasTooLowError = MaxFeePerGasTooLowError;
  }
});

// node_modules/viem/_cjs/errors/block.js
var require_block2 = __commonJS({
  "node_modules/viem/_cjs/errors/block.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BlockNotFoundError = void 0;
    var base_js_1 = require_base();
    var BlockNotFoundError = class extends base_js_1.BaseError {
      constructor({ blockHash, blockNumber }) {
        let identifier = "Block";
        if (blockHash)
          identifier = `Block at hash "${blockHash}"`;
        if (blockNumber)
          identifier = `Block at number "${blockNumber}"`;
        super(`${identifier} could not be found.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "BlockNotFoundError"
        });
      }
    };
    exports.BlockNotFoundError = BlockNotFoundError;
  }
});

// node_modules/viem/_cjs/actions/public/getBlock.js
var require_getBlock = __commonJS({
  "node_modules/viem/_cjs/actions/public/getBlock.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getBlock = void 0;
    var block_js_1 = require_block2();
    var toHex_js_1 = require_toHex();
    var block_js_2 = require_block();
    async function getBlock(client, { blockHash, blockNumber, blockTag: blockTag_, includeTransactions: includeTransactions_ } = {}) {
      const blockTag = blockTag_ ?? "latest";
      const includeTransactions = includeTransactions_ ?? false;
      const blockNumberHex = blockNumber !== void 0 ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
      let block = null;
      if (blockHash) {
        block = await client.request({
          method: "eth_getBlockByHash",
          params: [blockHash, includeTransactions]
        });
      } else {
        block = await client.request({
          method: "eth_getBlockByNumber",
          params: [blockNumberHex || blockTag, includeTransactions]
        });
      }
      if (!block)
        throw new block_js_1.BlockNotFoundError({ blockHash, blockNumber });
      const format = client.chain?.formatters?.block?.format || block_js_2.formatBlock;
      return format(block);
    }
    exports.getBlock = getBlock;
  }
});

// node_modules/viem/_cjs/actions/public/getGasPrice.js
var require_getGasPrice = __commonJS({
  "node_modules/viem/_cjs/actions/public/getGasPrice.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getGasPrice = void 0;
    async function getGasPrice(client) {
      const gasPrice = await client.request({
        method: "eth_gasPrice"
      });
      return BigInt(gasPrice);
    }
    exports.getGasPrice = getGasPrice;
  }
});

// node_modules/viem/_cjs/actions/public/estimateMaxPriorityFeePerGas.js
var require_estimateMaxPriorityFeePerGas = __commonJS({
  "node_modules/viem/_cjs/actions/public/estimateMaxPriorityFeePerGas.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.internal_estimateMaxPriorityFeePerGas = exports.estimateMaxPriorityFeePerGas = void 0;
    var fee_js_1 = require_fee();
    var fromHex_js_1 = require_fromHex();
    var getBlock_js_1 = require_getBlock();
    var getGasPrice_js_1 = require_getGasPrice();
    async function estimateMaxPriorityFeePerGas(client, args) {
      return internal_estimateMaxPriorityFeePerGas(client, args);
    }
    exports.estimateMaxPriorityFeePerGas = estimateMaxPriorityFeePerGas;
    async function internal_estimateMaxPriorityFeePerGas(client, args) {
      const { block: block_, chain = client.chain, request } = args || {};
      if (typeof chain?.fees?.defaultPriorityFee === "function") {
        const block = block_ || await (0, getBlock_js_1.getBlock)(client);
        return chain.fees.defaultPriorityFee({
          block,
          client,
          request
        });
      } else if (chain?.fees?.defaultPriorityFee)
        return chain?.fees?.defaultPriorityFee;
      try {
        const maxPriorityFeePerGasHex = await client.request({
          method: "eth_maxPriorityFeePerGas"
        });
        return (0, fromHex_js_1.hexToBigInt)(maxPriorityFeePerGasHex);
      } catch {
        const [block, gasPrice] = await Promise.all([
          block_ ? Promise.resolve(block_) : (0, getBlock_js_1.getBlock)(client),
          (0, getGasPrice_js_1.getGasPrice)(client)
        ]);
        if (typeof block.baseFeePerGas !== "bigint")
          throw new fee_js_1.Eip1559FeesNotSupportedError();
        const maxPriorityFeePerGas = gasPrice - block.baseFeePerGas;
        if (maxPriorityFeePerGas < 0n)
          return 0n;
        return maxPriorityFeePerGas;
      }
    }
    exports.internal_estimateMaxPriorityFeePerGas = internal_estimateMaxPriorityFeePerGas;
  }
});

// node_modules/viem/_cjs/actions/public/estimateFeesPerGas.js
var require_estimateFeesPerGas = __commonJS({
  "node_modules/viem/_cjs/actions/public/estimateFeesPerGas.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.internal_estimateFeesPerGas = exports.estimateFeesPerGas = void 0;
    var fee_js_1 = require_fee();
    var estimateMaxPriorityFeePerGas_js_1 = require_estimateMaxPriorityFeePerGas();
    var getBlock_js_1 = require_getBlock();
    var getGasPrice_js_1 = require_getGasPrice();
    async function estimateFeesPerGas(client, args) {
      return internal_estimateFeesPerGas(client, args);
    }
    exports.estimateFeesPerGas = estimateFeesPerGas;
    async function internal_estimateFeesPerGas(client, args) {
      const { block: block_, chain = client.chain, request, type = "eip1559" } = args || {};
      const baseFeeMultiplier = await (async () => {
        if (typeof chain?.fees?.baseFeeMultiplier === "function")
          return chain.fees.baseFeeMultiplier({
            block: block_,
            client,
            request
          });
        return chain?.fees?.baseFeeMultiplier ?? 1.2;
      })();
      if (baseFeeMultiplier < 1)
        throw new fee_js_1.BaseFeeScalarError();
      const decimals = baseFeeMultiplier.toString().split(".")[1]?.length ?? 0;
      const denominator = 10 ** decimals;
      const multiply = (base) => base * BigInt(Math.ceil(baseFeeMultiplier * denominator)) / BigInt(denominator);
      const block = block_ ? block_ : await (0, getBlock_js_1.getBlock)(client);
      if (typeof chain?.fees?.estimateFeesPerGas === "function")
        return chain.fees.estimateFeesPerGas({
          block: block_,
          client,
          multiply,
          request,
          type
        });
      if (type === "eip1559") {
        if (typeof block.baseFeePerGas !== "bigint")
          throw new fee_js_1.Eip1559FeesNotSupportedError();
        const maxPriorityFeePerGas = request?.maxPriorityFeePerGas ? request.maxPriorityFeePerGas : await (0, estimateMaxPriorityFeePerGas_js_1.internal_estimateMaxPriorityFeePerGas)(client, {
          block,
          chain,
          request
        });
        const baseFeePerGas = multiply(block.baseFeePerGas);
        const maxFeePerGas = request?.maxFeePerGas ?? baseFeePerGas + maxPriorityFeePerGas;
        return {
          maxFeePerGas,
          maxPriorityFeePerGas
        };
      }
      const gasPrice = request?.gasPrice ?? multiply(await (0, getGasPrice_js_1.getGasPrice)(client));
      return {
        gasPrice
      };
    }
    exports.internal_estimateFeesPerGas = internal_estimateFeesPerGas;
  }
});

// node_modules/viem/_cjs/actions/public/getTransactionCount.js
var require_getTransactionCount = __commonJS({
  "node_modules/viem/_cjs/actions/public/getTransactionCount.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTransactionCount = void 0;
    var fromHex_js_1 = require_fromHex();
    var toHex_js_1 = require_toHex();
    async function getTransactionCount(client, { address, blockTag = "latest", blockNumber }) {
      const count = await client.request({
        method: "eth_getTransactionCount",
        params: [address, blockNumber ? (0, toHex_js_1.numberToHex)(blockNumber) : blockTag]
      });
      return (0, fromHex_js_1.hexToNumber)(count);
    }
    exports.getTransactionCount = getTransactionCount;
  }
});

// node_modules/viem/_cjs/actions/wallet/prepareTransactionRequest.js
var require_prepareTransactionRequest = __commonJS({
  "node_modules/viem/_cjs/actions/wallet/prepareTransactionRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.prepareTransactionRequest = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var estimateFeesPerGas_js_1 = require_estimateFeesPerGas();
    var estimateGas_js_1 = require_estimateGas2();
    var getBlock_js_1 = require_getBlock();
    var getTransactionCount_js_1 = require_getTransactionCount();
    var account_js_1 = require_account();
    var fee_js_1 = require_fee();
    var assertRequest_js_1 = require_assertRequest();
    var getTransactionType_js_1 = require_getTransactionType();
    async function prepareTransactionRequest(client, args) {
      const { account: account_ = client.account, chain, gas, nonce, type } = args;
      if (!account_)
        throw new account_js_1.AccountNotFoundError();
      const account = (0, parseAccount_js_1.parseAccount)(account_);
      const block = await (0, getBlock_js_1.getBlock)(client, { blockTag: "latest" });
      const request = { ...args, from: account.address };
      if (typeof nonce === "undefined")
        request.nonce = await (0, getTransactionCount_js_1.getTransactionCount)(client, {
          address: account.address,
          blockTag: "pending"
        });
      if (typeof type === "undefined") {
        try {
          request.type = (0, getTransactionType_js_1.getTransactionType)(request);
        } catch {
          request.type = typeof block.baseFeePerGas === "bigint" ? "eip1559" : "legacy";
        }
      }
      if (request.type === "eip1559") {
        const { maxFeePerGas, maxPriorityFeePerGas } = await (0, estimateFeesPerGas_js_1.internal_estimateFeesPerGas)(client, {
          block,
          chain,
          request
        });
        if (typeof args.maxPriorityFeePerGas === "undefined" && args.maxFeePerGas && args.maxFeePerGas < maxPriorityFeePerGas)
          throw new fee_js_1.MaxFeePerGasTooLowError({
            maxPriorityFeePerGas
          });
        request.maxPriorityFeePerGas = maxPriorityFeePerGas;
        request.maxFeePerGas = maxFeePerGas;
      } else {
        if (typeof args.maxFeePerGas !== "undefined" || typeof args.maxPriorityFeePerGas !== "undefined")
          throw new fee_js_1.Eip1559FeesNotSupportedError();
        const { gasPrice: gasPrice_ } = await (0, estimateFeesPerGas_js_1.internal_estimateFeesPerGas)(client, {
          block,
          chain,
          request,
          type: "legacy"
        });
        request.gasPrice = gasPrice_;
      }
      if (typeof gas === "undefined")
        request.gas = await (0, estimateGas_js_1.estimateGas)(client, {
          ...request,
          account: { address: account.address, type: "json-rpc" }
        });
      (0, assertRequest_js_1.assertRequest)(request);
      return request;
    }
    exports.prepareTransactionRequest = prepareTransactionRequest;
  }
});

// node_modules/viem/_cjs/actions/public/estimateGas.js
var require_estimateGas2 = __commonJS({
  "node_modules/viem/_cjs/actions/public/estimateGas.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.estimateGas = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var account_js_1 = require_account();
    var toHex_js_1 = require_toHex();
    var getEstimateGasError_js_1 = require_getEstimateGasError();
    var extract_js_1 = require_extract();
    var transactionRequest_js_1 = require_transactionRequest();
    var assertRequest_js_1 = require_assertRequest();
    var prepareTransactionRequest_js_1 = require_prepareTransactionRequest();
    async function estimateGas(client, args) {
      const account_ = args.account ?? client.account;
      if (!account_)
        throw new account_js_1.AccountNotFoundError({
          docsPath: "/docs/actions/public/estimateGas"
        });
      const account = (0, parseAccount_js_1.parseAccount)(account_);
      try {
        const { accessList, blockNumber, blockTag, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = account.type === "local" ? await (0, prepareTransactionRequest_js_1.prepareTransactionRequest)(client, args) : args;
        const blockNumberHex = blockNumber ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
        const block = blockNumberHex || blockTag;
        (0, assertRequest_js_1.assertRequest)(args);
        const format = client.chain?.formatters?.transactionRequest?.format || transactionRequest_js_1.formatTransactionRequest;
        const request = format({
          ...(0, extract_js_1.extract)(rest, { format }),
          from: account.address,
          accessList,
          data,
          gas,
          gasPrice,
          maxFeePerGas,
          maxPriorityFeePerGas,
          nonce,
          to,
          value
        });
        const balance = await client.request({
          method: "eth_estimateGas",
          params: block ? [request, block] : [request]
        });
        return BigInt(balance);
      } catch (err) {
        throw (0, getEstimateGasError_js_1.getEstimateGasError)(err, {
          ...args,
          account,
          chain: client.chain
        });
      }
    }
    exports.estimateGas = estimateGas;
  }
});

// node_modules/viem/_cjs/actions/public/estimateContractGas.js
var require_estimateContractGas = __commonJS({
  "node_modules/viem/_cjs/actions/public/estimateContractGas.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.estimateContractGas = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    var getContractError_js_1 = require_getContractError();
    var estimateGas_js_1 = require_estimateGas2();
    async function estimateContractGas(client, { abi, address, args, functionName, ...request }) {
      const data = (0, encodeFunctionData_js_1.encodeFunctionData)({
        abi,
        args,
        functionName
      });
      try {
        const gas = await (0, estimateGas_js_1.estimateGas)(client, {
          data,
          to: address,
          ...request
        });
        return gas;
      } catch (err) {
        const account = request.account ? (0, parseAccount_js_1.parseAccount)(request.account) : void 0;
        throw (0, getContractError_js_1.getContractError)(err, {
          abi,
          address,
          args,
          docsPath: "/docs/contract/estimateContractGas",
          functionName,
          sender: account?.address
        });
      }
    }
    exports.estimateContractGas = estimateContractGas;
  }
});

// node_modules/viem/_cjs/utils/abi/decodeFunctionResult.js
var require_decodeFunctionResult = __commonJS({
  "node_modules/viem/_cjs/utils/abi/decodeFunctionResult.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeFunctionResult = void 0;
    var abi_js_1 = require_abi();
    var decodeAbiParameters_js_1 = require_decodeAbiParameters();
    var getAbiItem_js_1 = require_getAbiItem();
    var docsPath = "/docs/contract/decodeFunctionResult";
    function decodeFunctionResult({ abi, args, functionName, data }) {
      let abiItem = abi[0];
      if (functionName) {
        abiItem = (0, getAbiItem_js_1.getAbiItem)({
          abi,
          args,
          name: functionName
        });
        if (!abiItem)
          throw new abi_js_1.AbiFunctionNotFoundError(functionName, { docsPath });
      }
      if (abiItem.type !== "function")
        throw new abi_js_1.AbiFunctionNotFoundError(void 0, { docsPath });
      if (!abiItem.outputs)
        throw new abi_js_1.AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath });
      const values = (0, decodeAbiParameters_js_1.decodeAbiParameters)(abiItem.outputs, data);
      if (values && values.length > 1)
        return values;
      if (values && values.length === 1)
        return values[0];
      return void 0;
    }
    exports.decodeFunctionResult = decodeFunctionResult;
  }
});

// node_modules/viem/_cjs/constants/abis.js
var require_abis = __commonJS({
  "node_modules/viem/_cjs/constants/abis.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.universalSignatureValidatorAbi = exports.smartAccountAbi = exports.addressResolverAbi = exports.textResolverAbi = exports.universalResolverReverseAbi = exports.universalResolverResolveAbi = exports.multicall3Abi = void 0;
    exports.multicall3Abi = [
      {
        inputs: [
          {
            components: [
              {
                name: "target",
                type: "address"
              },
              {
                name: "allowFailure",
                type: "bool"
              },
              {
                name: "callData",
                type: "bytes"
              }
            ],
            name: "calls",
            type: "tuple[]"
          }
        ],
        name: "aggregate3",
        outputs: [
          {
            components: [
              {
                name: "success",
                type: "bool"
              },
              {
                name: "returnData",
                type: "bytes"
              }
            ],
            name: "returnData",
            type: "tuple[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      }
    ];
    var universalResolverErrors = [
      {
        inputs: [],
        name: "ResolverNotFound",
        type: "error"
      },
      {
        inputs: [],
        name: "ResolverWildcardNotSupported",
        type: "error"
      }
    ];
    exports.universalResolverResolveAbi = [
      ...universalResolverErrors,
      {
        name: "resolve",
        type: "function",
        stateMutability: "view",
        inputs: [
          { name: "name", type: "bytes" },
          { name: "data", type: "bytes" }
        ],
        outputs: [
          { name: "", type: "bytes" },
          { name: "address", type: "address" }
        ]
      }
    ];
    exports.universalResolverReverseAbi = [
      ...universalResolverErrors,
      {
        name: "reverse",
        type: "function",
        stateMutability: "view",
        inputs: [{ type: "bytes", name: "reverseName" }],
        outputs: [
          { type: "string", name: "resolvedName" },
          { type: "address", name: "resolvedAddress" },
          { type: "address", name: "reverseResolver" },
          { type: "address", name: "resolver" }
        ]
      }
    ];
    exports.textResolverAbi = [
      {
        name: "text",
        type: "function",
        stateMutability: "view",
        inputs: [
          { name: "name", type: "bytes32" },
          { name: "key", type: "string" }
        ],
        outputs: [{ name: "", type: "string" }]
      }
    ];
    exports.addressResolverAbi = [
      {
        name: "addr",
        type: "function",
        stateMutability: "view",
        inputs: [{ name: "name", type: "bytes32" }],
        outputs: [{ name: "", type: "address" }]
      },
      {
        name: "addr",
        type: "function",
        stateMutability: "view",
        inputs: [
          { name: "name", type: "bytes32" },
          { name: "coinType", type: "uint256" }
        ],
        outputs: [{ name: "", type: "bytes" }]
      }
    ];
    exports.smartAccountAbi = [
      {
        name: "isValidSignature",
        type: "function",
        stateMutability: "view",
        inputs: [
          { name: "hash", type: "bytes32" },
          { name: "signature", type: "bytes" }
        ],
        outputs: [{ name: "", type: "bytes4" }]
      }
    ];
    exports.universalSignatureValidatorAbi = [
      {
        inputs: [
          {
            internalType: "address",
            name: "_signer",
            type: "address"
          },
          {
            internalType: "bytes32",
            name: "_hash",
            type: "bytes32"
          },
          {
            internalType: "bytes",
            name: "_signature",
            type: "bytes"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      }
    ];
  }
});

// node_modules/viem/_cjs/constants/contract.js
var require_contract2 = __commonJS({
  "node_modules/viem/_cjs/constants/contract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.aggregate3Signature = void 0;
    exports.aggregate3Signature = "0x82ad56cb";
  }
});

// node_modules/viem/_cjs/utils/errors/getCallError.js
var require_getCallError = __commonJS({
  "node_modules/viem/_cjs/utils/errors/getCallError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getCallError = void 0;
    var contract_js_1 = require_contract();
    var node_js_1 = require_node();
    var getNodeError_js_1 = require_getNodeError();
    function getCallError(err, { docsPath, ...args }) {
      let cause = (0, getNodeError_js_1.getNodeError)(err, args);
      if (cause instanceof node_js_1.UnknownNodeError)
        cause = err;
      return new contract_js_1.CallExecutionError(cause, {
        docsPath,
        ...args
      });
    }
    exports.getCallError = getCallError;
  }
});

// node_modules/viem/_cjs/utils/promise/createBatchScheduler.js
var require_createBatchScheduler = __commonJS({
  "node_modules/viem/_cjs/utils/promise/createBatchScheduler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createBatchScheduler = void 0;
    var schedulerCache = /* @__PURE__ */ new Map();
    function createBatchScheduler({ fn, id, shouldSplitBatch, wait = 0 }) {
      const exec = async () => {
        const scheduler = getScheduler();
        flush();
        const args = scheduler.map(({ args: args2 }) => args2);
        if (args.length === 0)
          return;
        fn(args).then((data) => {
          scheduler.forEach(({ pendingPromise }, i) => pendingPromise.resolve?.([data[i], data]));
        }).catch((err) => {
          scheduler.forEach(({ pendingPromise }) => pendingPromise.reject?.(err));
        });
      };
      const flush = () => schedulerCache.delete(id);
      const getBatchedArgs = () => getScheduler().map(({ args }) => args);
      const getScheduler = () => schedulerCache.get(id) || [];
      const setScheduler = (item) => schedulerCache.set(id, [...getScheduler(), item]);
      return {
        flush,
        async schedule(args) {
          const pendingPromise = {};
          const promise = new Promise((resolve, reject) => {
            pendingPromise.resolve = resolve;
            pendingPromise.reject = reject;
          });
          const split = shouldSplitBatch?.([...getBatchedArgs(), args]);
          if (split)
            exec();
          const hasActiveScheduler = getScheduler().length > 0;
          if (hasActiveScheduler) {
            setScheduler({ args, pendingPromise });
            return promise;
          }
          setScheduler({ args, pendingPromise });
          setTimeout(exec, wait);
          return promise;
        }
      };
    }
    exports.createBatchScheduler = createBatchScheduler;
  }
});

// node_modules/viem/_cjs/errors/ccip.js
var require_ccip = __commonJS({
  "node_modules/viem/_cjs/errors/ccip.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OffchainLookupSenderMismatchError = exports.OffchainLookupResponseMalformedError = exports.OffchainLookupError = void 0;
    var stringify_js_1 = require_stringify();
    var base_js_1 = require_base();
    var utils_js_1 = require_utils3();
    var OffchainLookupError = class extends base_js_1.BaseError {
      constructor({ callbackSelector, cause, data, extraData, sender, urls }) {
        super(cause.shortMessage || "An error occurred while fetching for an offchain result.", {
          cause,
          metaMessages: [
            ...cause.metaMessages || [],
            cause.metaMessages?.length ? "" : [],
            "Offchain Gateway Call:",
            urls && [
              "  Gateway URL(s):",
              ...urls.map((url) => `    ${(0, utils_js_1.getUrl)(url)}`)
            ],
            `  Sender: ${sender}`,
            `  Data: ${data}`,
            `  Callback selector: ${callbackSelector}`,
            `  Extra data: ${extraData}`
          ].flat()
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "OffchainLookupError"
        });
      }
    };
    exports.OffchainLookupError = OffchainLookupError;
    var OffchainLookupResponseMalformedError = class extends base_js_1.BaseError {
      constructor({ result, url }) {
        super("Offchain gateway response is malformed. Response data must be a hex value.", {
          metaMessages: [
            `Gateway URL: ${(0, utils_js_1.getUrl)(url)}`,
            `Response: ${(0, stringify_js_1.stringify)(result)}`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "OffchainLookupResponseMalformedError"
        });
      }
    };
    exports.OffchainLookupResponseMalformedError = OffchainLookupResponseMalformedError;
    var OffchainLookupSenderMismatchError = class extends base_js_1.BaseError {
      constructor({ sender, to }) {
        super("Reverted sender address does not match target contract address (`to`).", {
          metaMessages: [
            `Contract address: ${to}`,
            `OffchainLookup sender address: ${sender}`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "OffchainLookupSenderMismatchError"
        });
      }
    };
    exports.OffchainLookupSenderMismatchError = OffchainLookupSenderMismatchError;
  }
});

// node_modules/viem/_cjs/utils/address/isAddressEqual.js
var require_isAddressEqual = __commonJS({
  "node_modules/viem/_cjs/utils/address/isAddressEqual.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAddressEqual = void 0;
    var address_js_1 = require_address();
    var isAddress_js_1 = require_isAddress();
    function isAddressEqual(a, b) {
      if (!(0, isAddress_js_1.isAddress)(a))
        throw new address_js_1.InvalidAddressError({ address: a });
      if (!(0, isAddress_js_1.isAddress)(b))
        throw new address_js_1.InvalidAddressError({ address: b });
      return a.toLowerCase() === b.toLowerCase();
    }
    exports.isAddressEqual = isAddressEqual;
  }
});

// node_modules/viem/_cjs/utils/ccip.js
var require_ccip2 = __commonJS({
  "node_modules/viem/_cjs/utils/ccip.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ccipFetch = exports.offchainLookup = exports.offchainLookupAbiItem = exports.offchainLookupSignature = void 0;
    var call_js_1 = require_call();
    var ccip_js_1 = require_ccip();
    var request_js_1 = require_request();
    var decodeErrorResult_js_1 = require_decodeErrorResult();
    var encodeAbiParameters_js_1 = require_encodeAbiParameters();
    var isAddressEqual_js_1 = require_isAddressEqual();
    var concat_js_1 = require_concat();
    var isHex_js_1 = require_isHex();
    var stringify_js_1 = require_stringify();
    exports.offchainLookupSignature = "0x556f1830";
    exports.offchainLookupAbiItem = {
      name: "OffchainLookup",
      type: "error",
      inputs: [
        {
          name: "sender",
          type: "address"
        },
        {
          name: "urls",
          type: "string[]"
        },
        {
          name: "callData",
          type: "bytes"
        },
        {
          name: "callbackFunction",
          type: "bytes4"
        },
        {
          name: "extraData",
          type: "bytes"
        }
      ]
    };
    async function offchainLookup(client, { blockNumber, blockTag, data, to }) {
      const { args } = (0, decodeErrorResult_js_1.decodeErrorResult)({
        data,
        abi: [exports.offchainLookupAbiItem]
      });
      const [sender, urls, callData, callbackSelector, extraData] = args;
      try {
        if (!(0, isAddressEqual_js_1.isAddressEqual)(to, sender))
          throw new ccip_js_1.OffchainLookupSenderMismatchError({ sender, to });
        const result = await ccipFetch({ data: callData, sender, urls });
        const { data: data_ } = await (0, call_js_1.call)(client, {
          blockNumber,
          blockTag,
          data: (0, concat_js_1.concat)([
            callbackSelector,
            (0, encodeAbiParameters_js_1.encodeAbiParameters)([{ type: "bytes" }, { type: "bytes" }], [result, extraData])
          ]),
          to
        });
        return data_;
      } catch (err) {
        throw new ccip_js_1.OffchainLookupError({
          callbackSelector,
          cause: err,
          data,
          extraData,
          sender,
          urls
        });
      }
    }
    exports.offchainLookup = offchainLookup;
    async function ccipFetch({ data, sender, urls }) {
      let error = new Error("An unknown error occurred.");
      for (let i = 0; i < urls.length; i++) {
        const url = urls[i];
        const method = url.includes("{sender}") || url.includes("{data}") ? "GET" : "POST";
        const body = method === "POST" ? { data, sender } : void 0;
        try {
          const response = await fetch(url.replace("{sender}", sender).replace("{data}", data), {
            body: JSON.stringify(body),
            method
          });
          let result;
          if (response.headers.get("Content-Type")?.startsWith("application/json")) {
            result = (await response.json()).data;
          } else {
            result = await response.text();
          }
          if (!response.ok) {
            error = new request_js_1.HttpRequestError({
              body,
              details: (0, stringify_js_1.stringify)(result.error) || response.statusText,
              headers: response.headers,
              status: response.status,
              url
            });
            continue;
          }
          if (!(0, isHex_js_1.isHex)(result)) {
            error = new ccip_js_1.OffchainLookupResponseMalformedError({
              result,
              url
            });
            continue;
          }
          return result;
        } catch (err) {
          error = new request_js_1.HttpRequestError({
            body,
            details: err.message,
            url
          });
        }
      }
      throw error;
    }
    exports.ccipFetch = ccipFetch;
  }
});

// node_modules/viem/_cjs/actions/public/call.js
var require_call = __commonJS({
  "node_modules/viem/_cjs/actions/public/call.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRevertErrorData = exports.call = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var abis_js_1 = require_abis();
    var contract_js_1 = require_contract2();
    var base_js_1 = require_base();
    var chain_js_1 = require_chain();
    var contract_js_2 = require_contract();
    var decodeFunctionResult_js_1 = require_decodeFunctionResult();
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    var chain_js_2 = require_chain2();
    var toHex_js_1 = require_toHex();
    var getCallError_js_1 = require_getCallError();
    var extract_js_1 = require_extract();
    var transactionRequest_js_1 = require_transactionRequest();
    var createBatchScheduler_js_1 = require_createBatchScheduler();
    var assertRequest_js_1 = require_assertRequest();
    async function call(client, args) {
      const { account: account_ = client.account, batch = Boolean(client.batch?.multicall), blockNumber, blockTag = "latest", accessList, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = args;
      const account = account_ ? (0, parseAccount_js_1.parseAccount)(account_) : void 0;
      try {
        (0, assertRequest_js_1.assertRequest)(args);
        const blockNumberHex = blockNumber ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
        const block = blockNumberHex || blockTag;
        const format = client.chain?.formatters?.transactionRequest?.format || transactionRequest_js_1.formatTransactionRequest;
        const request = format({
          ...(0, extract_js_1.extract)(rest, { format }),
          from: account?.address,
          accessList,
          data,
          gas,
          gasPrice,
          maxFeePerGas,
          maxPriorityFeePerGas,
          nonce,
          to,
          value
        });
        if (batch && shouldPerformMulticall({ request })) {
          try {
            return await scheduleMulticall(client, {
              ...request,
              blockNumber,
              blockTag
            });
          } catch (err) {
            if (!(err instanceof chain_js_1.ClientChainNotConfiguredError) && !(err instanceof chain_js_1.ChainDoesNotSupportContract))
              throw err;
          }
        }
        const response = await client.request({
          method: "eth_call",
          params: block ? [request, block] : [request]
        });
        if (response === "0x")
          return { data: void 0 };
        return { data: response };
      } catch (err) {
        const data2 = getRevertErrorData(err);
        const { offchainLookup, offchainLookupSignature } = await Promise.resolve().then(() => require_ccip2());
        if (data2?.slice(0, 10) === offchainLookupSignature && to) {
          return { data: await offchainLookup(client, { data: data2, to }) };
        }
        throw (0, getCallError_js_1.getCallError)(err, {
          ...args,
          account,
          chain: client.chain
        });
      }
    }
    exports.call = call;
    function shouldPerformMulticall({ request }) {
      const { data, to, ...request_ } = request;
      if (!data)
        return false;
      if (data.startsWith(contract_js_1.aggregate3Signature))
        return false;
      if (!to)
        return false;
      if (Object.values(request_).filter((x) => typeof x !== "undefined").length > 0)
        return false;
      return true;
    }
    async function scheduleMulticall(client, args) {
      const { batchSize = 1024, wait = 0 } = typeof client.batch?.multicall === "object" ? client.batch.multicall : {};
      const { blockNumber, blockTag = "latest", data, multicallAddress: multicallAddress_, to } = args;
      let multicallAddress = multicallAddress_;
      if (!multicallAddress) {
        if (!client.chain)
          throw new chain_js_1.ClientChainNotConfiguredError();
        multicallAddress = (0, chain_js_2.getChainContractAddress)({
          blockNumber,
          chain: client.chain,
          contract: "multicall3"
        });
      }
      const blockNumberHex = blockNumber ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
      const block = blockNumberHex || blockTag;
      const { schedule } = (0, createBatchScheduler_js_1.createBatchScheduler)({
        id: `${client.uid}.${block}`,
        wait,
        shouldSplitBatch(args2) {
          const size = args2.reduce((size2, { data: data2 }) => size2 + (data2.length - 2), 0);
          return size > batchSize * 2;
        },
        fn: async (requests) => {
          const calls = requests.map((request) => ({
            allowFailure: true,
            callData: request.data,
            target: request.to
          }));
          const calldata = (0, encodeFunctionData_js_1.encodeFunctionData)({
            abi: abis_js_1.multicall3Abi,
            args: [calls],
            functionName: "aggregate3"
          });
          const data2 = await client.request({
            method: "eth_call",
            params: [
              {
                data: calldata,
                to: multicallAddress
              },
              block
            ]
          });
          return (0, decodeFunctionResult_js_1.decodeFunctionResult)({
            abi: abis_js_1.multicall3Abi,
            args: [calls],
            functionName: "aggregate3",
            data: data2 || "0x"
          });
        }
      });
      const [{ returnData, success }] = await schedule({ data, to });
      if (!success)
        throw new contract_js_2.RawContractError({ data: returnData });
      if (returnData === "0x")
        return { data: void 0 };
      return { data: returnData };
    }
    function getRevertErrorData(err) {
      if (!(err instanceof base_js_1.BaseError))
        return void 0;
      const error = err.walk();
      return typeof error.data === "object" ? error.data.data : error.data;
    }
    exports.getRevertErrorData = getRevertErrorData;
  }
});

// node_modules/viem/_cjs/actions/public/readContract.js
var require_readContract = __commonJS({
  "node_modules/viem/_cjs/actions/public/readContract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.readContract = void 0;
    var decodeFunctionResult_js_1 = require_decodeFunctionResult();
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    var getContractError_js_1 = require_getContractError();
    var call_js_1 = require_call();
    async function readContract(client, { abi, address, args, functionName, ...callRequest }) {
      const calldata = (0, encodeFunctionData_js_1.encodeFunctionData)({
        abi,
        args,
        functionName
      });
      try {
        const { data } = await (0, call_js_1.call)(client, {
          data: calldata,
          to: address,
          ...callRequest
        });
        return (0, decodeFunctionResult_js_1.decodeFunctionResult)({
          abi,
          args,
          functionName,
          data: data || "0x"
        });
      } catch (err) {
        throw (0, getContractError_js_1.getContractError)(err, {
          abi,
          address,
          args,
          docsPath: "/docs/contract/readContract",
          functionName
        });
      }
    }
    exports.readContract = readContract;
  }
});

// node_modules/viem/_cjs/actions/public/simulateContract.js
var require_simulateContract = __commonJS({
  "node_modules/viem/_cjs/actions/public/simulateContract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.simulateContract = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var decodeFunctionResult_js_1 = require_decodeFunctionResult();
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    var getContractError_js_1 = require_getContractError();
    var call_js_1 = require_call();
    async function simulateContract(client, { abi, address, args, dataSuffix, functionName, ...callRequest }) {
      const account = callRequest.account ? (0, parseAccount_js_1.parseAccount)(callRequest.account) : void 0;
      const calldata = (0, encodeFunctionData_js_1.encodeFunctionData)({
        abi,
        args,
        functionName
      });
      try {
        const { data } = await (0, call_js_1.call)(client, {
          batch: false,
          data: `${calldata}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
          to: address,
          ...callRequest
        });
        const result = (0, decodeFunctionResult_js_1.decodeFunctionResult)({
          abi,
          args,
          functionName,
          data: data || "0x"
        });
        return {
          result,
          request: {
            abi,
            address,
            args,
            dataSuffix,
            functionName,
            ...callRequest
          }
        };
      } catch (err) {
        throw (0, getContractError_js_1.getContractError)(err, {
          abi,
          address,
          args,
          docsPath: "/docs/contract/simulateContract",
          functionName,
          sender: account?.address
        });
      }
    }
    exports.simulateContract = simulateContract;
  }
});

// node_modules/viem/_cjs/utils/observe.js
var require_observe = __commonJS({
  "node_modules/viem/_cjs/utils/observe.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.observe = exports.cleanupCache = exports.listenersCache = void 0;
    exports.listenersCache = /* @__PURE__ */ new Map();
    exports.cleanupCache = /* @__PURE__ */ new Map();
    var callbackCount = 0;
    function observe(observerId, callbacks, fn) {
      const callbackId = ++callbackCount;
      const getListeners = () => exports.listenersCache.get(observerId) || [];
      const unsubscribe = () => {
        const listeners2 = getListeners();
        exports.listenersCache.set(observerId, listeners2.filter((cb) => cb.id !== callbackId));
      };
      const unwatch = () => {
        const cleanup2 = exports.cleanupCache.get(observerId);
        if (getListeners().length === 1 && cleanup2)
          cleanup2();
        unsubscribe();
      };
      const listeners = getListeners();
      exports.listenersCache.set(observerId, [
        ...listeners,
        { id: callbackId, fns: callbacks }
      ]);
      if (listeners && listeners.length > 0)
        return unwatch;
      const emit = {};
      for (const key in callbacks) {
        emit[key] = (...args) => {
          const listeners2 = getListeners();
          if (listeners2.length === 0)
            return;
          listeners2.forEach((listener) => listener.fns[key]?.(...args));
        };
      }
      const cleanup = fn(emit);
      if (typeof cleanup === "function")
        exports.cleanupCache.set(observerId, cleanup);
      return unwatch;
    }
    exports.observe = observe;
  }
});

// node_modules/viem/_cjs/utils/wait.js
var require_wait = __commonJS({
  "node_modules/viem/_cjs/utils/wait.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wait = void 0;
    async function wait(time) {
      return new Promise((res) => setTimeout(res, time));
    }
    exports.wait = wait;
  }
});

// node_modules/viem/_cjs/utils/poll.js
var require_poll = __commonJS({
  "node_modules/viem/_cjs/utils/poll.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.poll = void 0;
    var wait_js_1 = require_wait();
    function poll(fn, { emitOnBegin, initialWaitTime, interval }) {
      let active = true;
      const unwatch = () => active = false;
      const watch = async () => {
        let data = void 0;
        if (emitOnBegin)
          data = await fn({ unpoll: unwatch });
        const initialWait = await initialWaitTime?.(data) ?? interval;
        await (0, wait_js_1.wait)(initialWait);
        const poll2 = async () => {
          if (!active)
            return;
          await fn({ unpoll: unwatch });
          await (0, wait_js_1.wait)(interval);
          poll2();
        };
        poll2();
      };
      watch();
      return unwatch;
    }
    exports.poll = poll;
  }
});

// node_modules/viem/_cjs/utils/abi/decodeEventLog.js
var require_decodeEventLog = __commonJS({
  "node_modules/viem/_cjs/utils/abi/decodeEventLog.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeEventLog = void 0;
    var abi_js_1 = require_abi();
    var getEventSelector_js_1 = require_getEventSelector();
    var decodeAbiParameters_js_1 = require_decodeAbiParameters();
    var formatAbiItem_js_1 = require_formatAbiItem2();
    var docsPath = "/docs/contract/decodeEventLog";
    function decodeEventLog({ abi, data, strict: strict_, topics }) {
      const strict = strict_ ?? true;
      const [signature, ...argTopics] = topics;
      if (!signature)
        throw new abi_js_1.AbiEventSignatureEmptyTopicsError({
          docsPath
        });
      const abiItem = abi.find((x) => x.type === "event" && signature === (0, getEventSelector_js_1.getEventSelector)((0, formatAbiItem_js_1.formatAbiItem)(x)));
      if (!(abiItem && "name" in abiItem) || abiItem.type !== "event")
        throw new abi_js_1.AbiEventSignatureNotFoundError(signature, {
          docsPath
        });
      const { name, inputs } = abiItem;
      const isUnnamed = inputs?.some((x) => !("name" in x && x.name));
      let args = isUnnamed ? [] : {};
      const indexedInputs = inputs.filter((x) => "indexed" in x && x.indexed);
      if (argTopics.length > 0) {
        for (let i = 0; i < indexedInputs.length; i++) {
          const param = indexedInputs[i];
          const topic = argTopics[i];
          if (!topic)
            throw new abi_js_1.DecodeLogTopicsMismatch({
              abiItem,
              param
            });
          args[param.name || i] = decodeTopic({ param, value: topic });
        }
      }
      const nonIndexedInputs = inputs.filter((x) => !("indexed" in x && x.indexed));
      if (nonIndexedInputs.length > 0) {
        if (data && data !== "0x") {
          try {
            const decodedData = (0, decodeAbiParameters_js_1.decodeAbiParameters)(nonIndexedInputs, data);
            if (decodedData) {
              if (isUnnamed)
                args = [...args, ...decodedData];
              else {
                for (let i = 0; i < nonIndexedInputs.length; i++) {
                  args[nonIndexedInputs[i].name] = decodedData[i];
                }
              }
            }
          } catch (err) {
            if (strict) {
              if (err instanceof abi_js_1.AbiDecodingDataSizeTooSmallError)
                throw new abi_js_1.DecodeLogDataMismatch({
                  abiItem,
                  data: err.data,
                  params: err.params,
                  size: err.size
                });
              throw err;
            }
          }
        } else if (strict) {
          throw new abi_js_1.DecodeLogDataMismatch({
            abiItem,
            data: "0x",
            params: nonIndexedInputs,
            size: 0
          });
        }
      }
      return {
        eventName: name,
        args: Object.values(args).length > 0 ? args : void 0
      };
    }
    exports.decodeEventLog = decodeEventLog;
    function decodeTopic({ param, value }) {
      if (param.type === "string" || param.type === "bytes" || param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
        return value;
      const decodedArg = (0, decodeAbiParameters_js_1.decodeAbiParameters)([param], value) || [];
      return decodedArg[0];
    }
  }
});

// node_modules/viem/_cjs/utils/promise/withCache.js
var require_withCache = __commonJS({
  "node_modules/viem/_cjs/utils/promise/withCache.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.withCache = exports.getCache = exports.responseCache = exports.promiseCache = void 0;
    exports.promiseCache = /* @__PURE__ */ new Map();
    exports.responseCache = /* @__PURE__ */ new Map();
    function getCache(cacheKey) {
      const buildCache = (cacheKey2, cache) => ({
        clear: () => cache.delete(cacheKey2),
        get: () => cache.get(cacheKey2),
        set: (data) => cache.set(cacheKey2, data)
      });
      const promise = buildCache(cacheKey, exports.promiseCache);
      const response = buildCache(cacheKey, exports.responseCache);
      return {
        clear: () => {
          promise.clear();
          response.clear();
        },
        promise,
        response
      };
    }
    exports.getCache = getCache;
    async function withCache(fn, { cacheKey, cacheTime = Infinity }) {
      const cache = getCache(cacheKey);
      const response = cache.response.get();
      if (response && cacheTime > 0) {
        const age = (/* @__PURE__ */ new Date()).getTime() - response.created.getTime();
        if (age < cacheTime)
          return response.data;
      }
      let promise = cache.promise.get();
      if (!promise) {
        promise = fn();
        cache.promise.set(promise);
      }
      try {
        const data = await promise;
        cache.response.set({ created: /* @__PURE__ */ new Date(), data });
        return data;
      } finally {
        cache.promise.clear();
      }
    }
    exports.withCache = withCache;
  }
});

// node_modules/viem/_cjs/actions/public/getBlockNumber.js
var require_getBlockNumber = __commonJS({
  "node_modules/viem/_cjs/actions/public/getBlockNumber.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getBlockNumber = exports.getBlockNumberCache = void 0;
    var withCache_js_1 = require_withCache();
    var cacheKey = (id) => `blockNumber.${id}`;
    function getBlockNumberCache(id) {
      return (0, withCache_js_1.getCache)(cacheKey(id));
    }
    exports.getBlockNumberCache = getBlockNumberCache;
    async function getBlockNumber(client, { cacheTime = client.cacheTime, maxAge } = {}) {
      const blockNumberHex = await (0, withCache_js_1.withCache)(() => client.request({
        method: "eth_blockNumber"
      }), { cacheKey: cacheKey(client.uid), cacheTime: maxAge ?? cacheTime });
      return BigInt(blockNumberHex);
    }
    exports.getBlockNumber = getBlockNumber;
  }
});

// node_modules/viem/_cjs/actions/public/getFilterChanges.js
var require_getFilterChanges = __commonJS({
  "node_modules/viem/_cjs/actions/public/getFilterChanges.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFilterChanges = void 0;
    var abi_js_1 = require_abi();
    var decodeEventLog_js_1 = require_decodeEventLog();
    var log_js_1 = require_log();
    async function getFilterChanges(_client, { filter }) {
      const strict = "strict" in filter && filter.strict;
      const logs = await filter.request({
        method: "eth_getFilterChanges",
        params: [filter.id]
      });
      return logs.map((log) => {
        if (typeof log === "string")
          return log;
        try {
          const { eventName, args } = "abi" in filter && filter.abi ? (0, decodeEventLog_js_1.decodeEventLog)({
            abi: filter.abi,
            data: log.data,
            topics: log.topics,
            strict
          }) : { eventName: void 0, args: void 0 };
          return (0, log_js_1.formatLog)(log, { args, eventName });
        } catch (err) {
          let eventName;
          let isUnnamed;
          if (err instanceof abi_js_1.DecodeLogDataMismatch || err instanceof abi_js_1.DecodeLogTopicsMismatch) {
            if ("strict" in filter && filter.strict)
              return;
            eventName = err.abiItem.name;
            isUnnamed = err.abiItem.inputs?.some((x) => !("name" in x && x.name));
          }
          return (0, log_js_1.formatLog)(log, { args: isUnnamed ? [] : {}, eventName });
        }
      }).filter(Boolean);
    }
    exports.getFilterChanges = getFilterChanges;
  }
});

// node_modules/viem/_cjs/actions/public/getLogs.js
var require_getLogs = __commonJS({
  "node_modules/viem/_cjs/actions/public/getLogs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLogs = void 0;
    var abi_js_1 = require_abi();
    var decodeEventLog_js_1 = require_decodeEventLog();
    var encodeEventTopics_js_1 = require_encodeEventTopics();
    var toHex_js_1 = require_toHex();
    var log_js_1 = require_log();
    async function getLogs(client, { address, blockHash, fromBlock, toBlock, event, events: events_, args, strict: strict_ } = {}) {
      const strict = strict_ ?? false;
      const events = events_ ?? (event ? [event] : void 0);
      let topics = [];
      if (events) {
        topics = [
          events.flatMap((event2) => (0, encodeEventTopics_js_1.encodeEventTopics)({
            abi: [event2],
            eventName: event2.name,
            args
          }))
        ];
        if (event)
          topics = topics[0];
      }
      let logs;
      if (blockHash) {
        logs = await client.request({
          method: "eth_getLogs",
          params: [{ address, topics, blockHash }]
        });
      } else {
        logs = await client.request({
          method: "eth_getLogs",
          params: [
            {
              address,
              topics,
              fromBlock: typeof fromBlock === "bigint" ? (0, toHex_js_1.numberToHex)(fromBlock) : fromBlock,
              toBlock: typeof toBlock === "bigint" ? (0, toHex_js_1.numberToHex)(toBlock) : toBlock
            }
          ]
        });
      }
      return logs.map((log) => {
        try {
          const { eventName, args: args2 } = events ? (0, decodeEventLog_js_1.decodeEventLog)({
            abi: events,
            data: log.data,
            topics: log.topics,
            strict
          }) : { eventName: void 0, args: void 0 };
          return (0, log_js_1.formatLog)(log, { args: args2, eventName });
        } catch (err) {
          let eventName;
          let isUnnamed;
          if (err instanceof abi_js_1.DecodeLogDataMismatch || err instanceof abi_js_1.DecodeLogTopicsMismatch) {
            if (strict)
              return;
            eventName = err.abiItem.name;
            isUnnamed = err.abiItem.inputs?.some((x) => !("name" in x && x.name));
          }
          return (0, log_js_1.formatLog)(log, { args: isUnnamed ? [] : {}, eventName });
        }
      }).filter(Boolean);
    }
    exports.getLogs = getLogs;
  }
});

// node_modules/viem/_cjs/actions/public/uninstallFilter.js
var require_uninstallFilter = __commonJS({
  "node_modules/viem/_cjs/actions/public/uninstallFilter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uninstallFilter = void 0;
    async function uninstallFilter(_client, { filter }) {
      return filter.request({
        method: "eth_uninstallFilter",
        params: [filter.id]
      });
    }
    exports.uninstallFilter = uninstallFilter;
  }
});

// node_modules/viem/_cjs/actions/public/watchContractEvent.js
var require_watchContractEvent = __commonJS({
  "node_modules/viem/_cjs/actions/public/watchContractEvent.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.watchContractEvent = void 0;
    var getAbiItem_js_1 = require_getAbiItem();
    var observe_js_1 = require_observe();
    var poll_js_1 = require_poll();
    var stringify_js_1 = require_stringify();
    var abi_js_1 = require_abi();
    var rpc_js_1 = require_rpc();
    var decodeEventLog_js_1 = require_decodeEventLog();
    var encodeEventTopics_js_1 = require_encodeEventTopics();
    var log_js_1 = require_log();
    var createContractEventFilter_js_1 = require_createContractEventFilter();
    var getBlockNumber_js_1 = require_getBlockNumber();
    var getFilterChanges_js_1 = require_getFilterChanges();
    var getLogs_js_1 = require_getLogs();
    var uninstallFilter_js_1 = require_uninstallFilter();
    function watchContractEvent(client, { abi, address, args, batch = true, eventName, onError, onLogs, poll: poll_, pollingInterval = client.pollingInterval, strict: strict_ }) {
      const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
      const pollContractEvent = () => {
        const observerId = (0, stringify_js_1.stringify)([
          "watchContractEvent",
          address,
          args,
          batch,
          client.uid,
          eventName,
          pollingInterval
        ]);
        const strict = strict_ ?? false;
        return (0, observe_js_1.observe)(observerId, { onLogs, onError }, (emit) => {
          let previousBlockNumber;
          let filter;
          let initialized = false;
          const unwatch = (0, poll_js_1.poll)(async () => {
            if (!initialized) {
              try {
                filter = await (0, createContractEventFilter_js_1.createContractEventFilter)(client, {
                  abi,
                  address,
                  args,
                  eventName,
                  strict
                });
              } catch {
              }
              initialized = true;
              return;
            }
            try {
              let logs;
              if (filter) {
                logs = await (0, getFilterChanges_js_1.getFilterChanges)(client, { filter });
              } else {
                const blockNumber = await (0, getBlockNumber_js_1.getBlockNumber)(client);
                if (previousBlockNumber && previousBlockNumber !== blockNumber) {
                  logs = await (0, getLogs_js_1.getLogs)(client, {
                    address,
                    args,
                    fromBlock: previousBlockNumber + 1n,
                    toBlock: blockNumber,
                    event: (0, getAbiItem_js_1.getAbiItem)({
                      abi,
                      name: eventName
                    })
                  });
                } else {
                  logs = [];
                }
                previousBlockNumber = blockNumber;
              }
              if (logs.length === 0)
                return;
              if (batch)
                emit.onLogs(logs);
              else
                logs.forEach((log) => emit.onLogs([log]));
            } catch (err) {
              if (filter && err instanceof rpc_js_1.InvalidInputRpcError)
                initialized = false;
              emit.onError?.(err);
            }
          }, {
            emitOnBegin: true,
            interval: pollingInterval
          });
          return async () => {
            if (filter)
              await (0, uninstallFilter_js_1.uninstallFilter)(client, { filter });
            unwatch();
          };
        });
      };
      const subscribeContractEvent = () => {
        let active = true;
        let unsubscribe = () => active = false;
        (async () => {
          try {
            const topics = eventName ? (0, encodeEventTopics_js_1.encodeEventTopics)({
              abi,
              eventName,
              args
            }) : [];
            const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
              params: ["logs", { address, topics }],
              onData(data) {
                if (!active)
                  return;
                const log = data.result;
                try {
                  const { eventName: eventName2, args: args2 } = (0, decodeEventLog_js_1.decodeEventLog)({
                    abi,
                    data: log.data,
                    topics: log.topics,
                    strict: strict_
                  });
                  const formatted = (0, log_js_1.formatLog)(log, {
                    args: args2,
                    eventName: eventName2
                  });
                  onLogs([formatted]);
                } catch (err) {
                  let eventName2;
                  let isUnnamed;
                  if (err instanceof abi_js_1.DecodeLogDataMismatch || err instanceof abi_js_1.DecodeLogTopicsMismatch) {
                    if (strict_)
                      return;
                    eventName2 = err.abiItem.name;
                    isUnnamed = err.abiItem.inputs?.some((x) => !("name" in x && x.name));
                  }
                  const formatted = (0, log_js_1.formatLog)(log, {
                    args: isUnnamed ? [] : {},
                    eventName: eventName2
                  });
                  onLogs([formatted]);
                }
              },
              onError(error) {
                onError?.(error);
              }
            });
            unsubscribe = unsubscribe_;
            if (!active)
              unsubscribe();
          } catch (err) {
            onError?.(err);
          }
        })();
        return unsubscribe;
      };
      return enablePolling ? pollContractEvent() : subscribeContractEvent();
    }
    exports.watchContractEvent = watchContractEvent;
  }
});

// node_modules/viem/_cjs/utils/errors/getTransactionError.js
var require_getTransactionError = __commonJS({
  "node_modules/viem/_cjs/utils/errors/getTransactionError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTransactionError = void 0;
    var node_js_1 = require_node();
    var transaction_js_1 = require_transaction2();
    var getNodeError_js_1 = require_getNodeError();
    function getTransactionError(err, { docsPath, ...args }) {
      let cause = (0, getNodeError_js_1.getNodeError)(err, args);
      if (cause instanceof node_js_1.UnknownNodeError)
        cause = err;
      return new transaction_js_1.TransactionExecutionError(cause, {
        docsPath,
        ...args
      });
    }
    exports.getTransactionError = getTransactionError;
  }
});

// node_modules/viem/_cjs/actions/public/getChainId.js
var require_getChainId = __commonJS({
  "node_modules/viem/_cjs/actions/public/getChainId.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getChainId = void 0;
    var fromHex_js_1 = require_fromHex();
    async function getChainId(client) {
      const chainIdHex = await client.request({
        method: "eth_chainId"
      });
      return (0, fromHex_js_1.hexToNumber)(chainIdHex);
    }
    exports.getChainId = getChainId;
  }
});

// node_modules/viem/_cjs/actions/wallet/sendRawTransaction.js
var require_sendRawTransaction = __commonJS({
  "node_modules/viem/_cjs/actions/wallet/sendRawTransaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sendRawTransaction = void 0;
    async function sendRawTransaction(client, { serializedTransaction }) {
      return client.request({
        method: "eth_sendRawTransaction",
        params: [serializedTransaction]
      });
    }
    exports.sendRawTransaction = sendRawTransaction;
  }
});

// node_modules/viem/_cjs/actions/wallet/sendTransaction.js
var require_sendTransaction = __commonJS({
  "node_modules/viem/_cjs/actions/wallet/sendTransaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sendTransaction = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var account_js_1 = require_account();
    var chain_js_1 = require_chain2();
    var getTransactionError_js_1 = require_getTransactionError();
    var extract_js_1 = require_extract();
    var transactionRequest_js_1 = require_transactionRequest();
    var assertRequest_js_1 = require_assertRequest();
    var getChainId_js_1 = require_getChainId();
    var prepareTransactionRequest_js_1 = require_prepareTransactionRequest();
    var sendRawTransaction_js_1 = require_sendRawTransaction();
    async function sendTransaction(client, args) {
      const { account: account_ = client.account, chain = client.chain, accessList, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = args;
      if (!account_)
        throw new account_js_1.AccountNotFoundError({
          docsPath: "/docs/actions/wallet/sendTransaction"
        });
      const account = (0, parseAccount_js_1.parseAccount)(account_);
      try {
        (0, assertRequest_js_1.assertRequest)(args);
        let chainId;
        if (chain !== null) {
          chainId = await (0, getChainId_js_1.getChainId)(client);
          (0, chain_js_1.assertCurrentChain)({
            currentChainId: chainId,
            chain
          });
        }
        if (account.type === "local") {
          const request2 = await (0, prepareTransactionRequest_js_1.prepareTransactionRequest)(client, {
            account,
            accessList,
            chain,
            data,
            gas,
            gasPrice,
            maxFeePerGas,
            maxPriorityFeePerGas,
            nonce,
            to,
            value,
            ...rest
          });
          if (!chainId)
            chainId = await (0, getChainId_js_1.getChainId)(client);
          const serializer = chain?.serializers?.transaction;
          const serializedTransaction = await account.signTransaction({
            ...request2,
            chainId
          }, { serializer });
          return await (0, sendRawTransaction_js_1.sendRawTransaction)(client, {
            serializedTransaction
          });
        }
        const format = chain?.formatters?.transactionRequest?.format || transactionRequest_js_1.formatTransactionRequest;
        const request = format({
          ...(0, extract_js_1.extract)(rest, { format }),
          accessList,
          data,
          from: account.address,
          gas,
          gasPrice,
          maxFeePerGas,
          maxPriorityFeePerGas,
          nonce,
          to,
          value
        });
        return await client.request({
          method: "eth_sendTransaction",
          params: [request]
        });
      } catch (err) {
        throw (0, getTransactionError_js_1.getTransactionError)(err, {
          ...args,
          account,
          chain: args.chain || void 0
        });
      }
    }
    exports.sendTransaction = sendTransaction;
  }
});

// node_modules/viem/_cjs/actions/wallet/writeContract.js
var require_writeContract = __commonJS({
  "node_modules/viem/_cjs/actions/wallet/writeContract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.writeContract = void 0;
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    var sendTransaction_js_1 = require_sendTransaction();
    async function writeContract(client, { abi, address, args, dataSuffix, functionName, ...request }) {
      const data = (0, encodeFunctionData_js_1.encodeFunctionData)({
        abi,
        args,
        functionName
      });
      const hash = await (0, sendTransaction_js_1.sendTransaction)(client, {
        data: `${data}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
        to: address,
        ...request
      });
      return hash;
    }
    exports.writeContract = writeContract;
  }
});

// node_modules/viem/_cjs/actions/getContract.js
var require_getContract = __commonJS({
  "node_modules/viem/_cjs/actions/getContract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEventParameters = exports.getFunctionParameters = exports.getContract = void 0;
    var createContractEventFilter_js_1 = require_createContractEventFilter();
    var estimateContractGas_js_1 = require_estimateContractGas();
    var readContract_js_1 = require_readContract();
    var simulateContract_js_1 = require_simulateContract();
    var watchContractEvent_js_1 = require_watchContractEvent();
    var writeContract_js_1 = require_writeContract();
    function getContract({ abi, address, publicClient, walletClient }) {
      const hasPublicClient = publicClient !== void 0 && publicClient !== null;
      const hasWalletClient = walletClient !== void 0 && walletClient !== null;
      const contract = {};
      let hasReadFunction = false;
      let hasWriteFunction = false;
      let hasEvent = false;
      for (const item of abi) {
        if (item.type === "function")
          if (item.stateMutability === "view" || item.stateMutability === "pure")
            hasReadFunction = true;
          else
            hasWriteFunction = true;
        else if (item.type === "event")
          hasEvent = true;
        if (hasReadFunction && hasWriteFunction && hasEvent)
          break;
      }
      if (hasPublicClient) {
        if (hasReadFunction)
          contract.read = new Proxy({}, {
            get(_, functionName) {
              return (...parameters) => {
                const { args, options } = getFunctionParameters(parameters);
                return (0, readContract_js_1.readContract)(publicClient, {
                  abi,
                  address,
                  functionName,
                  args,
                  ...options
                });
              };
            }
          });
        if (hasWriteFunction)
          contract.simulate = new Proxy({}, {
            get(_, functionName) {
              return (...parameters) => {
                const { args, options } = getFunctionParameters(parameters);
                return (0, simulateContract_js_1.simulateContract)(publicClient, {
                  abi,
                  address,
                  functionName,
                  args,
                  ...options
                });
              };
            }
          });
        if (hasEvent) {
          contract.createEventFilter = new Proxy({}, {
            get(_, eventName) {
              return (...parameters) => {
                const abiEvent = abi.find((x) => x.type === "event" && x.name === eventName);
                const { args, options } = getEventParameters(parameters, abiEvent);
                return (0, createContractEventFilter_js_1.createContractEventFilter)(publicClient, {
                  abi,
                  address,
                  eventName,
                  args,
                  ...options
                });
              };
            }
          });
          contract.watchEvent = new Proxy({}, {
            get(_, eventName) {
              return (...parameters) => {
                const abiEvent = abi.find((x) => x.type === "event" && x.name === eventName);
                const { args, options } = getEventParameters(parameters, abiEvent);
                return (0, watchContractEvent_js_1.watchContractEvent)(publicClient, {
                  abi,
                  address,
                  eventName,
                  args,
                  ...options
                });
              };
            }
          });
        }
      }
      if (hasWalletClient) {
        if (hasWriteFunction)
          contract.write = new Proxy({}, {
            get(_, functionName) {
              return (...parameters) => {
                const { args, options } = getFunctionParameters(parameters);
                return (0, writeContract_js_1.writeContract)(walletClient, {
                  abi,
                  address,
                  functionName,
                  args,
                  ...options
                });
              };
            }
          });
      }
      if (hasPublicClient || hasWalletClient) {
        if (hasWriteFunction)
          contract.estimateGas = new Proxy({}, {
            get(_, functionName) {
              return (...parameters) => {
                const { args, options } = getFunctionParameters(parameters);
                const client = publicClient ?? walletClient;
                return (0, estimateContractGas_js_1.estimateContractGas)(client, {
                  abi,
                  address,
                  functionName,
                  args,
                  ...options,
                  account: options.account ?? walletClient.account
                });
              };
            }
          });
      }
      contract.address = address;
      contract.abi = abi;
      return contract;
    }
    exports.getContract = getContract;
    function getFunctionParameters(values) {
      const hasArgs = values.length && Array.isArray(values[0]);
      const args = hasArgs ? values[0] : [];
      const options = (hasArgs ? values[1] : values[0]) ?? {};
      return { args, options };
    }
    exports.getFunctionParameters = getFunctionParameters;
    function getEventParameters(values, abiEvent) {
      let hasArgs = false;
      if (Array.isArray(values[0]))
        hasArgs = true;
      else if (values.length === 1) {
        hasArgs = abiEvent.inputs.some((x) => x.indexed);
      } else if (values.length === 2) {
        hasArgs = true;
      }
      const args = hasArgs ? values[0] : void 0;
      const options = (hasArgs ? values[1] : values[0]) ?? {};
      return { args, options };
    }
    exports.getEventParameters = getEventParameters;
  }
});

// node_modules/viem/_cjs/accounts/utils/publicKeyToAddress.js
var require_publicKeyToAddress = __commonJS({
  "node_modules/viem/_cjs/accounts/utils/publicKeyToAddress.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.publicKeyToAddress = void 0;
    var getAddress_js_1 = require_getAddress();
    var keccak256_js_1 = require_keccak256();
    function publicKeyToAddress(publicKey) {
      const address = (0, keccak256_js_1.keccak256)(`0x${publicKey.substring(4)}`).substring(26);
      return (0, getAddress_js_1.checksumAddress)(`0x${address}`);
    }
    exports.publicKeyToAddress = publicKeyToAddress;
  }
});

// node_modules/viem/_cjs/utils/accounts.js
var require_accounts = __commonJS({
  "node_modules/viem/_cjs/utils/accounts.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.publicKeyToAddress = exports.parseAccount = void 0;
    var parseAccount_js_1 = require_parseAccount();
    Object.defineProperty(exports, "parseAccount", { enumerable: true, get: function() {
      return parseAccount_js_1.parseAccount;
    } });
    var publicKeyToAddress_js_1 = require_publicKeyToAddress();
    Object.defineProperty(exports, "publicKeyToAddress", { enumerable: true, get: function() {
      return publicKeyToAddress_js_1.publicKeyToAddress;
    } });
  }
});

// node_modules/viem/_cjs/utils/uid.js
var require_uid = __commonJS({
  "node_modules/viem/_cjs/utils/uid.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uid = void 0;
    var size = 256;
    var index = size;
    var buffer;
    function uid(length = 11) {
      if (!buffer || index + length > size * 2) {
        buffer = "";
        index = 0;
        for (let i = 0; i < size; i++) {
          buffer += (256 + Math.random() * 256 | 0).toString(16).substring(1);
        }
      }
      return buffer.substring(index, index++ + length);
    }
    exports.uid = uid;
  }
});

// node_modules/viem/_cjs/clients/createClient.js
var require_createClient = __commonJS({
  "node_modules/viem/_cjs/clients/createClient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createClient = void 0;
    var accounts_js_1 = require_accounts();
    var uid_js_1 = require_uid();
    function createClient(parameters) {
      const { batch, cacheTime = parameters.pollingInterval ?? 4e3, key = "base", name = "Base Client", pollingInterval = 4e3, type = "base" } = parameters;
      const chain = parameters.chain;
      const account = parameters.account ? (0, accounts_js_1.parseAccount)(parameters.account) : void 0;
      const { config, request, value } = parameters.transport({
        chain,
        pollingInterval
      });
      const transport = { ...config, ...value };
      const client = {
        account,
        batch,
        cacheTime,
        chain,
        key,
        name,
        pollingInterval,
        request,
        transport,
        type,
        uid: (0, uid_js_1.uid)()
      };
      function extend(base) {
        return (extendFn) => {
          const extended = extendFn(base);
          for (const key2 in client)
            delete extended[key2];
          const combined = { ...base, ...extended };
          return Object.assign(combined, { extend: extend(combined) });
        };
      }
      return Object.assign(client, { extend: extend(client) });
    }
    exports.createClient = createClient;
  }
});

// node_modules/viem/_cjs/utils/promise/withRetry.js
var require_withRetry = __commonJS({
  "node_modules/viem/_cjs/utils/promise/withRetry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.withRetry = void 0;
    var wait_js_1 = require_wait();
    function withRetry(fn, { delay: delay_ = 100, retryCount = 2, shouldRetry = () => true } = {}) {
      return new Promise((resolve, reject) => {
        const attemptRetry = async ({ count = 0 } = {}) => {
          const retry = async ({ error }) => {
            const delay = typeof delay_ === "function" ? delay_({ count, error }) : delay_;
            if (delay)
              await (0, wait_js_1.wait)(delay);
            attemptRetry({ count: count + 1 });
          };
          try {
            const data = await fn();
            resolve(data);
          } catch (err) {
            if (count < retryCount && await shouldRetry({ count, error: err }))
              return retry({ error: err });
            reject(err);
          }
        };
        attemptRetry();
      });
    }
    exports.withRetry = withRetry;
  }
});

// node_modules/viem/_cjs/utils/buildRequest.js
var require_buildRequest = __commonJS({
  "node_modules/viem/_cjs/utils/buildRequest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.buildRequest = exports.isDeterministicError = void 0;
    var base_js_1 = require_base();
    var request_js_1 = require_request();
    var rpc_js_1 = require_rpc();
    var withRetry_js_1 = require_withRetry();
    var isDeterministicError = (error) => {
      if ("code" in error)
        return error.code !== -1 && error.code !== -32004 && error.code !== -32005 && error.code !== -32042 && error.code !== -32603;
      if (error instanceof request_js_1.HttpRequestError && error.status)
        return error.status !== 403 && error.status !== 408 && error.status !== 413 && error.status !== 429 && error.status !== 500 && error.status !== 502 && error.status !== 503 && error.status !== 504;
      return false;
    };
    exports.isDeterministicError = isDeterministicError;
    function buildRequest(request, { retryDelay = 150, retryCount = 3 } = {}) {
      return async (args) => (0, withRetry_js_1.withRetry)(async () => {
        try {
          return await request(args);
        } catch (err_) {
          const err = err_;
          switch (err.code) {
            case rpc_js_1.ParseRpcError.code:
              throw new rpc_js_1.ParseRpcError(err);
            case rpc_js_1.InvalidRequestRpcError.code:
              throw new rpc_js_1.InvalidRequestRpcError(err);
            case rpc_js_1.MethodNotFoundRpcError.code:
              throw new rpc_js_1.MethodNotFoundRpcError(err);
            case rpc_js_1.InvalidParamsRpcError.code:
              throw new rpc_js_1.InvalidParamsRpcError(err);
            case rpc_js_1.InternalRpcError.code:
              throw new rpc_js_1.InternalRpcError(err);
            case rpc_js_1.InvalidInputRpcError.code:
              throw new rpc_js_1.InvalidInputRpcError(err);
            case rpc_js_1.ResourceNotFoundRpcError.code:
              throw new rpc_js_1.ResourceNotFoundRpcError(err);
            case rpc_js_1.ResourceUnavailableRpcError.code:
              throw new rpc_js_1.ResourceUnavailableRpcError(err);
            case rpc_js_1.TransactionRejectedRpcError.code:
              throw new rpc_js_1.TransactionRejectedRpcError(err);
            case rpc_js_1.MethodNotSupportedRpcError.code:
              throw new rpc_js_1.MethodNotSupportedRpcError(err);
            case rpc_js_1.LimitExceededRpcError.code:
              throw new rpc_js_1.LimitExceededRpcError(err);
            case rpc_js_1.JsonRpcVersionUnsupportedError.code:
              throw new rpc_js_1.JsonRpcVersionUnsupportedError(err);
            case rpc_js_1.UserRejectedRequestError.code:
              throw new rpc_js_1.UserRejectedRequestError(err);
            case rpc_js_1.UnauthorizedProviderError.code:
              throw new rpc_js_1.UnauthorizedProviderError(err);
            case rpc_js_1.UnsupportedProviderMethodError.code:
              throw new rpc_js_1.UnsupportedProviderMethodError(err);
            case rpc_js_1.ProviderDisconnectedError.code:
              throw new rpc_js_1.ProviderDisconnectedError(err);
            case rpc_js_1.ChainDisconnectedError.code:
              throw new rpc_js_1.ChainDisconnectedError(err);
            case rpc_js_1.SwitchChainError.code:
              throw new rpc_js_1.SwitchChainError(err);
            case 5e3:
              throw new rpc_js_1.UserRejectedRequestError(err);
            default:
              if (err_ instanceof base_js_1.BaseError)
                throw err_;
              throw new rpc_js_1.UnknownRpcError(err);
          }
        }
      }, {
        delay: ({ count, error }) => {
          if (error && error instanceof request_js_1.HttpRequestError) {
            const retryAfter = error?.headers?.get("Retry-After");
            if (retryAfter?.match(/\d/))
              return parseInt(retryAfter) * 1e3;
          }
          return ~~(1 << count) * retryDelay;
        },
        retryCount,
        shouldRetry: ({ error }) => !(0, exports.isDeterministicError)(error)
      });
    }
    exports.buildRequest = buildRequest;
  }
});

// node_modules/viem/_cjs/clients/transports/createTransport.js
var require_createTransport = __commonJS({
  "node_modules/viem/_cjs/clients/transports/createTransport.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createTransport = void 0;
    var buildRequest_js_1 = require_buildRequest();
    function createTransport({ key, name, request, retryCount = 3, retryDelay = 150, timeout, type }, value) {
      return {
        config: { key, name, request, retryCount, retryDelay, timeout, type },
        request: (0, buildRequest_js_1.buildRequest)(request, { retryCount, retryDelay }),
        value
      };
    }
    exports.createTransport = createTransport;
  }
});

// node_modules/viem/_cjs/clients/transports/custom.js
var require_custom = __commonJS({
  "node_modules/viem/_cjs/clients/transports/custom.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.custom = void 0;
    var createTransport_js_1 = require_createTransport();
    function custom(provider, config = {}) {
      const { key = "custom", name = "Custom Provider", retryDelay } = config;
      return ({ retryCount: defaultRetryCount }) => (0, createTransport_js_1.createTransport)({
        key,
        name,
        request: provider.request.bind(provider),
        retryCount: config.retryCount ?? defaultRetryCount,
        retryDelay,
        type: "custom"
      });
    }
    exports.custom = custom;
  }
});

// node_modules/viem/_cjs/clients/transports/fallback.js
var require_fallback = __commonJS({
  "node_modules/viem/_cjs/clients/transports/fallback.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rankTransports = exports.fallback = void 0;
    var buildRequest_js_1 = require_buildRequest();
    var wait_js_1 = require_wait();
    var createTransport_js_1 = require_createTransport();
    function fallback(transports_, config = {}) {
      const { key = "fallback", name = "Fallback", rank = false, retryCount, retryDelay } = config;
      return ({ chain, pollingInterval = 4e3, timeout }) => {
        let transports = transports_;
        let onResponse = () => {
        };
        const transport = (0, createTransport_js_1.createTransport)({
          key,
          name,
          async request({ method, params }) {
            const fetch2 = async (i = 0) => {
              const transport2 = transports[i]({ chain, retryCount: 0, timeout });
              try {
                const response = await transport2.request({
                  method,
                  params
                });
                onResponse({
                  method,
                  params,
                  response,
                  transport: transport2,
                  status: "success"
                });
                return response;
              } catch (err) {
                onResponse({
                  error: err,
                  method,
                  params,
                  transport: transport2,
                  status: "error"
                });
                if ((0, buildRequest_js_1.isDeterministicError)(err))
                  throw err;
                if (i === transports.length - 1)
                  throw err;
                return fetch2(i + 1);
              }
            };
            return fetch2();
          },
          retryCount,
          retryDelay,
          type: "fallback"
        }, {
          onResponse: (fn) => onResponse = fn,
          transports: transports.map((fn) => fn({ chain, retryCount: 0 }))
        });
        if (rank) {
          const rankOptions = typeof rank === "object" ? rank : {};
          rankTransports({
            chain,
            interval: rankOptions.interval ?? pollingInterval,
            onTransports: (transports_2) => transports = transports_2,
            sampleCount: rankOptions.sampleCount,
            timeout: rankOptions.timeout,
            transports,
            weights: rankOptions.weights
          });
        }
        return transport;
      };
    }
    exports.fallback = fallback;
    function rankTransports({ chain, interval = 4e3, onTransports, sampleCount = 10, timeout = 1e3, transports, weights = {} }) {
      const { stability: stabilityWeight = 0.7, latency: latencyWeight = 0.3 } = weights;
      const samples = [];
      const rankTransports_ = async () => {
        const sample = await Promise.all(transports.map(async (transport) => {
          const transport_ = transport({ chain, retryCount: 0, timeout });
          const start = Date.now();
          let end;
          let success;
          try {
            await transport_.request({ method: "net_listening" });
            success = 1;
          } catch {
            success = 0;
          } finally {
            end = Date.now();
          }
          const latency = end - start;
          return { latency, success };
        }));
        samples.push(sample);
        if (samples.length > sampleCount)
          samples.shift();
        const maxLatency = Math.max(...samples.map((sample2) => Math.max(...sample2.map(({ latency }) => latency))));
        const scores = transports.map((_, i) => {
          const latencies = samples.map((sample2) => sample2[i].latency);
          const meanLatency = latencies.reduce((acc, latency) => acc + latency, 0) / latencies.length;
          const latencyScore = 1 - meanLatency / maxLatency;
          const successes = samples.map((sample2) => sample2[i].success);
          const stabilityScore = successes.reduce((acc, success) => acc + success, 0) / successes.length;
          if (stabilityScore === 0)
            return [0, i];
          return [
            latencyWeight * latencyScore + stabilityWeight * stabilityScore,
            i
          ];
        }).sort((a, b) => b[0] - a[0]);
        onTransports(scores.map(([, i]) => transports[i]));
        await (0, wait_js_1.wait)(interval);
        rankTransports_();
      };
      rankTransports_();
    }
    exports.rankTransports = rankTransports;
  }
});

// node_modules/viem/_cjs/errors/transport.js
var require_transport = __commonJS({
  "node_modules/viem/_cjs/errors/transport.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UrlRequiredError = void 0;
    var base_js_1 = require_base();
    var UrlRequiredError = class extends base_js_1.BaseError {
      constructor() {
        super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.", {
          docsPath: "/docs/clients/intro"
        });
      }
    };
    exports.UrlRequiredError = UrlRequiredError;
  }
});

// node_modules/isomorphic-ws/browser.js
var browser_exports = {};
__export(browser_exports, {
  default: () => browser_default
});
var ws, browser_default;
var init_browser = __esm({
  "node_modules/isomorphic-ws/browser.js"() {
    ws = null;
    if (typeof WebSocket !== "undefined") {
      ws = WebSocket;
    } else if (typeof MozWebSocket !== "undefined") {
      ws = MozWebSocket;
    } else if (typeof globalThis !== "undefined") {
      ws = globalThis.WebSocket || globalThis.MozWebSocket;
    } else if (typeof window !== "undefined") {
      ws = window.WebSocket || window.MozWebSocket;
    } else if (typeof self !== "undefined") {
      ws = self.WebSocket || self.MozWebSocket;
    }
    browser_default = ws;
  }
});

// node_modules/viem/_cjs/utils/promise/withTimeout.js
var require_withTimeout = __commonJS({
  "node_modules/viem/_cjs/utils/promise/withTimeout.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.withTimeout = void 0;
    function withTimeout(fn, { errorInstance, timeout, signal }) {
      return new Promise((resolve, reject) => {
        ;
        (async () => {
          let timeoutId;
          try {
            const controller = new AbortController();
            if (timeout > 0) {
              timeoutId = setTimeout(() => {
                if (signal) {
                  controller.abort();
                } else {
                  reject(errorInstance);
                }
              }, timeout);
            }
            resolve(await fn({ signal: controller?.signal }));
          } catch (err) {
            if (err.name === "AbortError")
              reject(errorInstance);
            reject(err);
          } finally {
            clearTimeout(timeoutId);
          }
        })();
      });
    }
    exports.withTimeout = withTimeout;
  }
});

// node_modules/viem/_cjs/utils/rpc.js
var require_rpc2 = __commonJS({
  "node_modules/viem/_cjs/utils/rpc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rpc = exports.getSocket = exports.socketsCache = void 0;
    var isomorphic_ws_1 = (init_browser(), __toCommonJS(browser_exports));
    var request_js_1 = require_request();
    var createBatchScheduler_js_1 = require_createBatchScheduler();
    var withTimeout_js_1 = require_withTimeout();
    var stringify_js_1 = require_stringify();
    var id = 0;
    async function http(url, { body, fetchOptions = {}, timeout = 1e4 }) {
      const { headers, method, signal: signal_ } = fetchOptions;
      try {
        const response = await (0, withTimeout_js_1.withTimeout)(async ({ signal }) => {
          const response2 = await fetch(url, {
            ...fetchOptions,
            body: Array.isArray(body) ? (0, stringify_js_1.stringify)(body.map((body2) => ({
              jsonrpc: "2.0",
              id: body2.id ?? id++,
              ...body2
            }))) : (0, stringify_js_1.stringify)({ jsonrpc: "2.0", id: body.id ?? id++, ...body }),
            headers: {
              ...headers,
              "Content-Type": "application/json"
            },
            method: method || "POST",
            signal: signal_ || (timeout > 0 ? signal : void 0)
          });
          return response2;
        }, {
          errorInstance: new request_js_1.TimeoutError({ body, url }),
          timeout,
          signal: true
        });
        let data;
        if (response.headers.get("Content-Type")?.startsWith("application/json")) {
          data = await response.json();
        } else {
          data = await response.text();
        }
        if (!response.ok) {
          throw new request_js_1.HttpRequestError({
            body,
            details: (0, stringify_js_1.stringify)(data.error) || response.statusText,
            headers: response.headers,
            status: response.status,
            url
          });
        }
        return data;
      } catch (err) {
        if (err instanceof request_js_1.HttpRequestError)
          throw err;
        if (err instanceof request_js_1.TimeoutError)
          throw err;
        throw new request_js_1.HttpRequestError({
          body,
          details: err.message,
          url
        });
      }
    }
    exports.socketsCache = /* @__PURE__ */ new Map();
    async function getSocket(url) {
      let socket = exports.socketsCache.get(url);
      if (socket)
        return socket;
      const { schedule } = (0, createBatchScheduler_js_1.createBatchScheduler)({
        id: url,
        fn: async () => {
          let WebSocket_ = isomorphic_ws_1.default;
          if (!isomorphic_ws_1.default.constructor)
            WebSocket_ = isomorphic_ws_1.default.WebSocket;
          const webSocket2 = new WebSocket_(url);
          const requests = /* @__PURE__ */ new Map();
          const subscriptions = /* @__PURE__ */ new Map();
          const onMessage = ({ data }) => {
            const message = JSON.parse(data);
            const isSubscription = message.method === "eth_subscription";
            const id2 = isSubscription ? message.params.subscription : message.id;
            const cache = isSubscription ? subscriptions : requests;
            const callback = cache.get(id2);
            if (callback)
              callback({ data });
            if (!isSubscription)
              cache.delete(id2);
          };
          const onClose = () => {
            exports.socketsCache.delete(url);
            webSocket2.removeEventListener("close", onClose);
            webSocket2.removeEventListener("message", onMessage);
          };
          webSocket2.addEventListener("close", onClose);
          webSocket2.addEventListener("message", onMessage);
          if (webSocket2.readyState === isomorphic_ws_1.default.CONNECTING) {
            await new Promise((resolve, reject) => {
              if (!webSocket2)
                return;
              webSocket2.onopen = resolve;
              webSocket2.onerror = reject;
            });
          }
          socket = Object.assign(webSocket2, {
            requests,
            subscriptions
          });
          exports.socketsCache.set(url, socket);
          return [socket];
        }
      });
      const [_, [socket_]] = await schedule();
      return socket_;
    }
    exports.getSocket = getSocket;
    function webSocket(socket, { body, onResponse }) {
      if (socket.readyState === socket.CLOSED || socket.readyState === socket.CLOSING)
        throw new request_js_1.WebSocketRequestError({
          body,
          url: socket.url,
          details: "Socket is closed."
        });
      const id_ = id++;
      const callback = ({ data }) => {
        const message = JSON.parse(data);
        if (typeof message.id === "number" && id_ !== message.id)
          return;
        onResponse?.(message);
        if (body.method === "eth_subscribe" && typeof message.result === "string") {
          socket.subscriptions.set(message.result, callback);
        }
        if (body.method === "eth_unsubscribe") {
          socket.subscriptions.delete(body.params?.[0]);
        }
      };
      socket.requests.set(id_, callback);
      socket.send(JSON.stringify({ jsonrpc: "2.0", ...body, id: id_ }));
      return socket;
    }
    async function webSocketAsync(socket, { body, timeout = 1e4 }) {
      return (0, withTimeout_js_1.withTimeout)(() => new Promise((onResponse) => exports.rpc.webSocket(socket, {
        body,
        onResponse
      })), {
        errorInstance: new request_js_1.TimeoutError({ body, url: socket.url }),
        timeout
      });
    }
    exports.rpc = {
      http,
      webSocket,
      webSocketAsync
    };
  }
});

// node_modules/viem/_cjs/clients/transports/http.js
var require_http = __commonJS({
  "node_modules/viem/_cjs/clients/transports/http.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.http = void 0;
    var request_js_1 = require_request();
    var transport_js_1 = require_transport();
    var createBatchScheduler_js_1 = require_createBatchScheduler();
    var rpc_js_1 = require_rpc2();
    var createTransport_js_1 = require_createTransport();
    function http(url, config = {}) {
      const { batch, fetchOptions, key = "http", name = "HTTP JSON-RPC", retryDelay } = config;
      return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {
        const { batchSize = 1e3, wait = 0 } = typeof batch === "object" ? batch : {};
        const retryCount = config.retryCount ?? retryCount_;
        const timeout = timeout_ ?? config.timeout ?? 1e4;
        const url_ = url || chain?.rpcUrls.default.http[0];
        if (!url_)
          throw new transport_js_1.UrlRequiredError();
        return (0, createTransport_js_1.createTransport)({
          key,
          name,
          async request({ method, params }) {
            const body = { method, params };
            const { schedule } = (0, createBatchScheduler_js_1.createBatchScheduler)({
              id: `${url}`,
              wait,
              shouldSplitBatch(requests) {
                return requests.length > batchSize;
              },
              fn: (body2) => rpc_js_1.rpc.http(url_, {
                body: body2,
                fetchOptions,
                timeout
              })
            });
            const fn = async (body2) => batch ? schedule(body2) : [await rpc_js_1.rpc.http(url_, { body: body2, fetchOptions, timeout })];
            const [{ error, result }] = await fn(body);
            if (error)
              throw new request_js_1.RpcRequestError({
                body,
                error,
                url: url_
              });
            return result;
          },
          retryCount,
          retryDelay,
          timeout,
          type: "http"
        }, {
          url
        });
      };
    }
    exports.http = http;
  }
});

// node_modules/viem/_cjs/utils/ens/errors.js
var require_errors2 = __commonJS({
  "node_modules/viem/_cjs/utils/ens/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isNullUniversalResolverError = void 0;
    var solidity_js_1 = require_solidity();
    var base_js_1 = require_base();
    var contract_js_1 = require_contract();
    function isNullUniversalResolverError(err, callType) {
      if (!(err instanceof base_js_1.BaseError))
        return false;
      const cause = err.walk((e) => e instanceof contract_js_1.ContractFunctionRevertedError);
      if (!(cause instanceof contract_js_1.ContractFunctionRevertedError))
        return false;
      if (cause.data?.errorName === "ResolverNotFound")
        return true;
      if (cause.data?.errorName === "ResolverWildcardNotSupported")
        return true;
      if (cause.reason?.includes("Wildcard on non-extended resolvers is not supported"))
        return true;
      if (callType === "reverse" && cause.reason === solidity_js_1.panicReasons[50])
        return true;
      return false;
    }
    exports.isNullUniversalResolverError = isNullUniversalResolverError;
  }
});

// node_modules/viem/_cjs/utils/ens/encodedLabelToLabelhash.js
var require_encodedLabelToLabelhash = __commonJS({
  "node_modules/viem/_cjs/utils/ens/encodedLabelToLabelhash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodedLabelToLabelhash = void 0;
    var isHex_js_1 = require_isHex();
    function encodedLabelToLabelhash(label) {
      if (label.length !== 66)
        return null;
      if (label.indexOf("[") !== 0)
        return null;
      if (label.indexOf("]") !== 65)
        return null;
      const hash = `0x${label.slice(1, 65)}`;
      if (!(0, isHex_js_1.isHex)(hash))
        return null;
      return hash;
    }
    exports.encodedLabelToLabelhash = encodedLabelToLabelhash;
  }
});

// node_modules/viem/_cjs/utils/ens/namehash.js
var require_namehash = __commonJS({
  "node_modules/viem/_cjs/utils/ens/namehash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.namehash = void 0;
    var concat_js_1 = require_concat();
    var toBytes_js_1 = require_toBytes();
    var toHex_js_1 = require_toHex();
    var keccak256_js_1 = require_keccak256();
    var encodedLabelToLabelhash_js_1 = require_encodedLabelToLabelhash();
    function namehash(name) {
      let result = new Uint8Array(32).fill(0);
      if (!name)
        return (0, toHex_js_1.bytesToHex)(result);
      const labels = name.split(".");
      for (let i = labels.length - 1; i >= 0; i -= 1) {
        const hashFromEncodedLabel = (0, encodedLabelToLabelhash_js_1.encodedLabelToLabelhash)(labels[i]);
        const hashed = hashFromEncodedLabel ? (0, toBytes_js_1.toBytes)(hashFromEncodedLabel) : (0, keccak256_js_1.keccak256)((0, toBytes_js_1.stringToBytes)(labels[i]), "bytes");
        result = (0, keccak256_js_1.keccak256)((0, concat_js_1.concat)([result, hashed]), "bytes");
      }
      return (0, toHex_js_1.bytesToHex)(result);
    }
    exports.namehash = namehash;
  }
});

// node_modules/viem/_cjs/utils/ens/encodeLabelhash.js
var require_encodeLabelhash = __commonJS({
  "node_modules/viem/_cjs/utils/ens/encodeLabelhash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeLabelhash = void 0;
    function encodeLabelhash(hash) {
      return `[${hash.slice(2)}]`;
    }
    exports.encodeLabelhash = encodeLabelhash;
  }
});

// node_modules/viem/_cjs/utils/ens/labelhash.js
var require_labelhash = __commonJS({
  "node_modules/viem/_cjs/utils/ens/labelhash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.labelhash = void 0;
    var toBytes_js_1 = require_toBytes();
    var toHex_js_1 = require_toHex();
    var keccak256_js_1 = require_keccak256();
    var encodedLabelToLabelhash_js_1 = require_encodedLabelToLabelhash();
    function labelhash(label) {
      const result = new Uint8Array(32).fill(0);
      if (!label)
        return (0, toHex_js_1.bytesToHex)(result);
      return (0, encodedLabelToLabelhash_js_1.encodedLabelToLabelhash)(label) || (0, keccak256_js_1.keccak256)((0, toBytes_js_1.stringToBytes)(label));
    }
    exports.labelhash = labelhash;
  }
});

// node_modules/viem/_cjs/utils/ens/packetToBytes.js
var require_packetToBytes = __commonJS({
  "node_modules/viem/_cjs/utils/ens/packetToBytes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.packetToBytes = void 0;
    var toBytes_js_1 = require_toBytes();
    var encodeLabelhash_js_1 = require_encodeLabelhash();
    var labelhash_js_1 = require_labelhash();
    function packetToBytes(packet) {
      const value = packet.replace(/^\.|\.$/gm, "");
      if (value.length === 0)
        return new Uint8Array(1);
      const bytes = new Uint8Array((0, toBytes_js_1.stringToBytes)(value).byteLength + 2);
      let offset = 0;
      const list = value.split(".");
      for (let i = 0; i < list.length; i++) {
        let encoded = (0, toBytes_js_1.stringToBytes)(list[i]);
        if (encoded.byteLength > 255)
          encoded = (0, toBytes_js_1.stringToBytes)((0, encodeLabelhash_js_1.encodeLabelhash)((0, labelhash_js_1.labelhash)(list[i])));
        bytes[offset] = encoded.length;
        bytes.set(encoded, offset + 1);
        offset += encoded.length + 1;
      }
      if (bytes.byteLength !== offset + 1)
        return bytes.slice(0, offset + 1);
      return bytes;
    }
    exports.packetToBytes = packetToBytes;
  }
});

// node_modules/viem/_cjs/actions/ens/getEnsAddress.js
var require_getEnsAddress = __commonJS({
  "node_modules/viem/_cjs/actions/ens/getEnsAddress.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEnsAddress = void 0;
    var abis_js_1 = require_abis();
    var decodeFunctionResult_js_1 = require_decodeFunctionResult();
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    var chain_js_1 = require_chain2();
    var trim_js_1 = require_trim();
    var toHex_js_1 = require_toHex();
    var errors_js_1 = require_errors2();
    var namehash_js_1 = require_namehash();
    var packetToBytes_js_1 = require_packetToBytes();
    var readContract_js_1 = require_readContract();
    async function getEnsAddress(client, { blockNumber, blockTag, coinType, name, universalResolverAddress: universalResolverAddress_ }) {
      let universalResolverAddress = universalResolverAddress_;
      if (!universalResolverAddress) {
        if (!client.chain)
          throw new Error("client chain not configured. universalResolverAddress is required.");
        universalResolverAddress = (0, chain_js_1.getChainContractAddress)({
          blockNumber,
          chain: client.chain,
          contract: "ensUniversalResolver"
        });
      }
      try {
        const functionData = (0, encodeFunctionData_js_1.encodeFunctionData)({
          abi: abis_js_1.addressResolverAbi,
          functionName: "addr",
          ...coinType != null ? { args: [(0, namehash_js_1.namehash)(name), BigInt(coinType)] } : { args: [(0, namehash_js_1.namehash)(name)] }
        });
        const res = await (0, readContract_js_1.readContract)(client, {
          address: universalResolverAddress,
          abi: abis_js_1.universalResolverResolveAbi,
          functionName: "resolve",
          args: [(0, toHex_js_1.toHex)((0, packetToBytes_js_1.packetToBytes)(name)), functionData],
          blockNumber,
          blockTag
        });
        if (res[0] === "0x")
          return null;
        const address = (0, decodeFunctionResult_js_1.decodeFunctionResult)({
          abi: abis_js_1.addressResolverAbi,
          args: coinType != null ? [(0, namehash_js_1.namehash)(name), BigInt(coinType)] : void 0,
          functionName: "addr",
          data: res[0]
        });
        if (address === "0x")
          return null;
        if ((0, trim_js_1.trim)(address) === "0x00")
          return null;
        return address;
      } catch (err) {
        if ((0, errors_js_1.isNullUniversalResolverError)(err, "resolve"))
          return null;
        throw err;
      }
    }
    exports.getEnsAddress = getEnsAddress;
  }
});

// node_modules/viem/_cjs/errors/ens.js
var require_ens = __commonJS({
  "node_modules/viem/_cjs/errors/ens.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EnsAvatarUnsupportedNamespaceError = exports.EnsAvatarUriResolutionError = exports.EnsAvatarInvalidNftUriError = exports.EnsAvatarInvalidMetadataError = void 0;
    var base_js_1 = require_base();
    var EnsAvatarInvalidMetadataError = class extends base_js_1.BaseError {
      constructor({ data }) {
        super("Unable to extract image from metadata. The metadata may be malformed or invalid.", {
          metaMessages: [
            "- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.",
            "",
            `Provided data: ${JSON.stringify(data)}`
          ]
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "EnsAvatarInvalidMetadataError"
        });
      }
    };
    exports.EnsAvatarInvalidMetadataError = EnsAvatarInvalidMetadataError;
    var EnsAvatarInvalidNftUriError = class extends base_js_1.BaseError {
      constructor({ reason }) {
        super(`ENS NFT avatar URI is invalid. ${reason}`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "EnsAvatarInvalidNftUriError"
        });
      }
    };
    exports.EnsAvatarInvalidNftUriError = EnsAvatarInvalidNftUriError;
    var EnsAvatarUriResolutionError = class extends base_js_1.BaseError {
      constructor({ uri }) {
        super(`Unable to resolve ENS avatar URI "${uri}". The URI may be malformed, invalid, or does not respond with a valid image.`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "EnsAvatarUriResolutionError"
        });
      }
    };
    exports.EnsAvatarUriResolutionError = EnsAvatarUriResolutionError;
    var EnsAvatarUnsupportedNamespaceError = class extends base_js_1.BaseError {
      constructor({ namespace }) {
        super(`ENS NFT avatar namespace "${namespace}" is not supported. Must be "erc721" or "erc1155".`);
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "EnsAvatarUnsupportedNamespaceError"
        });
      }
    };
    exports.EnsAvatarUnsupportedNamespaceError = EnsAvatarUnsupportedNamespaceError;
  }
});

// node_modules/viem/_cjs/utils/ens/avatar/utils.js
var require_utils6 = __commonJS({
  "node_modules/viem/_cjs/utils/ens/avatar/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getNftTokenUri = exports.parseNftUri = exports.parseAvatarUri = exports.getMetadataAvatarUri = exports.getJsonImage = exports.resolveAvatarUri = exports.getGateway = exports.isImageUri = void 0;
    var readContract_js_1 = require_readContract();
    var ens_js_1 = require_ens();
    var networkRegex = /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/;
    var ipfsHashRegex = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/;
    var base64Regex = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/;
    var dataURIRegex = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;
    async function isImageUri(uri) {
      try {
        const res = await fetch(uri, { method: "HEAD" });
        if (res.status === 200) {
          const contentType = res.headers.get("content-type");
          return contentType?.startsWith("image/");
        }
        return false;
      } catch (error) {
        if (typeof error === "object" && typeof error.response !== "undefined") {
          return false;
        }
        if (!globalThis.hasOwnProperty("Image"))
          return false;
        return new Promise((resolve) => {
          const img = new Image();
          img.onload = () => {
            resolve(true);
          };
          img.onerror = () => {
            resolve(false);
          };
          img.src = uri;
        });
      }
    }
    exports.isImageUri = isImageUri;
    function getGateway(custom, defaultGateway) {
      if (!custom)
        return defaultGateway;
      if (custom.endsWith("/"))
        return custom.slice(0, -1);
      return custom;
    }
    exports.getGateway = getGateway;
    function resolveAvatarUri({ uri, gatewayUrls }) {
      const isEncoded = base64Regex.test(uri);
      if (isEncoded)
        return { uri, isOnChain: true, isEncoded };
      const ipfsGateway = getGateway(gatewayUrls?.ipfs, "https://ipfs.io");
      const arweaveGateway = getGateway(gatewayUrls?.arweave, "https://arweave.net");
      const networkRegexMatch = uri.match(networkRegex);
      const { protocol, subpath, target, subtarget = "" } = networkRegexMatch?.groups || {};
      const isIPNS = protocol === "ipns:/" || subpath === "ipns/";
      const isIPFS = protocol === "ipfs:/" || subpath === "ipfs/" || ipfsHashRegex.test(uri);
      if (uri.startsWith("http") && !isIPNS && !isIPFS) {
        let replacedUri = uri;
        if (gatewayUrls?.arweave)
          replacedUri = uri.replace(/https:\/\/arweave.net/g, gatewayUrls?.arweave);
        return { uri: replacedUri, isOnChain: false, isEncoded: false };
      }
      if ((isIPNS || isIPFS) && target) {
        return {
          uri: `${ipfsGateway}/${isIPNS ? "ipns" : "ipfs"}/${target}${subtarget}`,
          isOnChain: false,
          isEncoded: false
        };
      } else if (protocol === "ar:/" && target) {
        return {
          uri: `${arweaveGateway}/${target}${subtarget || ""}`,
          isOnChain: false,
          isEncoded: false
        };
      }
      let parsedUri = uri.replace(dataURIRegex, "");
      if (parsedUri.startsWith("<svg")) {
        parsedUri = `data:image/svg+xml;base64,${btoa(parsedUri)}`;
      }
      if (parsedUri.startsWith("data:") || parsedUri.startsWith("{")) {
        return {
          uri: parsedUri,
          isOnChain: true,
          isEncoded: false
        };
      }
      throw new ens_js_1.EnsAvatarUriResolutionError({ uri });
    }
    exports.resolveAvatarUri = resolveAvatarUri;
    function getJsonImage(data) {
      if (typeof data !== "object" || !("image" in data) && !("image_url" in data) && !("image_data" in data)) {
        throw new ens_js_1.EnsAvatarInvalidMetadataError({ data });
      }
      return data.image || data.image_url || data.image_data;
    }
    exports.getJsonImage = getJsonImage;
    async function getMetadataAvatarUri({ gatewayUrls, uri }) {
      try {
        const res = await fetch(uri).then((res2) => res2.json());
        const image = await parseAvatarUri({
          gatewayUrls,
          uri: getJsonImage(res)
        });
        return image;
      } catch {
        throw new ens_js_1.EnsAvatarUriResolutionError({ uri });
      }
    }
    exports.getMetadataAvatarUri = getMetadataAvatarUri;
    async function parseAvatarUri({ gatewayUrls, uri }) {
      const { uri: resolvedURI, isOnChain } = resolveAvatarUri({ uri, gatewayUrls });
      if (isOnChain)
        return resolvedURI;
      const isImage = await isImageUri(resolvedURI);
      if (isImage)
        return resolvedURI;
      throw new ens_js_1.EnsAvatarUriResolutionError({ uri });
    }
    exports.parseAvatarUri = parseAvatarUri;
    function parseNftUri(uri_) {
      let uri = uri_;
      if (uri.startsWith("did:nft:")) {
        uri = uri.replace("did:nft:", "").replace(/_/g, "/");
      }
      const [reference, asset_namespace, tokenID] = uri.split("/");
      const [eip_namespace, chainID] = reference.split(":");
      const [erc_namespace, contractAddress] = asset_namespace.split(":");
      if (!eip_namespace || eip_namespace.toLowerCase() !== "eip155")
        throw new ens_js_1.EnsAvatarInvalidNftUriError({ reason: "Only EIP-155 supported" });
      if (!chainID)
        throw new ens_js_1.EnsAvatarInvalidNftUriError({ reason: "Chain ID not found" });
      if (!contractAddress)
        throw new ens_js_1.EnsAvatarInvalidNftUriError({
          reason: "Contract address not found"
        });
      if (!tokenID)
        throw new ens_js_1.EnsAvatarInvalidNftUriError({ reason: "Token ID not found" });
      if (!erc_namespace)
        throw new ens_js_1.EnsAvatarInvalidNftUriError({ reason: "ERC namespace not found" });
      return {
        chainID: parseInt(chainID),
        namespace: erc_namespace.toLowerCase(),
        contractAddress,
        tokenID
      };
    }
    exports.parseNftUri = parseNftUri;
    async function getNftTokenUri(client, { nft }) {
      if (nft.namespace === "erc721") {
        return (0, readContract_js_1.readContract)(client, {
          address: nft.contractAddress,
          abi: [
            {
              name: "tokenURI",
              type: "function",
              stateMutability: "view",
              inputs: [{ name: "tokenId", type: "uint256" }],
              outputs: [{ name: "", type: "string" }]
            }
          ],
          functionName: "tokenURI",
          args: [BigInt(nft.tokenID)]
        });
      }
      if (nft.namespace === "erc1155") {
        return (0, readContract_js_1.readContract)(client, {
          address: nft.contractAddress,
          abi: [
            {
              name: "uri",
              type: "function",
              stateMutability: "view",
              inputs: [{ name: "_id", type: "uint256" }],
              outputs: [{ name: "", type: "string" }]
            }
          ],
          functionName: "uri",
          args: [BigInt(nft.tokenID)]
        });
      }
      throw new ens_js_1.EnsAvatarUnsupportedNamespaceError({ namespace: nft.namespace });
    }
    exports.getNftTokenUri = getNftTokenUri;
  }
});

// node_modules/viem/_cjs/utils/ens/avatar/parseAvatarRecord.js
var require_parseAvatarRecord = __commonJS({
  "node_modules/viem/_cjs/utils/ens/avatar/parseAvatarRecord.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseAvatarRecord = void 0;
    var utils_js_1 = require_utils6();
    async function parseAvatarRecord(client, { gatewayUrls, record }) {
      if (/eip155:/i.test(record))
        return parseNftAvatarUri(client, { gatewayUrls, record });
      return (0, utils_js_1.parseAvatarUri)({ uri: record, gatewayUrls });
    }
    exports.parseAvatarRecord = parseAvatarRecord;
    async function parseNftAvatarUri(client, { gatewayUrls, record }) {
      const nft = (0, utils_js_1.parseNftUri)(record);
      const nftUri = await (0, utils_js_1.getNftTokenUri)(client, { nft });
      const { uri: resolvedNftUri, isOnChain, isEncoded } = (0, utils_js_1.resolveAvatarUri)({ uri: nftUri, gatewayUrls });
      if (isOnChain && (resolvedNftUri.includes("data:application/json;base64,") || resolvedNftUri.startsWith("{"))) {
        const encodedJson = isEncoded ? atob(resolvedNftUri.replace("data:application/json;base64,", "")) : resolvedNftUri;
        const decoded = JSON.parse(encodedJson);
        return (0, utils_js_1.parseAvatarUri)({ uri: (0, utils_js_1.getJsonImage)(decoded), gatewayUrls });
      }
      let uriTokenId = nft.tokenID;
      if (nft.namespace === "erc1155")
        uriTokenId = uriTokenId.replace("0x", "").padStart(64, "0");
      return (0, utils_js_1.getMetadataAvatarUri)({
        gatewayUrls,
        uri: resolvedNftUri.replace(/(?:0x)?{id}/, uriTokenId)
      });
    }
  }
});

// node_modules/viem/_cjs/actions/ens/getEnsText.js
var require_getEnsText = __commonJS({
  "node_modules/viem/_cjs/actions/ens/getEnsText.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEnsText = void 0;
    var abis_js_1 = require_abis();
    var decodeFunctionResult_js_1 = require_decodeFunctionResult();
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    var chain_js_1 = require_chain2();
    var toHex_js_1 = require_toHex();
    var errors_js_1 = require_errors2();
    var namehash_js_1 = require_namehash();
    var packetToBytes_js_1 = require_packetToBytes();
    var readContract_js_1 = require_readContract();
    async function getEnsText(client, { blockNumber, blockTag, name, key, universalResolverAddress: universalResolverAddress_ }) {
      let universalResolverAddress = universalResolverAddress_;
      if (!universalResolverAddress) {
        if (!client.chain)
          throw new Error("client chain not configured. universalResolverAddress is required.");
        universalResolverAddress = (0, chain_js_1.getChainContractAddress)({
          blockNumber,
          chain: client.chain,
          contract: "ensUniversalResolver"
        });
      }
      try {
        const res = await (0, readContract_js_1.readContract)(client, {
          address: universalResolverAddress,
          abi: abis_js_1.universalResolverResolveAbi,
          functionName: "resolve",
          args: [
            (0, toHex_js_1.toHex)((0, packetToBytes_js_1.packetToBytes)(name)),
            (0, encodeFunctionData_js_1.encodeFunctionData)({
              abi: abis_js_1.textResolverAbi,
              functionName: "text",
              args: [(0, namehash_js_1.namehash)(name), key]
            })
          ],
          blockNumber,
          blockTag
        });
        if (res[0] === "0x")
          return null;
        const record = (0, decodeFunctionResult_js_1.decodeFunctionResult)({
          abi: abis_js_1.textResolverAbi,
          functionName: "text",
          data: res[0]
        });
        return record === "" ? null : record;
      } catch (err) {
        if ((0, errors_js_1.isNullUniversalResolverError)(err, "resolve"))
          return null;
        throw err;
      }
    }
    exports.getEnsText = getEnsText;
  }
});

// node_modules/viem/_cjs/actions/ens/getEnsAvatar.js
var require_getEnsAvatar = __commonJS({
  "node_modules/viem/_cjs/actions/ens/getEnsAvatar.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEnsAvatar = void 0;
    var parseAvatarRecord_js_1 = require_parseAvatarRecord();
    var getEnsText_js_1 = require_getEnsText();
    async function getEnsAvatar(client, { blockNumber, blockTag, gatewayUrls, name, universalResolverAddress }) {
      const record = await (0, getEnsText_js_1.getEnsText)(client, {
        blockNumber,
        blockTag,
        key: "avatar",
        name,
        universalResolverAddress
      });
      if (!record)
        return null;
      try {
        return await (0, parseAvatarRecord_js_1.parseAvatarRecord)(client, { record, gatewayUrls });
      } catch {
        return null;
      }
    }
    exports.getEnsAvatar = getEnsAvatar;
  }
});

// node_modules/viem/_cjs/actions/ens/getEnsName.js
var require_getEnsName = __commonJS({
  "node_modules/viem/_cjs/actions/ens/getEnsName.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEnsName = void 0;
    var abis_js_1 = require_abis();
    var chain_js_1 = require_chain2();
    var toHex_js_1 = require_toHex();
    var errors_js_1 = require_errors2();
    var packetToBytes_js_1 = require_packetToBytes();
    var readContract_js_1 = require_readContract();
    async function getEnsName(client, { address, blockNumber, blockTag, universalResolverAddress: universalResolverAddress_ }) {
      let universalResolverAddress = universalResolverAddress_;
      if (!universalResolverAddress) {
        if (!client.chain)
          throw new Error("client chain not configured. universalResolverAddress is required.");
        universalResolverAddress = (0, chain_js_1.getChainContractAddress)({
          blockNumber,
          chain: client.chain,
          contract: "ensUniversalResolver"
        });
      }
      const reverseNode = `${address.toLowerCase().substring(2)}.addr.reverse`;
      try {
        const res = await (0, readContract_js_1.readContract)(client, {
          address: universalResolverAddress,
          abi: abis_js_1.universalResolverReverseAbi,
          functionName: "reverse",
          args: [(0, toHex_js_1.toHex)((0, packetToBytes_js_1.packetToBytes)(reverseNode))],
          blockNumber,
          blockTag
        });
        return res[0];
      } catch (err) {
        if ((0, errors_js_1.isNullUniversalResolverError)(err, "reverse"))
          return null;
        throw err;
      }
    }
    exports.getEnsName = getEnsName;
  }
});

// node_modules/viem/_cjs/actions/ens/getEnsResolver.js
var require_getEnsResolver = __commonJS({
  "node_modules/viem/_cjs/actions/ens/getEnsResolver.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEnsResolver = void 0;
    var chain_js_1 = require_chain2();
    var toHex_js_1 = require_toHex();
    var packetToBytes_js_1 = require_packetToBytes();
    var readContract_js_1 = require_readContract();
    async function getEnsResolver(client, { blockNumber, blockTag, name, universalResolverAddress: universalResolverAddress_ }) {
      let universalResolverAddress = universalResolverAddress_;
      if (!universalResolverAddress) {
        if (!client.chain)
          throw new Error("client chain not configured. universalResolverAddress is required.");
        universalResolverAddress = (0, chain_js_1.getChainContractAddress)({
          blockNumber,
          chain: client.chain,
          contract: "ensUniversalResolver"
        });
      }
      const [resolverAddress] = await (0, readContract_js_1.readContract)(client, {
        address: universalResolverAddress,
        abi: [
          {
            inputs: [{ type: "bytes" }],
            name: "findResolver",
            outputs: [{ type: "address" }, { type: "bytes32" }],
            stateMutability: "view",
            type: "function"
          }
        ],
        functionName: "findResolver",
        args: [(0, toHex_js_1.toHex)((0, packetToBytes_js_1.packetToBytes)(name))],
        blockNumber,
        blockTag
      });
      return resolverAddress;
    }
    exports.getEnsResolver = getEnsResolver;
  }
});

// node_modules/viem/_cjs/actions/public/createBlockFilter.js
var require_createBlockFilter = __commonJS({
  "node_modules/viem/_cjs/actions/public/createBlockFilter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createBlockFilter = void 0;
    var createFilterRequestScope_js_1 = require_createFilterRequestScope();
    async function createBlockFilter(client) {
      const getRequest = (0, createFilterRequestScope_js_1.createFilterRequestScope)(client, {
        method: "eth_newBlockFilter"
      });
      const id = await client.request({
        method: "eth_newBlockFilter"
      });
      return { id, request: getRequest(id), type: "block" };
    }
    exports.createBlockFilter = createBlockFilter;
  }
});

// node_modules/viem/_cjs/actions/public/createEventFilter.js
var require_createEventFilter = __commonJS({
  "node_modules/viem/_cjs/actions/public/createEventFilter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createEventFilter = void 0;
    var encodeEventTopics_js_1 = require_encodeEventTopics();
    var toHex_js_1 = require_toHex();
    var createFilterRequestScope_js_1 = require_createFilterRequestScope();
    async function createEventFilter(client, { address, args, event, events: events_, fromBlock, strict, toBlock } = {}) {
      const events = events_ ?? (event ? [event] : void 0);
      const getRequest = (0, createFilterRequestScope_js_1.createFilterRequestScope)(client, {
        method: "eth_newFilter"
      });
      let topics = [];
      if (events) {
        topics = [
          events.flatMap((event2) => (0, encodeEventTopics_js_1.encodeEventTopics)({
            abi: [event2],
            eventName: event2.name,
            args
          }))
        ];
        if (event)
          topics = topics[0];
      }
      const id = await client.request({
        method: "eth_newFilter",
        params: [
          {
            address,
            fromBlock: typeof fromBlock === "bigint" ? (0, toHex_js_1.numberToHex)(fromBlock) : fromBlock,
            toBlock: typeof toBlock === "bigint" ? (0, toHex_js_1.numberToHex)(toBlock) : toBlock,
            ...topics.length ? { topics } : {}
          }
        ]
      });
      return {
        abi: events,
        args,
        eventName: event ? event.name : void 0,
        fromBlock,
        id,
        request: getRequest(id),
        strict,
        toBlock,
        type: "event"
      };
    }
    exports.createEventFilter = createEventFilter;
  }
});

// node_modules/viem/_cjs/actions/public/createPendingTransactionFilter.js
var require_createPendingTransactionFilter = __commonJS({
  "node_modules/viem/_cjs/actions/public/createPendingTransactionFilter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createPendingTransactionFilter = void 0;
    var createFilterRequestScope_js_1 = require_createFilterRequestScope();
    async function createPendingTransactionFilter(client) {
      const getRequest = (0, createFilterRequestScope_js_1.createFilterRequestScope)(client, {
        method: "eth_newPendingTransactionFilter"
      });
      const id = await client.request({
        method: "eth_newPendingTransactionFilter"
      });
      return { id, request: getRequest(id), type: "transaction" };
    }
    exports.createPendingTransactionFilter = createPendingTransactionFilter;
  }
});

// node_modules/viem/_cjs/actions/public/getBalance.js
var require_getBalance = __commonJS({
  "node_modules/viem/_cjs/actions/public/getBalance.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getBalance = void 0;
    var toHex_js_1 = require_toHex();
    async function getBalance(client, { address, blockNumber, blockTag = "latest" }) {
      const blockNumberHex = blockNumber ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
      const balance = await client.request({
        method: "eth_getBalance",
        params: [address, blockNumberHex || blockTag]
      });
      return BigInt(balance);
    }
    exports.getBalance = getBalance;
  }
});

// node_modules/viem/_cjs/actions/public/getBlockTransactionCount.js
var require_getBlockTransactionCount = __commonJS({
  "node_modules/viem/_cjs/actions/public/getBlockTransactionCount.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getBlockTransactionCount = void 0;
    var fromHex_js_1 = require_fromHex();
    var toHex_js_1 = require_toHex();
    async function getBlockTransactionCount(client, { blockHash, blockNumber, blockTag = "latest" } = {}) {
      const blockNumberHex = blockNumber !== void 0 ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
      let count;
      if (blockHash) {
        count = await client.request({
          method: "eth_getBlockTransactionCountByHash",
          params: [blockHash]
        });
      } else {
        count = await client.request({
          method: "eth_getBlockTransactionCountByNumber",
          params: [blockNumberHex || blockTag]
        });
      }
      return (0, fromHex_js_1.hexToNumber)(count);
    }
    exports.getBlockTransactionCount = getBlockTransactionCount;
  }
});

// node_modules/viem/_cjs/actions/public/getBytecode.js
var require_getBytecode = __commonJS({
  "node_modules/viem/_cjs/actions/public/getBytecode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getBytecode = void 0;
    var toHex_js_1 = require_toHex();
    async function getBytecode(client, { address, blockNumber, blockTag = "latest" }) {
      const blockNumberHex = blockNumber !== void 0 ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
      const hex = await client.request({
        method: "eth_getCode",
        params: [address, blockNumberHex || blockTag]
      });
      if (hex === "0x")
        return void 0;
      return hex;
    }
    exports.getBytecode = getBytecode;
  }
});

// node_modules/viem/_cjs/utils/formatters/feeHistory.js
var require_feeHistory = __commonJS({
  "node_modules/viem/_cjs/utils/formatters/feeHistory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatFeeHistory = void 0;
    function formatFeeHistory(feeHistory) {
      return {
        baseFeePerGas: feeHistory.baseFeePerGas.map((value) => BigInt(value)),
        gasUsedRatio: feeHistory.gasUsedRatio,
        oldestBlock: BigInt(feeHistory.oldestBlock),
        reward: feeHistory.reward?.map((reward) => reward.map((value) => BigInt(value)))
      };
    }
    exports.formatFeeHistory = formatFeeHistory;
  }
});

// node_modules/viem/_cjs/actions/public/getFeeHistory.js
var require_getFeeHistory = __commonJS({
  "node_modules/viem/_cjs/actions/public/getFeeHistory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFeeHistory = void 0;
    var toHex_js_1 = require_toHex();
    var feeHistory_js_1 = require_feeHistory();
    async function getFeeHistory(client, { blockCount, blockNumber, blockTag = "latest", rewardPercentiles }) {
      const blockNumberHex = blockNumber ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
      const feeHistory = await client.request({
        method: "eth_feeHistory",
        params: [
          (0, toHex_js_1.numberToHex)(blockCount),
          blockNumberHex || blockTag,
          rewardPercentiles
        ]
      });
      return (0, feeHistory_js_1.formatFeeHistory)(feeHistory);
    }
    exports.getFeeHistory = getFeeHistory;
  }
});

// node_modules/viem/_cjs/actions/public/getFilterLogs.js
var require_getFilterLogs = __commonJS({
  "node_modules/viem/_cjs/actions/public/getFilterLogs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFilterLogs = void 0;
    var abi_js_1 = require_abi();
    var decodeEventLog_js_1 = require_decodeEventLog();
    var log_js_1 = require_log();
    async function getFilterLogs(_client, { filter }) {
      const strict = filter.strict ?? false;
      const logs = await filter.request({
        method: "eth_getFilterLogs",
        params: [filter.id]
      });
      return logs.map((log) => {
        try {
          const { eventName, args } = "abi" in filter && filter.abi ? (0, decodeEventLog_js_1.decodeEventLog)({
            abi: filter.abi,
            data: log.data,
            topics: log.topics,
            strict
          }) : { eventName: void 0, args: void 0 };
          return (0, log_js_1.formatLog)(log, { args, eventName });
        } catch (err) {
          let eventName;
          let isUnnamed;
          if (err instanceof abi_js_1.DecodeLogDataMismatch || err instanceof abi_js_1.DecodeLogTopicsMismatch) {
            if ("strict" in filter && filter.strict)
              return;
            eventName = err.abiItem.name;
            isUnnamed = err.abiItem.inputs?.some((x) => !("name" in x && x.name));
          }
          return (0, log_js_1.formatLog)(log, { args: isUnnamed ? [] : {}, eventName });
        }
      }).filter(Boolean);
    }
    exports.getFilterLogs = getFilterLogs;
  }
});

// node_modules/viem/_cjs/actions/public/getStorageAt.js
var require_getStorageAt = __commonJS({
  "node_modules/viem/_cjs/actions/public/getStorageAt.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getStorageAt = void 0;
    var toHex_js_1 = require_toHex();
    async function getStorageAt(client, { address, blockNumber, blockTag = "latest", slot }) {
      const blockNumberHex = blockNumber !== void 0 ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
      const data = await client.request({
        method: "eth_getStorageAt",
        params: [address, slot, blockNumberHex || blockTag]
      });
      return data;
    }
    exports.getStorageAt = getStorageAt;
  }
});

// node_modules/viem/_cjs/actions/public/getTransaction.js
var require_getTransaction = __commonJS({
  "node_modules/viem/_cjs/actions/public/getTransaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTransaction = void 0;
    var transaction_js_1 = require_transaction2();
    var toHex_js_1 = require_toHex();
    var transaction_js_2 = require_transaction();
    async function getTransaction(client, { blockHash, blockNumber, blockTag: blockTag_, hash, index }) {
      const blockTag = blockTag_ || "latest";
      const blockNumberHex = blockNumber !== void 0 ? (0, toHex_js_1.numberToHex)(blockNumber) : void 0;
      let transaction = null;
      if (hash) {
        transaction = await client.request({
          method: "eth_getTransactionByHash",
          params: [hash]
        });
      } else if (blockHash) {
        transaction = await client.request({
          method: "eth_getTransactionByBlockHashAndIndex",
          params: [blockHash, (0, toHex_js_1.numberToHex)(index)]
        });
      } else if (blockNumberHex || blockTag) {
        transaction = await client.request({
          method: "eth_getTransactionByBlockNumberAndIndex",
          params: [blockNumberHex || blockTag, (0, toHex_js_1.numberToHex)(index)]
        });
      }
      if (!transaction)
        throw new transaction_js_1.TransactionNotFoundError({
          blockHash,
          blockNumber,
          blockTag,
          hash,
          index
        });
      const format = client.chain?.formatters?.transaction?.format || transaction_js_2.formatTransaction;
      return format(transaction);
    }
    exports.getTransaction = getTransaction;
  }
});

// node_modules/viem/_cjs/actions/public/getTransactionConfirmations.js
var require_getTransactionConfirmations = __commonJS({
  "node_modules/viem/_cjs/actions/public/getTransactionConfirmations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTransactionConfirmations = void 0;
    var getBlockNumber_js_1 = require_getBlockNumber();
    var getTransaction_js_1 = require_getTransaction();
    async function getTransactionConfirmations(client, { hash, transactionReceipt }) {
      const [blockNumber, transaction] = await Promise.all([
        (0, getBlockNumber_js_1.getBlockNumber)(client),
        hash ? (0, getTransaction_js_1.getTransaction)(client, { hash }) : void 0
      ]);
      const transactionBlockNumber = transactionReceipt?.blockNumber || transaction?.blockNumber;
      if (!transactionBlockNumber)
        return 0n;
      return blockNumber - transactionBlockNumber + 1n;
    }
    exports.getTransactionConfirmations = getTransactionConfirmations;
  }
});

// node_modules/viem/_cjs/actions/public/getTransactionReceipt.js
var require_getTransactionReceipt = __commonJS({
  "node_modules/viem/_cjs/actions/public/getTransactionReceipt.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTransactionReceipt = void 0;
    var transaction_js_1 = require_transaction2();
    var transactionReceipt_js_1 = require_transactionReceipt();
    async function getTransactionReceipt(client, { hash }) {
      const receipt = await client.request({
        method: "eth_getTransactionReceipt",
        params: [hash]
      });
      if (!receipt)
        throw new transaction_js_1.TransactionReceiptNotFoundError({ hash });
      const format = client.chain?.formatters?.transactionReceipt?.format || transactionReceipt_js_1.formatTransactionReceipt;
      return format(receipt);
    }
    exports.getTransactionReceipt = getTransactionReceipt;
  }
});

// node_modules/viem/_cjs/actions/public/multicall.js
var require_multicall = __commonJS({
  "node_modules/viem/_cjs/actions/public/multicall.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.multicall = void 0;
    var abis_js_1 = require_abis();
    var abi_js_1 = require_abi();
    var base_js_1 = require_base();
    var contract_js_1 = require_contract();
    var decodeFunctionResult_js_1 = require_decodeFunctionResult();
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    var chain_js_1 = require_chain2();
    var getContractError_js_1 = require_getContractError();
    var readContract_js_1 = require_readContract();
    async function multicall(client, args) {
      const { allowFailure = true, batchSize: batchSize_, blockNumber, blockTag, contracts, multicallAddress: multicallAddress_ } = args;
      const batchSize = batchSize_ ?? (typeof client.batch?.multicall === "object" && client.batch.multicall.batchSize || 1024);
      let multicallAddress = multicallAddress_;
      if (!multicallAddress) {
        if (!client.chain)
          throw new Error("client chain not configured. multicallAddress is required.");
        multicallAddress = (0, chain_js_1.getChainContractAddress)({
          blockNumber,
          chain: client.chain,
          contract: "multicall3"
        });
      }
      const chunkedCalls = [[]];
      let currentChunk = 0;
      let currentChunkSize = 0;
      for (let i = 0; i < contracts.length; i++) {
        const { abi, address, args: args2, functionName } = contracts[i];
        try {
          const callData = (0, encodeFunctionData_js_1.encodeFunctionData)({
            abi,
            args: args2,
            functionName
          });
          currentChunkSize += (callData.length - 2) / 2;
          if (batchSize > 0 && currentChunkSize > batchSize && chunkedCalls[currentChunk].length > 0) {
            currentChunk++;
            currentChunkSize = (callData.length - 2) / 2;
            chunkedCalls[currentChunk] = [];
          }
          chunkedCalls[currentChunk] = [
            ...chunkedCalls[currentChunk],
            {
              allowFailure: true,
              callData,
              target: address
            }
          ];
        } catch (err) {
          const error = (0, getContractError_js_1.getContractError)(err, {
            abi,
            address,
            args: args2,
            docsPath: "/docs/contract/multicall",
            functionName
          });
          if (!allowFailure)
            throw error;
          chunkedCalls[currentChunk] = [
            ...chunkedCalls[currentChunk],
            {
              allowFailure: true,
              callData: "0x",
              target: address
            }
          ];
        }
      }
      const aggregate3Results = await Promise.allSettled(chunkedCalls.map((calls) => (0, readContract_js_1.readContract)(client, {
        abi: abis_js_1.multicall3Abi,
        address: multicallAddress,
        args: [calls],
        blockNumber,
        blockTag,
        functionName: "aggregate3"
      })));
      const results = [];
      for (let i = 0; i < aggregate3Results.length; i++) {
        const result = aggregate3Results[i];
        if (result.status === "rejected") {
          if (!allowFailure)
            throw result.reason;
          for (let j = 0; j < chunkedCalls[i].length; j++) {
            results.push({
              status: "failure",
              error: result.reason,
              result: void 0
            });
          }
          continue;
        }
        const aggregate3Result = result.value;
        for (let j = 0; j < aggregate3Result.length; j++) {
          const { returnData, success } = aggregate3Result[j];
          const { callData } = chunkedCalls[i][j];
          const { abi, address, functionName, args: args2 } = contracts[results.length];
          try {
            if (callData === "0x")
              throw new abi_js_1.AbiDecodingZeroDataError();
            if (!success)
              throw new contract_js_1.RawContractError({ data: returnData });
            const result2 = (0, decodeFunctionResult_js_1.decodeFunctionResult)({
              abi,
              args: args2,
              data: returnData,
              functionName
            });
            results.push(allowFailure ? { result: result2, status: "success" } : result2);
          } catch (err) {
            const error = (0, getContractError_js_1.getContractError)(err, {
              abi,
              address,
              args: args2,
              docsPath: "/docs/contract/multicall",
              functionName
            });
            if (!allowFailure)
              throw error;
            results.push({ error, result: void 0, status: "failure" });
          }
        }
      }
      if (results.length !== contracts.length)
        throw new base_js_1.BaseError("multicall results mismatch");
      return results;
    }
    exports.multicall = multicall;
  }
});

// node_modules/viem/_cjs/utils/regex.js
var require_regex2 = __commonJS({
  "node_modules/viem/_cjs/utils/regex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.integerRegex = exports.bytesRegex = exports.arrayRegex = void 0;
    exports.arrayRegex = /^(.*)\[([0-9]*)\]$/;
    exports.bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
    exports.integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
  }
});

// node_modules/viem/_cjs/utils/signature/hashTypedData.js
var require_hashTypedData = __commonJS({
  "node_modules/viem/_cjs/utils/signature/hashTypedData.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashDomain = exports.hashTypedData = void 0;
    var encodeAbiParameters_js_1 = require_encodeAbiParameters();
    var concat_js_1 = require_concat();
    var toHex_js_1 = require_toHex();
    var keccak256_js_1 = require_keccak256();
    var typedData_js_1 = require_typedData();
    function hashTypedData({ domain: domain_, message, primaryType, types: types_ }) {
      const domain = typeof domain_ === "undefined" ? {} : domain_;
      const types = {
        EIP712Domain: (0, typedData_js_1.getTypesForEIP712Domain)({ domain }),
        ...types_
      };
      (0, typedData_js_1.validateTypedData)({
        domain,
        message,
        primaryType,
        types
      });
      const parts = ["0x1901"];
      if (domain)
        parts.push(hashDomain({
          domain,
          types
        }));
      if (primaryType !== "EIP712Domain") {
        parts.push(hashStruct({
          data: message,
          primaryType,
          types
        }));
      }
      return (0, keccak256_js_1.keccak256)((0, concat_js_1.concat)(parts));
    }
    exports.hashTypedData = hashTypedData;
    function hashDomain({ domain, types }) {
      return hashStruct({
        data: domain,
        primaryType: "EIP712Domain",
        types
      });
    }
    exports.hashDomain = hashDomain;
    function hashStruct({ data, primaryType, types }) {
      const encoded = encodeData({
        data,
        primaryType,
        types
      });
      return (0, keccak256_js_1.keccak256)(encoded);
    }
    function encodeData({ data, primaryType, types }) {
      const encodedTypes = [{ type: "bytes32" }];
      const encodedValues = [hashType({ primaryType, types })];
      for (const field of types[primaryType]) {
        const [type, value] = encodeField({
          types,
          name: field.name,
          type: field.type,
          value: data[field.name]
        });
        encodedTypes.push(type);
        encodedValues.push(value);
      }
      return (0, encodeAbiParameters_js_1.encodeAbiParameters)(encodedTypes, encodedValues);
    }
    function hashType({ primaryType, types }) {
      const encodedHashType = (0, toHex_js_1.toHex)(encodeType({ primaryType, types }));
      return (0, keccak256_js_1.keccak256)(encodedHashType);
    }
    function encodeType({ primaryType, types }) {
      let result = "";
      const unsortedDeps = findTypeDependencies({ primaryType, types });
      unsortedDeps.delete(primaryType);
      const deps = [primaryType, ...Array.from(unsortedDeps).sort()];
      for (const type of deps) {
        result += `${type}(${types[type].map(({ name, type: t }) => `${t} ${name}`).join(",")})`;
      }
      return result;
    }
    function findTypeDependencies({ primaryType: primaryType_, types }, results = /* @__PURE__ */ new Set()) {
      const match = primaryType_.match(/^\w*/u);
      const primaryType = match?.[0];
      if (results.has(primaryType) || types[primaryType] === void 0) {
        return results;
      }
      results.add(primaryType);
      for (const field of types[primaryType]) {
        findTypeDependencies({ primaryType: field.type, types }, results);
      }
      return results;
    }
    function encodeField({ types, name, type, value }) {
      if (types[type] !== void 0) {
        return [
          { type: "bytes32" },
          (0, keccak256_js_1.keccak256)(encodeData({ data: value, primaryType: type, types }))
        ];
      }
      if (type === "bytes") {
        const prepend = value.length % 2 ? "0" : "";
        value = `0x${prepend + value.slice(2)}`;
        return [{ type: "bytes32" }, (0, keccak256_js_1.keccak256)(value)];
      }
      if (type === "string")
        return [{ type: "bytes32" }, (0, keccak256_js_1.keccak256)((0, toHex_js_1.toHex)(value))];
      if (type.lastIndexOf("]") === type.length - 1) {
        const parsedType = type.slice(0, type.lastIndexOf("["));
        const typeValuePairs = value.map((item) => encodeField({
          name,
          type: parsedType,
          types,
          value: item
        }));
        return [
          { type: "bytes32" },
          (0, keccak256_js_1.keccak256)((0, encodeAbiParameters_js_1.encodeAbiParameters)(typeValuePairs.map(([t]) => t), typeValuePairs.map(([, v]) => v)))
        ];
      }
      return [{ type }, value];
    }
  }
});

// node_modules/viem/_cjs/utils/typedData.js
var require_typedData = __commonJS({
  "node_modules/viem/_cjs/utils/typedData.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.domainSeparator = exports.getTypesForEIP712Domain = exports.validateTypedData = void 0;
    var abi_js_1 = require_abi();
    var address_js_1 = require_address();
    var isAddress_js_1 = require_isAddress();
    var size_js_1 = require_size();
    var toHex_js_1 = require_toHex();
    var regex_js_1 = require_regex2();
    var hashTypedData_js_1 = require_hashTypedData();
    function validateTypedData({ domain, message, primaryType, types: types_ }) {
      const types = types_;
      const validateData = (struct, value_) => {
        for (const param of struct) {
          const { name, type: type_ } = param;
          const type = type_;
          const value = value_[name];
          const integerMatch = type.match(regex_js_1.integerRegex);
          if (integerMatch && (typeof value === "number" || typeof value === "bigint")) {
            const [_type, base, size_] = integerMatch;
            (0, toHex_js_1.numberToHex)(value, {
              signed: base === "int",
              size: parseInt(size_) / 8
            });
          }
          if (type === "address" && typeof value === "string" && !(0, isAddress_js_1.isAddress)(value))
            throw new address_js_1.InvalidAddressError({ address: value });
          const bytesMatch = type.match(regex_js_1.bytesRegex);
          if (bytesMatch) {
            const [_type, size_] = bytesMatch;
            if (size_ && (0, size_js_1.size)(value) !== parseInt(size_))
              throw new abi_js_1.BytesSizeMismatchError({
                expectedSize: parseInt(size_),
                givenSize: (0, size_js_1.size)(value)
              });
          }
          const struct2 = types[type];
          if (struct2)
            validateData(struct2, value);
        }
      };
      if (types.EIP712Domain && domain)
        validateData(types.EIP712Domain, domain);
      if (primaryType !== "EIP712Domain") {
        const type = types[primaryType];
        validateData(type, message);
      }
    }
    exports.validateTypedData = validateTypedData;
    function getTypesForEIP712Domain({ domain }) {
      return [
        typeof domain?.name === "string" && { name: "name", type: "string" },
        domain?.version && { name: "version", type: "string" },
        typeof domain?.chainId === "number" && {
          name: "chainId",
          type: "uint256"
        },
        domain?.verifyingContract && {
          name: "verifyingContract",
          type: "address"
        },
        domain?.salt && { name: "salt", type: "bytes32" }
      ].filter(Boolean);
    }
    exports.getTypesForEIP712Domain = getTypesForEIP712Domain;
    function domainSeparator({ domain }) {
      return (0, hashTypedData_js_1.hashDomain)({
        domain,
        types: {
          EIP712Domain: getTypesForEIP712Domain({ domain })
        }
      });
    }
    exports.domainSeparator = domainSeparator;
  }
});

// node_modules/viem/_cjs/utils/abi/decodeFunctionData.js
var require_decodeFunctionData = __commonJS({
  "node_modules/viem/_cjs/utils/abi/decodeFunctionData.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeFunctionData = void 0;
    var abi_js_1 = require_abi();
    var slice_js_1 = require_slice();
    var getFunctionSelector_js_1 = require_getFunctionSelector();
    var decodeAbiParameters_js_1 = require_decodeAbiParameters();
    var formatAbiItem_js_1 = require_formatAbiItem2();
    function decodeFunctionData({ abi, data }) {
      const signature = (0, slice_js_1.slice)(data, 0, 4);
      const description = abi.find((x) => x.type === "function" && signature === (0, getFunctionSelector_js_1.getFunctionSelector)((0, formatAbiItem_js_1.formatAbiItem)(x)));
      if (!description)
        throw new abi_js_1.AbiFunctionSignatureNotFoundError(signature, {
          docsPath: "/docs/contract/decodeFunctionData"
        });
      return {
        functionName: description.name,
        args: "inputs" in description && description.inputs && description.inputs.length > 0 ? (0, decodeAbiParameters_js_1.decodeAbiParameters)(description.inputs, (0, slice_js_1.slice)(data, 4)) : void 0
      };
    }
    exports.decodeFunctionData = decodeFunctionData;
  }
});

// node_modules/viem/_cjs/utils/abi/encodeDeployData.js
var require_encodeDeployData = __commonJS({
  "node_modules/viem/_cjs/utils/abi/encodeDeployData.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeDeployData = void 0;
    var abi_js_1 = require_abi();
    var concat_js_1 = require_concat();
    var encodeAbiParameters_js_1 = require_encodeAbiParameters();
    var docsPath = "/docs/contract/encodeDeployData";
    function encodeDeployData({ abi, args, bytecode }) {
      if (!args || args.length === 0)
        return bytecode;
      const description = abi.find((x) => "type" in x && x.type === "constructor");
      if (!description)
        throw new abi_js_1.AbiConstructorNotFoundError({ docsPath });
      if (!("inputs" in description))
        throw new abi_js_1.AbiConstructorParamsNotFoundError({ docsPath });
      if (!description.inputs || description.inputs.length === 0)
        throw new abi_js_1.AbiConstructorParamsNotFoundError({ docsPath });
      const data = (0, encodeAbiParameters_js_1.encodeAbiParameters)(description.inputs, args);
      return (0, concat_js_1.concatHex)([bytecode, data]);
    }
    exports.encodeDeployData = encodeDeployData;
  }
});

// node_modules/viem/_cjs/utils/abi/encodeErrorResult.js
var require_encodeErrorResult = __commonJS({
  "node_modules/viem/_cjs/utils/abi/encodeErrorResult.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeErrorResult = void 0;
    var abi_js_1 = require_abi();
    var concat_js_1 = require_concat();
    var getFunctionSelector_js_1 = require_getFunctionSelector();
    var encodeAbiParameters_js_1 = require_encodeAbiParameters();
    var formatAbiItem_js_1 = require_formatAbiItem2();
    var getAbiItem_js_1 = require_getAbiItem();
    var docsPath = "/docs/contract/encodeErrorResult";
    function encodeErrorResult({ abi, errorName, args }) {
      let abiItem = abi[0];
      if (errorName) {
        abiItem = (0, getAbiItem_js_1.getAbiItem)({
          abi,
          args,
          name: errorName
        });
        if (!abiItem)
          throw new abi_js_1.AbiErrorNotFoundError(errorName, { docsPath });
      }
      if (abiItem.type !== "error")
        throw new abi_js_1.AbiErrorNotFoundError(void 0, { docsPath });
      const definition = (0, formatAbiItem_js_1.formatAbiItem)(abiItem);
      const signature = (0, getFunctionSelector_js_1.getFunctionSelector)(definition);
      let data = "0x";
      if (args && args.length > 0) {
        if (!abiItem.inputs)
          throw new abi_js_1.AbiErrorInputsNotFoundError(abiItem.name, { docsPath });
        data = (0, encodeAbiParameters_js_1.encodeAbiParameters)(abiItem.inputs, args);
      }
      return (0, concat_js_1.concatHex)([signature, data]);
    }
    exports.encodeErrorResult = encodeErrorResult;
  }
});

// node_modules/viem/_cjs/utils/abi/encodeFunctionResult.js
var require_encodeFunctionResult = __commonJS({
  "node_modules/viem/_cjs/utils/abi/encodeFunctionResult.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeFunctionResult = void 0;
    var abi_js_1 = require_abi();
    var encodeAbiParameters_js_1 = require_encodeAbiParameters();
    var getAbiItem_js_1 = require_getAbiItem();
    var docsPath = "/docs/contract/encodeFunctionResult";
    function encodeFunctionResult({ abi, functionName, result }) {
      let abiItem = abi[0];
      if (functionName) {
        abiItem = (0, getAbiItem_js_1.getAbiItem)({
          abi,
          name: functionName
        });
        if (!abiItem)
          throw new abi_js_1.AbiFunctionNotFoundError(functionName, {
            docsPath: "/docs/contract/encodeFunctionResult"
          });
      }
      if (abiItem.type !== "function")
        throw new abi_js_1.AbiFunctionNotFoundError(void 0, {
          docsPath: "/docs/contract/encodeFunctionResult"
        });
      if (!abiItem.outputs)
        throw new abi_js_1.AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath });
      let values = Array.isArray(result) ? result : [result];
      if (abiItem.outputs.length === 0 && !values[0])
        values = [];
      return (0, encodeAbiParameters_js_1.encodeAbiParameters)(abiItem.outputs, values);
    }
    exports.encodeFunctionResult = encodeFunctionResult;
  }
});

// node_modules/viem/_cjs/utils/abi/encodePacked.js
var require_encodePacked = __commonJS({
  "node_modules/viem/_cjs/utils/abi/encodePacked.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodePacked = void 0;
    var abi_js_1 = require_abi();
    var address_js_1 = require_address();
    var isAddress_js_1 = require_isAddress();
    var concat_js_1 = require_concat();
    var pad_js_1 = require_pad();
    var toHex_js_1 = require_toHex();
    var regex_js_1 = require_regex2();
    function encodePacked(types, values) {
      if (types.length !== values.length)
        throw new abi_js_1.AbiEncodingLengthMismatchError({
          expectedLength: types.length,
          givenLength: values.length
        });
      const data = [];
      for (let i = 0; i < types.length; i++) {
        const type = types[i];
        const value = values[i];
        data.push(encode(type, value));
      }
      return (0, concat_js_1.concatHex)(data);
    }
    exports.encodePacked = encodePacked;
    function encode(type, value, isArray = false) {
      if (type === "address") {
        const address = value;
        if (!(0, isAddress_js_1.isAddress)(address))
          throw new address_js_1.InvalidAddressError({ address });
        return (0, pad_js_1.pad)(address.toLowerCase(), {
          size: isArray ? 32 : null
        });
      }
      if (type === "string")
        return (0, toHex_js_1.stringToHex)(value);
      if (type === "bytes")
        return value;
      if (type === "bool")
        return (0, pad_js_1.pad)((0, toHex_js_1.boolToHex)(value), { size: isArray ? 32 : 1 });
      const intMatch = type.match(regex_js_1.integerRegex);
      if (intMatch) {
        const [_type, baseType, bits = "256"] = intMatch;
        const size = parseInt(bits) / 8;
        return (0, toHex_js_1.numberToHex)(value, {
          size: isArray ? 32 : size,
          signed: baseType === "int"
        });
      }
      const bytesMatch = type.match(regex_js_1.bytesRegex);
      if (bytesMatch) {
        const [_type, size] = bytesMatch;
        if (parseInt(size) !== (value.length - 2) / 2)
          throw new abi_js_1.BytesSizeMismatchError({
            expectedSize: parseInt(size),
            givenSize: (value.length - 2) / 2
          });
        return (0, pad_js_1.pad)(value, { dir: "right", size: isArray ? 32 : null });
      }
      const arrayMatch = type.match(regex_js_1.arrayRegex);
      if (arrayMatch && Array.isArray(value)) {
        const [_type, childType] = arrayMatch;
        const data = [];
        for (let i = 0; i < value.length; i++) {
          data.push(encode(childType, value[i], true));
        }
        if (data.length === 0)
          return "0x";
        return (0, concat_js_1.concatHex)(data);
      }
      throw new abi_js_1.UnsupportedPackedAbiType(type);
    }
  }
});

// node_modules/viem/_cjs/utils/data/isBytes.js
var require_isBytes = __commonJS({
  "node_modules/viem/_cjs/utils/data/isBytes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBytes = void 0;
    function isBytes(value) {
      if (!value)
        return false;
      if (typeof value !== "object")
        return false;
      if (!("BYTES_PER_ELEMENT" in value))
        return false;
      return value.BYTES_PER_ELEMENT === 1 && value.constructor.name === "Uint8Array";
    }
    exports.isBytes = isBytes;
  }
});

// node_modules/viem/_cjs/utils/address/getContractAddress.js
var require_getContractAddress = __commonJS({
  "node_modules/viem/_cjs/utils/address/getContractAddress.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getCreate2Address = exports.getCreateAddress = exports.getContractAddress = void 0;
    var concat_js_1 = require_concat();
    var isBytes_js_1 = require_isBytes();
    var pad_js_1 = require_pad();
    var slice_js_1 = require_slice();
    var toBytes_js_1 = require_toBytes();
    var toRlp_js_1 = require_toRlp();
    var keccak256_js_1 = require_keccak256();
    var getAddress_js_1 = require_getAddress();
    function getContractAddress(opts) {
      if (opts.opcode === "CREATE2")
        return getCreate2Address(opts);
      return getCreateAddress(opts);
    }
    exports.getContractAddress = getContractAddress;
    function getCreateAddress(opts) {
      const from = (0, toBytes_js_1.toBytes)((0, getAddress_js_1.getAddress)(opts.from));
      let nonce = (0, toBytes_js_1.toBytes)(opts.nonce);
      if (nonce[0] === 0)
        nonce = new Uint8Array([]);
      return (0, getAddress_js_1.getAddress)(`0x${(0, keccak256_js_1.keccak256)((0, toRlp_js_1.toRlp)([from, nonce], "bytes")).slice(26)}`);
    }
    exports.getCreateAddress = getCreateAddress;
    function getCreate2Address(opts) {
      const from = (0, toBytes_js_1.toBytes)((0, getAddress_js_1.getAddress)(opts.from));
      const salt = (0, pad_js_1.pad)((0, isBytes_js_1.isBytes)(opts.salt) ? opts.salt : (0, toBytes_js_1.toBytes)(opts.salt), {
        size: 32
      });
      const bytecodeHash = (0, toBytes_js_1.toBytes)((0, keccak256_js_1.keccak256)((0, isBytes_js_1.isBytes)(opts.bytecode) ? opts.bytecode : (0, toBytes_js_1.toBytes)(opts.bytecode)));
      return (0, getAddress_js_1.getAddress)((0, slice_js_1.slice)((0, keccak256_js_1.keccak256)((0, concat_js_1.concat)([(0, toBytes_js_1.toBytes)("0xff"), from, salt, bytecodeHash])), 12));
    }
    exports.getCreate2Address = getCreate2Address;
  }
});

// node_modules/viem/_cjs/utils/encoding/fromBytes.js
var require_fromBytes = __commonJS({
  "node_modules/viem/_cjs/utils/encoding/fromBytes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bytesToString = exports.bytesToNumber = exports.bytesToBool = exports.bytesToBigint = exports.fromBytes = void 0;
    var encoding_js_1 = require_encoding();
    var trim_js_1 = require_trim();
    var fromHex_js_1 = require_fromHex();
    var toHex_js_1 = require_toHex();
    function fromBytes(bytes, toOrOpts) {
      const opts = typeof toOrOpts === "string" ? { to: toOrOpts } : toOrOpts;
      const to = opts.to;
      if (to === "number")
        return bytesToNumber(bytes, opts);
      if (to === "bigint")
        return bytesToBigint(bytes, opts);
      if (to === "boolean")
        return bytesToBool(bytes, opts);
      if (to === "string")
        return bytesToString(bytes, opts);
      return (0, toHex_js_1.bytesToHex)(bytes, opts);
    }
    exports.fromBytes = fromBytes;
    function bytesToBigint(bytes, opts = {}) {
      if (typeof opts.size !== "undefined")
        (0, fromHex_js_1.assertSize)(bytes, { size: opts.size });
      const hex = (0, toHex_js_1.bytesToHex)(bytes, opts);
      return (0, fromHex_js_1.hexToBigInt)(hex);
    }
    exports.bytesToBigint = bytesToBigint;
    function bytesToBool(bytes_, opts = {}) {
      let bytes = bytes_;
      if (typeof opts.size !== "undefined") {
        (0, fromHex_js_1.assertSize)(bytes, { size: opts.size });
        bytes = (0, trim_js_1.trim)(bytes);
      }
      if (bytes.length > 1 || bytes[0] > 1)
        throw new encoding_js_1.InvalidBytesBooleanError(bytes);
      return Boolean(bytes[0]);
    }
    exports.bytesToBool = bytesToBool;
    function bytesToNumber(bytes, opts = {}) {
      if (typeof opts.size !== "undefined")
        (0, fromHex_js_1.assertSize)(bytes, { size: opts.size });
      const hex = (0, toHex_js_1.bytesToHex)(bytes, opts);
      return (0, fromHex_js_1.hexToNumber)(hex);
    }
    exports.bytesToNumber = bytesToNumber;
    function bytesToString(bytes_, opts = {}) {
      let bytes = bytes_;
      if (typeof opts.size !== "undefined") {
        (0, fromHex_js_1.assertSize)(bytes, { size: opts.size });
        bytes = (0, trim_js_1.trim)(bytes, { dir: "right" });
      }
      return new TextDecoder().decode(bytes);
    }
    exports.bytesToString = bytesToString;
  }
});

// node_modules/viem/_cjs/utils/encoding/fromRlp.js
var require_fromRlp = __commonJS({
  "node_modules/viem/_cjs/utils/encoding/fromRlp.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromRlp = void 0;
    var encoding_js_1 = require_encoding();
    var fromBytes_js_1 = require_fromBytes();
    var toBytes_js_1 = require_toBytes();
    var toHex_js_1 = require_toHex();
    function fromRlp(value, to) {
      const bytes = parse(value);
      const [data, consumed] = rlpToBytes(bytes);
      if (consumed < bytes.length)
        throw new encoding_js_1.DataLengthTooLongError({
          consumed,
          length: bytes.length
        });
      return format(data, to);
    }
    exports.fromRlp = fromRlp;
    function parse(value) {
      if (typeof value === "string") {
        if (value.length > 3 && value.length % 2 !== 0)
          throw new encoding_js_1.InvalidHexValueError(value);
        return (0, toBytes_js_1.hexToBytes)(value);
      }
      return value;
    }
    function format(bytes, to) {
      if (Array.isArray(bytes))
        return bytes.map((b) => format(b, to));
      return to === "hex" ? (0, toHex_js_1.bytesToHex)(bytes) : bytes;
    }
    function rlpToBytes(bytes, offset = 0) {
      if (bytes.length === 0)
        return [new Uint8Array([]), 0];
      const prefix = bytes[offset];
      if (prefix <= 127)
        return [new Uint8Array([bytes[offset]]), 1];
      if (prefix <= 183) {
        const length2 = prefix - 128;
        const offset_ = offset + 1;
        if (offset_ + length2 > bytes.length)
          throw new encoding_js_1.DataLengthTooShortError({
            length: offset_ + length2,
            dataLength: bytes.length
          });
        return [bytes.slice(offset_, offset_ + length2), 1 + length2];
      }
      if (prefix <= 191) {
        const lengthOfLength2 = prefix - 183;
        const offset_ = offset + 1;
        const length2 = (0, fromBytes_js_1.bytesToNumber)(bytes.slice(offset_, offset_ + lengthOfLength2));
        if (offset_ + lengthOfLength2 + length2 > bytes.length)
          throw new encoding_js_1.DataLengthTooShortError({
            length: lengthOfLength2 + length2,
            dataLength: bytes.length - lengthOfLength2
          });
        return [
          bytes.slice(offset_ + lengthOfLength2, offset_ + lengthOfLength2 + length2),
          1 + lengthOfLength2 + length2
        ];
      }
      let lengthOfLength = 0;
      let length = prefix - 192;
      if (prefix > 247) {
        lengthOfLength = prefix - 247;
        length = (0, fromBytes_js_1.bytesToNumber)(bytes.slice(offset + 1, offset + 1 + lengthOfLength));
      }
      let nextOffset = offset + 1 + lengthOfLength;
      if (nextOffset > bytes.length)
        throw new encoding_js_1.DataLengthTooShortError({
          length: nextOffset,
          dataLength: bytes.length
        });
      const consumed = 1 + lengthOfLength + length;
      const result = [];
      while (nextOffset < offset + consumed) {
        const decoded = rlpToBytes(bytes, nextOffset);
        result.push(decoded[0]);
        nextOffset += decoded[1];
        if (nextOffset > offset + consumed)
          throw new encoding_js_1.OffsetOutOfBoundsError({
            nextOffset,
            offset: offset + consumed
          });
      }
      return [result, consumed];
    }
  }
});

// node_modules/viem/_cjs/utils/hash/isHash.js
var require_isHash = __commonJS({
  "node_modules/viem/_cjs/utils/hash/isHash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isHash = void 0;
    var isHex_js_1 = require_isHex();
    var size_js_1 = require_size();
    function isHash(hash) {
      return (0, isHex_js_1.isHex)(hash) && (0, size_js_1.size)(hash) === 32;
    }
    exports.isHash = isHash;
  }
});

// node_modules/@noble/hashes/_sha2.js
var require_sha2 = __commonJS({
  "node_modules/@noble/hashes/_sha2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SHA2 = void 0;
    var _assert_js_1 = require_assert();
    var utils_js_1 = require_utils5();
    function setBigUint64(view, byteOffset, value, isLE) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value, isLE);
      const _32n = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value >> _32n & _u32_max);
      const wl = Number(value & _u32_max);
      const h = isLE ? 4 : 0;
      const l = isLE ? 0 : 4;
      view.setUint32(byteOffset + h, wh, isLE);
      view.setUint32(byteOffset + l, wl, isLE);
    }
    var SHA2 = class extends utils_js_1.Hash {
      constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
      }
      update(data) {
        (0, _assert_js_1.exists)(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = (0, utils_js_1.createView)(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.output)(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i = pos; i < blockLen; i++)
          buffer[i] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i = 0; i < outLen; i++)
          oview.setUint32(4 * i, state[i], isLE);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
          to.buffer.set(buffer);
        return to;
      }
    };
    exports.SHA2 = SHA2;
  }
});

// node_modules/@noble/hashes/sha256.js
var require_sha256 = __commonJS({
  "node_modules/@noble/hashes/sha256.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha224 = exports.sha256 = void 0;
    var _sha2_js_1 = require_sha2();
    var utils_js_1 = require_utils5();
    var Chi = (a, b, c) => a & b ^ ~a & c;
    var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
    var SHA256_K = /* @__PURE__ */ new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    var IV = /* @__PURE__ */ new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
    var SHA256 = class extends _sha2_js_1.SHA2 {
      constructor() {
        super(64, 32, 8, false);
        this.A = IV[0] | 0;
        this.B = IV[1] | 0;
        this.C = IV[2] | 0;
        this.D = IV[3] | 0;
        this.E = IV[4] | 0;
        this.F = IV[5] | 0;
        this.G = IV[6] | 0;
        this.H = IV[7] | 0;
      }
      get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
      }
      // prettier-ignore
      set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
          const W15 = SHA256_W[i - 15];
          const W2 = SHA256_W[i - 2];
          const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
          const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
          SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
          const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
          const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
          const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
          const T2 = sigma0 + Maj(A, B, C) | 0;
          H = G;
          G = F;
          F = E;
          E = D + T1 | 0;
          D = C;
          C = B;
          B = A;
          A = T1 + T2 | 0;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
      }
      roundClean() {
        SHA256_W.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    };
    var SHA224 = class extends SHA256 {
      constructor() {
        super();
        this.A = 3238371032 | 0;
        this.B = 914150663 | 0;
        this.C = 812702999 | 0;
        this.D = 4144912697 | 0;
        this.E = 4290775857 | 0;
        this.F = 1750603025 | 0;
        this.G = 1694076839 | 0;
        this.H = 3204075428 | 0;
        this.outputLen = 28;
      }
    };
    exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
    exports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
  }
});

// node_modules/@noble/curves/abstract/utils.js
var require_utils7 = __commonJS({
  "node_modules/@noble/curves/abstract/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateObject = exports.createHmacDrbg = exports.bitMask = exports.bitSet = exports.bitGet = exports.bitLen = exports.utf8ToBytes = exports.equalBytes = exports.concatBytes = exports.ensureBytes = exports.numberToVarBytesBE = exports.numberToBytesLE = exports.numberToBytesBE = exports.bytesToNumberLE = exports.bytesToNumberBE = exports.hexToBytes = exports.hexToNumber = exports.numberToHexUnpadded = exports.bytesToHex = void 0;
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var u8a = (a) => a instanceof Uint8Array;
    var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      if (!u8a(bytes))
        throw new Error("Uint8Array expected");
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    exports.bytesToHex = bytesToHex;
    function numberToHexUnpadded(num) {
      const hex = num.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
    }
    exports.numberToHexUnpadded = numberToHexUnpadded;
    function hexToNumber(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      return BigInt(hex === "" ? "0" : `0x${hex}`);
    }
    exports.hexToNumber = hexToNumber;
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const len = hex.length;
      if (len % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + len);
      const array = new Uint8Array(len / 2);
      for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
          throw new Error("Invalid byte sequence");
        array[i] = byte;
      }
      return array;
    }
    exports.hexToBytes = hexToBytes;
    function bytesToNumberBE(bytes) {
      return hexToNumber(bytesToHex(bytes));
    }
    exports.bytesToNumberBE = bytesToNumberBE;
    function bytesToNumberLE(bytes) {
      if (!u8a(bytes))
        throw new Error("Uint8Array expected");
      return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
    }
    exports.bytesToNumberLE = bytesToNumberLE;
    function numberToBytesBE(n, len) {
      return hexToBytes(n.toString(16).padStart(len * 2, "0"));
    }
    exports.numberToBytesBE = numberToBytesBE;
    function numberToBytesLE(n, len) {
      return numberToBytesBE(n, len).reverse();
    }
    exports.numberToBytesLE = numberToBytesLE;
    function numberToVarBytesBE(n) {
      return hexToBytes(numberToHexUnpadded(n));
    }
    exports.numberToVarBytesBE = numberToVarBytesBE;
    function ensureBytes(title, hex, expectedLength) {
      let res;
      if (typeof hex === "string") {
        try {
          res = hexToBytes(hex);
        } catch (e) {
          throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
        }
      } else if (u8a(hex)) {
        res = Uint8Array.from(hex);
      } else {
        throw new Error(`${title} must be hex string or Uint8Array`);
      }
      const len = res.length;
      if (typeof expectedLength === "number" && len !== expectedLength)
        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
      return res;
    }
    exports.ensureBytes = ensureBytes;
    function concatBytes(...arrays) {
      const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
      let pad = 0;
      arrays.forEach((a) => {
        if (!u8a(a))
          throw new Error("Uint8Array expected");
        r.set(a, pad);
        pad += a.length;
      });
      return r;
    }
    exports.concatBytes = concatBytes;
    function equalBytes(b1, b2) {
      if (b1.length !== b2.length)
        return false;
      for (let i = 0; i < b1.length; i++)
        if (b1[i] !== b2[i])
          return false;
      return true;
    }
    exports.equalBytes = equalBytes;
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    exports.utf8ToBytes = utf8ToBytes;
    function bitLen(n) {
      let len;
      for (len = 0; n > _0n; n >>= _1n, len += 1)
        ;
      return len;
    }
    exports.bitLen = bitLen;
    function bitGet(n, pos) {
      return n >> BigInt(pos) & _1n;
    }
    exports.bitGet = bitGet;
    var bitSet = (n, pos, value) => {
      return n | (value ? _1n : _0n) << BigInt(pos);
    };
    exports.bitSet = bitSet;
    var bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
    exports.bitMask = bitMask;
    var u8n = (data) => new Uint8Array(data);
    var u8fr = (arr) => Uint8Array.from(arr);
    function createHmacDrbg(hashLen, qByteLen, hmacFn) {
      if (typeof hashLen !== "number" || hashLen < 2)
        throw new Error("hashLen must be a number");
      if (typeof qByteLen !== "number" || qByteLen < 2)
        throw new Error("qByteLen must be a number");
      if (typeof hmacFn !== "function")
        throw new Error("hmacFn must be a function");
      let v = u8n(hashLen);
      let k = u8n(hashLen);
      let i = 0;
      const reset = () => {
        v.fill(1);
        k.fill(0);
        i = 0;
      };
      const h = (...b) => hmacFn(k, v, ...b);
      const reseed = (seed = u8n()) => {
        k = h(u8fr([0]), seed);
        v = h();
        if (seed.length === 0)
          return;
        k = h(u8fr([1]), seed);
        v = h();
      };
      const gen = () => {
        if (i++ >= 1e3)
          throw new Error("drbg: tried 1000 values");
        let len = 0;
        const out = [];
        while (len < qByteLen) {
          v = h();
          const sl = v.slice();
          out.push(sl);
          len += v.length;
        }
        return concatBytes(...out);
      };
      const genUntil = (seed, pred) => {
        reset();
        reseed(seed);
        let res = void 0;
        while (!(res = pred(gen())))
          reseed();
        reset();
        return res;
      };
      return genUntil;
    }
    exports.createHmacDrbg = createHmacDrbg;
    var validatorFns = {
      bigint: (val) => typeof val === "bigint",
      function: (val) => typeof val === "function",
      boolean: (val) => typeof val === "boolean",
      string: (val) => typeof val === "string",
      stringOrUint8Array: (val) => typeof val === "string" || val instanceof Uint8Array,
      isSafeInteger: (val) => Number.isSafeInteger(val),
      array: (val) => Array.isArray(val),
      field: (val, object) => object.Fp.isValid(val),
      hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
    };
    function validateObject(object, validators, optValidators = {}) {
      const checkField = (fieldName, type, isOptional) => {
        const checkVal = validatorFns[type];
        if (typeof checkVal !== "function")
          throw new Error(`Invalid validator "${type}", expected function`);
        const val = object[fieldName];
        if (isOptional && val === void 0)
          return;
        if (!checkVal(val, object)) {
          throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
        }
      };
      for (const [fieldName, type] of Object.entries(validators))
        checkField(fieldName, type, false);
      for (const [fieldName, type] of Object.entries(optValidators))
        checkField(fieldName, type, true);
      return object;
    }
    exports.validateObject = validateObject;
  }
});

// node_modules/@noble/curves/abstract/modular.js
var require_modular = __commonJS({
  "node_modules/@noble/curves/abstract/modular.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mapHashToField = exports.getMinHashLength = exports.getFieldBytesLength = exports.hashToPrivateScalar = exports.FpSqrtEven = exports.FpSqrtOdd = exports.Field = exports.nLength = exports.FpIsSquare = exports.FpDiv = exports.FpInvertBatch = exports.FpPow = exports.validateField = exports.isNegativeLE = exports.FpSqrt = exports.tonelliShanks = exports.invert = exports.pow2 = exports.pow = exports.mod = void 0;
    var utils_js_1 = require_utils7();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _4n = BigInt(4);
    var _5n = BigInt(5);
    var _8n = BigInt(8);
    var _9n = BigInt(9);
    var _16n = BigInt(16);
    function mod(a, b) {
      const result = a % b;
      return result >= _0n ? result : b + result;
    }
    exports.mod = mod;
    function pow(num, power, modulo) {
      if (modulo <= _0n || power < _0n)
        throw new Error("Expected power/modulo > 0");
      if (modulo === _1n)
        return _0n;
      let res = _1n;
      while (power > _0n) {
        if (power & _1n)
          res = res * num % modulo;
        num = num * num % modulo;
        power >>= _1n;
      }
      return res;
    }
    exports.pow = pow;
    function pow2(x, power, modulo) {
      let res = x;
      while (power-- > _0n) {
        res *= res;
        res %= modulo;
      }
      return res;
    }
    exports.pow2 = pow2;
    function invert(number, modulo) {
      if (number === _0n || modulo <= _0n) {
        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
      }
      let a = mod(number, modulo);
      let b = modulo;
      let x = _0n, y = _1n, u = _1n, v = _0n;
      while (a !== _0n) {
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        const n = y - v * q;
        b = a, a = r, x = u, y = v, u = m, v = n;
      }
      const gcd = b;
      if (gcd !== _1n)
        throw new Error("invert: does not exist");
      return mod(x, modulo);
    }
    exports.invert = invert;
    function tonelliShanks(P) {
      const legendreC = (P - _1n) / _2n;
      let Q, S, Z;
      for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)
        ;
      for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)
        ;
      if (S === 1) {
        const p1div4 = (P + _1n) / _4n;
        return function tonelliFast(Fp, n) {
          const root = Fp.pow(n, p1div4);
          if (!Fp.eql(Fp.sqr(root), n))
            throw new Error("Cannot find square root");
          return root;
        };
      }
      const Q1div2 = (Q + _1n) / _2n;
      return function tonelliSlow(Fp, n) {
        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
          throw new Error("Cannot find square root");
        let r = S;
        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q);
        let x = Fp.pow(n, Q1div2);
        let b = Fp.pow(n, Q);
        while (!Fp.eql(b, Fp.ONE)) {
          if (Fp.eql(b, Fp.ZERO))
            return Fp.ZERO;
          let m = 1;
          for (let t2 = Fp.sqr(b); m < r; m++) {
            if (Fp.eql(t2, Fp.ONE))
              break;
            t2 = Fp.sqr(t2);
          }
          const ge = Fp.pow(g, _1n << BigInt(r - m - 1));
          g = Fp.sqr(ge);
          x = Fp.mul(x, ge);
          b = Fp.mul(b, g);
          r = m;
        }
        return x;
      };
    }
    exports.tonelliShanks = tonelliShanks;
    function FpSqrt(P) {
      if (P % _4n === _3n) {
        const p1div4 = (P + _1n) / _4n;
        return function sqrt3mod4(Fp, n) {
          const root = Fp.pow(n, p1div4);
          if (!Fp.eql(Fp.sqr(root), n))
            throw new Error("Cannot find square root");
          return root;
        };
      }
      if (P % _8n === _5n) {
        const c1 = (P - _5n) / _8n;
        return function sqrt5mod8(Fp, n) {
          const n2 = Fp.mul(n, _2n);
          const v = Fp.pow(n2, c1);
          const nv = Fp.mul(n, v);
          const i = Fp.mul(Fp.mul(nv, _2n), v);
          const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
          if (!Fp.eql(Fp.sqr(root), n))
            throw new Error("Cannot find square root");
          return root;
        };
      }
      if (P % _16n === _9n) {
      }
      return tonelliShanks(P);
    }
    exports.FpSqrt = FpSqrt;
    var isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;
    exports.isNegativeLE = isNegativeLE;
    var FIELD_FIELDS = [
      "create",
      "isValid",
      "is0",
      "neg",
      "inv",
      "sqrt",
      "sqr",
      "eql",
      "add",
      "sub",
      "mul",
      "pow",
      "div",
      "addN",
      "subN",
      "mulN",
      "sqrN"
    ];
    function validateField(field) {
      const initial = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "isSafeInteger",
        BITS: "isSafeInteger"
      };
      const opts = FIELD_FIELDS.reduce((map, val) => {
        map[val] = "function";
        return map;
      }, initial);
      return (0, utils_js_1.validateObject)(field, opts);
    }
    exports.validateField = validateField;
    function FpPow(f, num, power) {
      if (power < _0n)
        throw new Error("Expected power > 0");
      if (power === _0n)
        return f.ONE;
      if (power === _1n)
        return num;
      let p = f.ONE;
      let d = num;
      while (power > _0n) {
        if (power & _1n)
          p = f.mul(p, d);
        d = f.sqr(d);
        power >>= _1n;
      }
      return p;
    }
    exports.FpPow = FpPow;
    function FpInvertBatch(f, nums) {
      const tmp = new Array(nums.length);
      const lastMultiplied = nums.reduce((acc, num, i) => {
        if (f.is0(num))
          return acc;
        tmp[i] = acc;
        return f.mul(acc, num);
      }, f.ONE);
      const inverted = f.inv(lastMultiplied);
      nums.reduceRight((acc, num, i) => {
        if (f.is0(num))
          return acc;
        tmp[i] = f.mul(acc, tmp[i]);
        return f.mul(acc, num);
      }, inverted);
      return tmp;
    }
    exports.FpInvertBatch = FpInvertBatch;
    function FpDiv(f, lhs, rhs) {
      return f.mul(lhs, typeof rhs === "bigint" ? invert(rhs, f.ORDER) : f.inv(rhs));
    }
    exports.FpDiv = FpDiv;
    function FpIsSquare(f) {
      const legendreConst = (f.ORDER - _1n) / _2n;
      return (x) => {
        const p = f.pow(x, legendreConst);
        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);
      };
    }
    exports.FpIsSquare = FpIsSquare;
    function nLength(n, nBitLength) {
      const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
      const nByteLength = Math.ceil(_nBitLength / 8);
      return { nBitLength: _nBitLength, nByteLength };
    }
    exports.nLength = nLength;
    function Field(ORDER, bitLen, isLE = false, redef = {}) {
      if (ORDER <= _0n)
        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
      const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);
      if (BYTES > 2048)
        throw new Error("Field lengths over 2048 bytes are not supported");
      const sqrtP = FpSqrt(ORDER);
      const f = Object.freeze({
        ORDER,
        BITS,
        BYTES,
        MASK: (0, utils_js_1.bitMask)(BITS),
        ZERO: _0n,
        ONE: _1n,
        create: (num) => mod(num, ORDER),
        isValid: (num) => {
          if (typeof num !== "bigint")
            throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
          return _0n <= num && num < ORDER;
        },
        is0: (num) => num === _0n,
        isOdd: (num) => (num & _1n) === _1n,
        neg: (num) => mod(-num, ORDER),
        eql: (lhs, rhs) => lhs === rhs,
        sqr: (num) => mod(num * num, ORDER),
        add: (lhs, rhs) => mod(lhs + rhs, ORDER),
        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
        pow: (num, power) => FpPow(f, num, power),
        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
        // Same as above, but doesn't normalize
        sqrN: (num) => num * num,
        addN: (lhs, rhs) => lhs + rhs,
        subN: (lhs, rhs) => lhs - rhs,
        mulN: (lhs, rhs) => lhs * rhs,
        inv: (num) => invert(num, ORDER),
        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
        invertBatch: (lst) => FpInvertBatch(f, lst),
        // TODO: do we really need constant cmov?
        // We don't have const-time bigints anyway, so probably will be not very useful
        cmov: (a, b, c) => c ? b : a,
        toBytes: (num) => isLE ? (0, utils_js_1.numberToBytesLE)(num, BYTES) : (0, utils_js_1.numberToBytesBE)(num, BYTES),
        fromBytes: (bytes) => {
          if (bytes.length !== BYTES)
            throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);
          return isLE ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);
        }
      });
      return Object.freeze(f);
    }
    exports.Field = Field;
    function FpSqrtOdd(Fp, elm) {
      if (!Fp.isOdd)
        throw new Error(`Field doesn't have isOdd`);
      const root = Fp.sqrt(elm);
      return Fp.isOdd(root) ? root : Fp.neg(root);
    }
    exports.FpSqrtOdd = FpSqrtOdd;
    function FpSqrtEven(Fp, elm) {
      if (!Fp.isOdd)
        throw new Error(`Field doesn't have isOdd`);
      const root = Fp.sqrt(elm);
      return Fp.isOdd(root) ? Fp.neg(root) : root;
    }
    exports.FpSqrtEven = FpSqrtEven;
    function hashToPrivateScalar(hash, groupOrder, isLE = false) {
      hash = (0, utils_js_1.ensureBytes)("privateHash", hash);
      const hashLen = hash.length;
      const minLen = nLength(groupOrder).nByteLength + 8;
      if (minLen < 24 || hashLen < minLen || hashLen > 1024)
        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
      const num = isLE ? (0, utils_js_1.bytesToNumberLE)(hash) : (0, utils_js_1.bytesToNumberBE)(hash);
      return mod(num, groupOrder - _1n) + _1n;
    }
    exports.hashToPrivateScalar = hashToPrivateScalar;
    function getFieldBytesLength(fieldOrder) {
      if (typeof fieldOrder !== "bigint")
        throw new Error("field order must be bigint");
      const bitLength = fieldOrder.toString(2).length;
      return Math.ceil(bitLength / 8);
    }
    exports.getFieldBytesLength = getFieldBytesLength;
    function getMinHashLength(fieldOrder) {
      const length = getFieldBytesLength(fieldOrder);
      return length + Math.ceil(length / 2);
    }
    exports.getMinHashLength = getMinHashLength;
    function mapHashToField(key, fieldOrder, isLE = false) {
      const len = key.length;
      const fieldLen = getFieldBytesLength(fieldOrder);
      const minLen = getMinHashLength(fieldOrder);
      if (len < 16 || len < minLen || len > 1024)
        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
      const num = isLE ? (0, utils_js_1.bytesToNumberBE)(key) : (0, utils_js_1.bytesToNumberLE)(key);
      const reduced = mod(num, fieldOrder - _1n) + _1n;
      return isLE ? (0, utils_js_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1.numberToBytesBE)(reduced, fieldLen);
    }
    exports.mapHashToField = mapHashToField;
  }
});

// node_modules/@noble/curves/abstract/curve.js
var require_curve = __commonJS({
  "node_modules/@noble/curves/abstract/curve.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateBasic = exports.wNAF = void 0;
    var modular_js_1 = require_modular();
    var utils_js_1 = require_utils7();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    function wNAF(c, bits) {
      const constTimeNegate = (condition, item) => {
        const neg = item.negate();
        return condition ? neg : item;
      };
      const opts = (W) => {
        const windows = Math.ceil(bits / W) + 1;
        const windowSize = 2 ** (W - 1);
        return { windows, windowSize };
      };
      return {
        constTimeNegate,
        // non-const time multiplication ladder
        unsafeLadder(elm, n) {
          let p = c.ZERO;
          let d = elm;
          while (n > _0n) {
            if (n & _1n)
              p = p.add(d);
            d = d.double();
            n >>= _1n;
          }
          return p;
        },
        /**
         * Creates a wNAF precomputation window. Used for caching.
         * Default window size is set by `utils.precompute()` and is equal to 8.
         * Number of precomputed points depends on the curve size:
         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
         * - 𝑊 is the window size
         * - 𝑛 is the bitlength of the curve order.
         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
         * @returns precomputed point tables flattened to a single array
         */
        precomputeWindow(elm, W) {
          const { windows, windowSize } = opts(W);
          const points = [];
          let p = elm;
          let base = p;
          for (let window2 = 0; window2 < windows; window2++) {
            base = p;
            points.push(base);
            for (let i = 1; i < windowSize; i++) {
              base = base.add(p);
              points.push(base);
            }
            p = base.double();
          }
          return points;
        },
        /**
         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
         * @param W window size
         * @param precomputes precomputed tables
         * @param n scalar (we don't check here, but should be less than curve order)
         * @returns real and fake (for const-time) points
         */
        wNAF(W, precomputes, n) {
          const { windows, windowSize } = opts(W);
          let p = c.ZERO;
          let f = c.BASE;
          const mask = BigInt(2 ** W - 1);
          const maxNumber = 2 ** W;
          const shiftBy = BigInt(W);
          for (let window2 = 0; window2 < windows; window2++) {
            const offset = window2 * windowSize;
            let wbits = Number(n & mask);
            n >>= shiftBy;
            if (wbits > windowSize) {
              wbits -= maxNumber;
              n += _1n;
            }
            const offset1 = offset;
            const offset2 = offset + Math.abs(wbits) - 1;
            const cond1 = window2 % 2 !== 0;
            const cond2 = wbits < 0;
            if (wbits === 0) {
              f = f.add(constTimeNegate(cond1, precomputes[offset1]));
            } else {
              p = p.add(constTimeNegate(cond2, precomputes[offset2]));
            }
          }
          return { p, f };
        },
        wNAFCached(P, precomputesMap, n, transform) {
          const W = P._WINDOW_SIZE || 1;
          let comp = precomputesMap.get(P);
          if (!comp) {
            comp = this.precomputeWindow(P, W);
            if (W !== 1) {
              precomputesMap.set(P, transform(comp));
            }
          }
          return this.wNAF(W, comp, n);
        }
      };
    }
    exports.wNAF = wNAF;
    function validateBasic(curve) {
      (0, modular_js_1.validateField)(curve.Fp);
      (0, utils_js_1.validateObject)(curve, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
      }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
      });
      return Object.freeze({
        ...(0, modular_js_1.nLength)(curve.n, curve.nBitLength),
        ...curve,
        ...{ p: curve.Fp.ORDER }
      });
    }
    exports.validateBasic = validateBasic;
  }
});

// node_modules/@noble/curves/abstract/weierstrass.js
var require_weierstrass = __commonJS({
  "node_modules/@noble/curves/abstract/weierstrass.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mapToCurveSimpleSWU = exports.SWUFpSqrtRatio = exports.weierstrass = exports.weierstrassPoints = exports.DER = void 0;
    var mod = require_modular();
    var ut = require_utils7();
    var utils_js_1 = require_utils7();
    var curve_js_1 = require_curve();
    function validatePointOpts(curve) {
      const opts = (0, curve_js_1.validateBasic)(curve);
      ut.validateObject(opts, {
        a: "field",
        b: "field"
      }, {
        allowedPrivateKeyLengths: "array",
        wrapPrivateKey: "boolean",
        isTorsionFree: "function",
        clearCofactor: "function",
        allowInfinityPoint: "boolean",
        fromBytes: "function",
        toBytes: "function"
      });
      const { endo, Fp, a } = opts;
      if (endo) {
        if (!Fp.eql(a, Fp.ZERO)) {
          throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
        }
        if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
          throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
        }
      }
      return Object.freeze({ ...opts });
    }
    var { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;
    exports.DER = {
      // asn.1 DER encoding utils
      Err: class DERErr extends Error {
        constructor(m = "") {
          super(m);
        }
      },
      _parseInt(data) {
        const { Err: E } = exports.DER;
        if (data.length < 2 || data[0] !== 2)
          throw new E("Invalid signature integer tag");
        const len = data[1];
        const res = data.subarray(2, len + 2);
        if (!len || res.length !== len)
          throw new E("Invalid signature integer: wrong length");
        if (res[0] & 128)
          throw new E("Invalid signature integer: negative");
        if (res[0] === 0 && !(res[1] & 128))
          throw new E("Invalid signature integer: unnecessary leading zero");
        return { d: b2n(res), l: data.subarray(len + 2) };
      },
      toSig(hex) {
        const { Err: E } = exports.DER;
        const data = typeof hex === "string" ? h2b(hex) : hex;
        if (!(data instanceof Uint8Array))
          throw new Error("ui8a expected");
        let l = data.length;
        if (l < 2 || data[0] != 48)
          throw new E("Invalid signature tag");
        if (data[1] !== l - 2)
          throw new E("Invalid signature: incorrect length");
        const { d: r, l: sBytes } = exports.DER._parseInt(data.subarray(2));
        const { d: s, l: rBytesLeft } = exports.DER._parseInt(sBytes);
        if (rBytesLeft.length)
          throw new E("Invalid signature: left bytes after parsing");
        return { r, s };
      },
      hexFromSig(sig) {
        const slice = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
        const h = (num) => {
          const hex = num.toString(16);
          return hex.length & 1 ? `0${hex}` : hex;
        };
        const s = slice(h(sig.s));
        const r = slice(h(sig.r));
        const shl = s.length / 2;
        const rhl = r.length / 2;
        const sl = h(shl);
        const rl = h(rhl);
        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
      }
    };
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _4n = BigInt(4);
    function weierstrassPoints(opts) {
      const CURVE = validatePointOpts(opts);
      const { Fp } = CURVE;
      const toBytes = CURVE.toBytes || ((_c, point, _isCompressed) => {
        const a = point.toAffine();
        return ut.concatBytes(Uint8Array.from([4]), Fp.toBytes(a.x), Fp.toBytes(a.y));
      });
      const fromBytes = CURVE.fromBytes || ((bytes) => {
        const tail = bytes.subarray(1);
        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
        return { x, y };
      });
      function weierstrassEquation(x) {
        const { a, b } = CURVE;
        const x2 = Fp.sqr(x);
        const x3 = Fp.mul(x2, x);
        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b);
      }
      if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
        throw new Error("bad generator point: equation left != right");
      function isWithinCurveOrder(num) {
        return typeof num === "bigint" && _0n < num && num < CURVE.n;
      }
      function assertGE(num) {
        if (!isWithinCurveOrder(num))
          throw new Error("Expected valid bigint: 0 < bigint < curve.n");
      }
      function normPrivateKeyToScalar(key) {
        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
        if (lengths && typeof key !== "bigint") {
          if (key instanceof Uint8Array)
            key = ut.bytesToHex(key);
          if (typeof key !== "string" || !lengths.includes(key.length))
            throw new Error("Invalid key");
          key = key.padStart(nByteLength * 2, "0");
        }
        let num;
        try {
          num = typeof key === "bigint" ? key : ut.bytesToNumberBE((0, utils_js_1.ensureBytes)("private key", key, nByteLength));
        } catch (error) {
          throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
        }
        if (wrapPrivateKey)
          num = mod.mod(num, n);
        assertGE(num);
        return num;
      }
      const pointPrecomputes = /* @__PURE__ */ new Map();
      function assertPrjPoint(other) {
        if (!(other instanceof Point))
          throw new Error("ProjectivePoint expected");
      }
      class Point {
        constructor(px, py, pz) {
          this.px = px;
          this.py = py;
          this.pz = pz;
          if (px == null || !Fp.isValid(px))
            throw new Error("x required");
          if (py == null || !Fp.isValid(py))
            throw new Error("y required");
          if (pz == null || !Fp.isValid(pz))
            throw new Error("z required");
        }
        // Does not validate if the point is on-curve.
        // Use fromHex instead, or call assertValidity() later.
        static fromAffine(p) {
          const { x, y } = p || {};
          if (!p || !Fp.isValid(x) || !Fp.isValid(y))
            throw new Error("invalid affine point");
          if (p instanceof Point)
            throw new Error("projective point not allowed");
          const is0 = (i) => Fp.eql(i, Fp.ZERO);
          if (is0(x) && is0(y))
            return Point.ZERO;
          return new Point(x, y, Fp.ONE);
        }
        get x() {
          return this.toAffine().x;
        }
        get y() {
          return this.toAffine().y;
        }
        /**
         * Takes a bunch of Projective Points but executes only one
         * inversion on all of them. Inversion is very slow operation,
         * so this improves performance massively.
         * Optimization: converts a list of projective points to a list of identical points with Z=1.
         */
        static normalizeZ(points) {
          const toInv = Fp.invertBatch(points.map((p) => p.pz));
          return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
        }
        /**
         * Converts hash string or Uint8Array to Point.
         * @param hex short/long ECDSA hex
         */
        static fromHex(hex) {
          const P = Point.fromAffine(fromBytes((0, utils_js_1.ensureBytes)("pointHex", hex)));
          P.assertValidity();
          return P;
        }
        // Multiplies generator point by privateKey.
        static fromPrivateKey(privateKey) {
          return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
        }
        // "Private method", don't use it directly
        _setWindowSize(windowSize) {
          this._WINDOW_SIZE = windowSize;
          pointPrecomputes.delete(this);
        }
        // A point on curve is valid if it conforms to equation.
        assertValidity() {
          if (this.is0()) {
            if (CURVE.allowInfinityPoint && !Fp.is0(this.py))
              return;
            throw new Error("bad point: ZERO");
          }
          const { x, y } = this.toAffine();
          if (!Fp.isValid(x) || !Fp.isValid(y))
            throw new Error("bad point: x or y not FE");
          const left = Fp.sqr(y);
          const right = weierstrassEquation(x);
          if (!Fp.eql(left, right))
            throw new Error("bad point: equation left != right");
          if (!this.isTorsionFree())
            throw new Error("bad point: not in prime-order subgroup");
        }
        hasEvenY() {
          const { y } = this.toAffine();
          if (Fp.isOdd)
            return !Fp.isOdd(y);
          throw new Error("Field doesn't support isOdd");
        }
        /**
         * Compare one point to another.
         */
        equals(other) {
          assertPrjPoint(other);
          const { px: X1, py: Y1, pz: Z1 } = this;
          const { px: X2, py: Y2, pz: Z2 } = other;
          const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
          const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
          return U1 && U2;
        }
        /**
         * Flips point to one corresponding to (x, -y) in Affine coordinates.
         */
        negate() {
          return new Point(this.px, Fp.neg(this.py), this.pz);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
          const { a, b } = CURVE;
          const b3 = Fp.mul(b, _3n);
          const { px: X1, py: Y1, pz: Z1 } = this;
          let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
          let t0 = Fp.mul(X1, X1);
          let t1 = Fp.mul(Y1, Y1);
          let t2 = Fp.mul(Z1, Z1);
          let t3 = Fp.mul(X1, Y1);
          t3 = Fp.add(t3, t3);
          Z3 = Fp.mul(X1, Z1);
          Z3 = Fp.add(Z3, Z3);
          X3 = Fp.mul(a, Z3);
          Y3 = Fp.mul(b3, t2);
          Y3 = Fp.add(X3, Y3);
          X3 = Fp.sub(t1, Y3);
          Y3 = Fp.add(t1, Y3);
          Y3 = Fp.mul(X3, Y3);
          X3 = Fp.mul(t3, X3);
          Z3 = Fp.mul(b3, Z3);
          t2 = Fp.mul(a, t2);
          t3 = Fp.sub(t0, t2);
          t3 = Fp.mul(a, t3);
          t3 = Fp.add(t3, Z3);
          Z3 = Fp.add(t0, t0);
          t0 = Fp.add(Z3, t0);
          t0 = Fp.add(t0, t2);
          t0 = Fp.mul(t0, t3);
          Y3 = Fp.add(Y3, t0);
          t2 = Fp.mul(Y1, Z1);
          t2 = Fp.add(t2, t2);
          t0 = Fp.mul(t2, t3);
          X3 = Fp.sub(X3, t0);
          Z3 = Fp.mul(t2, t1);
          Z3 = Fp.add(Z3, Z3);
          Z3 = Fp.add(Z3, Z3);
          return new Point(X3, Y3, Z3);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(other) {
          assertPrjPoint(other);
          const { px: X1, py: Y1, pz: Z1 } = this;
          const { px: X2, py: Y2, pz: Z2 } = other;
          let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
          const a = CURVE.a;
          const b3 = Fp.mul(CURVE.b, _3n);
          let t0 = Fp.mul(X1, X2);
          let t1 = Fp.mul(Y1, Y2);
          let t2 = Fp.mul(Z1, Z2);
          let t3 = Fp.add(X1, Y1);
          let t4 = Fp.add(X2, Y2);
          t3 = Fp.mul(t3, t4);
          t4 = Fp.add(t0, t1);
          t3 = Fp.sub(t3, t4);
          t4 = Fp.add(X1, Z1);
          let t5 = Fp.add(X2, Z2);
          t4 = Fp.mul(t4, t5);
          t5 = Fp.add(t0, t2);
          t4 = Fp.sub(t4, t5);
          t5 = Fp.add(Y1, Z1);
          X3 = Fp.add(Y2, Z2);
          t5 = Fp.mul(t5, X3);
          X3 = Fp.add(t1, t2);
          t5 = Fp.sub(t5, X3);
          Z3 = Fp.mul(a, t4);
          X3 = Fp.mul(b3, t2);
          Z3 = Fp.add(X3, Z3);
          X3 = Fp.sub(t1, Z3);
          Z3 = Fp.add(t1, Z3);
          Y3 = Fp.mul(X3, Z3);
          t1 = Fp.add(t0, t0);
          t1 = Fp.add(t1, t0);
          t2 = Fp.mul(a, t2);
          t4 = Fp.mul(b3, t4);
          t1 = Fp.add(t1, t2);
          t2 = Fp.sub(t0, t2);
          t2 = Fp.mul(a, t2);
          t4 = Fp.add(t4, t2);
          t0 = Fp.mul(t1, t4);
          Y3 = Fp.add(Y3, t0);
          t0 = Fp.mul(t5, t4);
          X3 = Fp.mul(t3, X3);
          X3 = Fp.sub(X3, t0);
          t0 = Fp.mul(t3, t1);
          Z3 = Fp.mul(t5, Z3);
          Z3 = Fp.add(Z3, t0);
          return new Point(X3, Y3, Z3);
        }
        subtract(other) {
          return this.add(other.negate());
        }
        is0() {
          return this.equals(Point.ZERO);
        }
        wNAF(n) {
          return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
            const toInv = Fp.invertBatch(comp.map((p) => p.pz));
            return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
          });
        }
        /**
         * Non-constant-time multiplication. Uses double-and-add algorithm.
         * It's faster, but should only be used when you don't care about
         * an exposed private key e.g. sig verification, which works over *public* keys.
         */
        multiplyUnsafe(n) {
          const I = Point.ZERO;
          if (n === _0n)
            return I;
          assertGE(n);
          if (n === _1n)
            return this;
          const { endo } = CURVE;
          if (!endo)
            return wnaf.unsafeLadder(this, n);
          let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
          let k1p = I;
          let k2p = I;
          let d = this;
          while (k1 > _0n || k2 > _0n) {
            if (k1 & _1n)
              k1p = k1p.add(d);
            if (k2 & _1n)
              k2p = k2p.add(d);
            d = d.double();
            k1 >>= _1n;
            k2 >>= _1n;
          }
          if (k1neg)
            k1p = k1p.negate();
          if (k2neg)
            k2p = k2p.negate();
          k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
          return k1p.add(k2p);
        }
        /**
         * Constant time multiplication.
         * Uses wNAF method. Windowed method may be 10% faster,
         * but takes 2x longer to generate and consumes 2x memory.
         * Uses precomputes when available.
         * Uses endomorphism for Koblitz curves.
         * @param scalar by which the point would be multiplied
         * @returns New point
         */
        multiply(scalar) {
          assertGE(scalar);
          let n = scalar;
          let point, fake;
          const { endo } = CURVE;
          if (endo) {
            const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
            let { p: k1p, f: f1p } = this.wNAF(k1);
            let { p: k2p, f: f2p } = this.wNAF(k2);
            k1p = wnaf.constTimeNegate(k1neg, k1p);
            k2p = wnaf.constTimeNegate(k2neg, k2p);
            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
            point = k1p.add(k2p);
            fake = f1p.add(f2p);
          } else {
            const { p, f } = this.wNAF(n);
            point = p;
            fake = f;
          }
          return Point.normalizeZ([point, fake])[0];
        }
        /**
         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
         * Not using Strauss-Shamir trick: precomputation tables are faster.
         * The trick could be useful if both P and Q are not G (not in our case).
         * @returns non-zero affine point
         */
        multiplyAndAddUnsafe(Q, a, b) {
          const G = Point.BASE;
          const mul = (P, a2) => a2 === _0n || a2 === _1n || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
          const sum = mul(this, a).add(mul(Q, b));
          return sum.is0() ? void 0 : sum;
        }
        // Converts Projective point to affine (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        // (x, y, z) ∋ (x=x/z, y=y/z)
        toAffine(iz) {
          const { px: x, py: y, pz: z } = this;
          const is0 = this.is0();
          if (iz == null)
            iz = is0 ? Fp.ONE : Fp.inv(z);
          const ax = Fp.mul(x, iz);
          const ay = Fp.mul(y, iz);
          const zz = Fp.mul(z, iz);
          if (is0)
            return { x: Fp.ZERO, y: Fp.ZERO };
          if (!Fp.eql(zz, Fp.ONE))
            throw new Error("invZ was invalid");
          return { x: ax, y: ay };
        }
        isTorsionFree() {
          const { h: cofactor, isTorsionFree } = CURVE;
          if (cofactor === _1n)
            return true;
          if (isTorsionFree)
            return isTorsionFree(Point, this);
          throw new Error("isTorsionFree() has not been declared for the elliptic curve");
        }
        clearCofactor() {
          const { h: cofactor, clearCofactor } = CURVE;
          if (cofactor === _1n)
            return this;
          if (clearCofactor)
            return clearCofactor(Point, this);
          return this.multiplyUnsafe(CURVE.h);
        }
        toRawBytes(isCompressed = true) {
          this.assertValidity();
          return toBytes(Point, this, isCompressed);
        }
        toHex(isCompressed = true) {
          return ut.bytesToHex(this.toRawBytes(isCompressed));
        }
      }
      Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
      Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
      const _bits = CURVE.nBitLength;
      const wnaf = (0, curve_js_1.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
      return {
        CURVE,
        ProjectivePoint: Point,
        normPrivateKeyToScalar,
        weierstrassEquation,
        isWithinCurveOrder
      };
    }
    exports.weierstrassPoints = weierstrassPoints;
    function validateOpts(curve) {
      const opts = (0, curve_js_1.validateBasic)(curve);
      ut.validateObject(opts, {
        hash: "hash",
        hmac: "function",
        randomBytes: "function"
      }, {
        bits2int: "function",
        bits2int_modN: "function",
        lowS: "boolean"
      });
      return Object.freeze({ lowS: true, ...opts });
    }
    function weierstrass(curveDef) {
      const CURVE = validateOpts(curveDef);
      const { Fp, n: CURVE_ORDER } = CURVE;
      const compressedLen = Fp.BYTES + 1;
      const uncompressedLen = 2 * Fp.BYTES + 1;
      function isValidFieldElement(num) {
        return _0n < num && num < Fp.ORDER;
      }
      function modN(a) {
        return mod.mod(a, CURVE_ORDER);
      }
      function invN(a) {
        return mod.invert(a, CURVE_ORDER);
      }
      const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
        ...CURVE,
        toBytes(_c, point, isCompressed) {
          const a = point.toAffine();
          const x = Fp.toBytes(a.x);
          const cat = ut.concatBytes;
          if (isCompressed) {
            return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
          } else {
            return cat(Uint8Array.from([4]), x, Fp.toBytes(a.y));
          }
        },
        fromBytes(bytes) {
          const len = bytes.length;
          const head = bytes[0];
          const tail = bytes.subarray(1);
          if (len === compressedLen && (head === 2 || head === 3)) {
            const x = ut.bytesToNumberBE(tail);
            if (!isValidFieldElement(x))
              throw new Error("Point is not on curve");
            const y2 = weierstrassEquation(x);
            let y = Fp.sqrt(y2);
            const isYOdd = (y & _1n) === _1n;
            const isHeadOdd = (head & 1) === 1;
            if (isHeadOdd !== isYOdd)
              y = Fp.neg(y);
            return { x, y };
          } else if (len === uncompressedLen && head === 4) {
            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
            return { x, y };
          } else {
            throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
          }
        }
      });
      const numToNByteStr = (num) => ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));
      function isBiggerThanHalfOrder(number) {
        const HALF = CURVE_ORDER >> _1n;
        return number > HALF;
      }
      function normalizeS(s) {
        return isBiggerThanHalfOrder(s) ? modN(-s) : s;
      }
      const slcNum = (b, from, to) => ut.bytesToNumberBE(b.slice(from, to));
      class Signature {
        constructor(r, s, recovery) {
          this.r = r;
          this.s = s;
          this.recovery = recovery;
          this.assertValidity();
        }
        // pair (bytes of r, bytes of s)
        static fromCompact(hex) {
          const l = CURVE.nByteLength;
          hex = (0, utils_js_1.ensureBytes)("compactSignature", hex, l * 2);
          return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
        }
        // DER encoded ECDSA signature
        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
        static fromDER(hex) {
          const { r, s } = exports.DER.toSig((0, utils_js_1.ensureBytes)("DER", hex));
          return new Signature(r, s);
        }
        assertValidity() {
          if (!isWithinCurveOrder(this.r))
            throw new Error("r must be 0 < r < CURVE.n");
          if (!isWithinCurveOrder(this.s))
            throw new Error("s must be 0 < s < CURVE.n");
        }
        addRecoveryBit(recovery) {
          return new Signature(this.r, this.s, recovery);
        }
        recoverPublicKey(msgHash) {
          const { r, s, recovery: rec } = this;
          const h = bits2int_modN((0, utils_js_1.ensureBytes)("msgHash", msgHash));
          if (rec == null || ![0, 1, 2, 3].includes(rec))
            throw new Error("recovery id invalid");
          const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
          if (radj >= Fp.ORDER)
            throw new Error("recovery id 2 or 3 invalid");
          const prefix = (rec & 1) === 0 ? "02" : "03";
          const R = Point.fromHex(prefix + numToNByteStr(radj));
          const ir = invN(radj);
          const u1 = modN(-h * ir);
          const u2 = modN(s * ir);
          const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
          if (!Q)
            throw new Error("point at infinify");
          Q.assertValidity();
          return Q;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
          return isBiggerThanHalfOrder(this.s);
        }
        normalizeS() {
          return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
        }
        // DER-encoded
        toDERRawBytes() {
          return ut.hexToBytes(this.toDERHex());
        }
        toDERHex() {
          return exports.DER.hexFromSig({ r: this.r, s: this.s });
        }
        // padded bytes of r, then padded bytes of s
        toCompactRawBytes() {
          return ut.hexToBytes(this.toCompactHex());
        }
        toCompactHex() {
          return numToNByteStr(this.r) + numToNByteStr(this.s);
        }
      }
      const utils = {
        isValidPrivateKey(privateKey) {
          try {
            normPrivateKeyToScalar(privateKey);
            return true;
          } catch (error) {
            return false;
          }
        },
        normPrivateKeyToScalar,
        /**
         * Produces cryptographically secure private key from random of size
         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
         */
        randomPrivateKey: () => {
          const length = mod.getMinHashLength(CURVE.n);
          return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);
        },
        /**
         * Creates precompute table for an arbitrary EC point. Makes point "cached".
         * Allows to massively speed-up `point.multiply(scalar)`.
         * @returns cached point
         * @example
         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
         * fast.multiply(privKey); // much faster ECDH now
         */
        precompute(windowSize = 8, point = Point.BASE) {
          point._setWindowSize(windowSize);
          point.multiply(BigInt(3));
          return point;
        }
      };
      function getPublicKey(privateKey, isCompressed = true) {
        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
      }
      function isProbPub(item) {
        const arr = item instanceof Uint8Array;
        const str = typeof item === "string";
        const len = (arr || str) && item.length;
        if (arr)
          return len === compressedLen || len === uncompressedLen;
        if (str)
          return len === 2 * compressedLen || len === 2 * uncompressedLen;
        if (item instanceof Point)
          return true;
        return false;
      }
      function getSharedSecret(privateA, publicB, isCompressed = true) {
        if (isProbPub(privateA))
          throw new Error("first arg must be private key");
        if (!isProbPub(publicB))
          throw new Error("second arg must be public key");
        const b = Point.fromHex(publicB);
        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
      }
      const bits2int = CURVE.bits2int || function(bytes) {
        const num = ut.bytesToNumberBE(bytes);
        const delta = bytes.length * 8 - CURVE.nBitLength;
        return delta > 0 ? num >> BigInt(delta) : num;
      };
      const bits2int_modN = CURVE.bits2int_modN || function(bytes) {
        return modN(bits2int(bytes));
      };
      const ORDER_MASK = ut.bitMask(CURVE.nBitLength);
      function int2octets(num) {
        if (typeof num !== "bigint")
          throw new Error("bigint expected");
        if (!(_0n <= num && num < ORDER_MASK))
          throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
        return ut.numberToBytesBE(num, CURVE.nByteLength);
      }
      function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
        if (["recovered", "canonical"].some((k) => k in opts))
          throw new Error("sign() legacy options not supported");
        const { hash, randomBytes } = CURVE;
        let { lowS, prehash, extraEntropy: ent } = opts;
        if (lowS == null)
          lowS = true;
        msgHash = (0, utils_js_1.ensureBytes)("msgHash", msgHash);
        if (prehash)
          msgHash = (0, utils_js_1.ensureBytes)("prehashed msgHash", hash(msgHash));
        const h1int = bits2int_modN(msgHash);
        const d = normPrivateKeyToScalar(privateKey);
        const seedArgs = [int2octets(d), int2octets(h1int)];
        if (ent != null) {
          const e = ent === true ? randomBytes(Fp.BYTES) : ent;
          seedArgs.push((0, utils_js_1.ensureBytes)("extraEntropy", e));
        }
        const seed = ut.concatBytes(...seedArgs);
        const m = h1int;
        function k2sig(kBytes) {
          const k = bits2int(kBytes);
          if (!isWithinCurveOrder(k))
            return;
          const ik = invN(k);
          const q = Point.BASE.multiply(k).toAffine();
          const r = modN(q.x);
          if (r === _0n)
            return;
          const s = modN(ik * modN(m + r * d));
          if (s === _0n)
            return;
          let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n);
          let normS = s;
          if (lowS && isBiggerThanHalfOrder(s)) {
            normS = normalizeS(s);
            recovery ^= 1;
          }
          return new Signature(r, normS, recovery);
        }
        return { seed, k2sig };
      }
      const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
      const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
      function sign(msgHash, privKey, opts = defaultSigOpts) {
        const { seed, k2sig } = prepSig(msgHash, privKey, opts);
        const C = CURVE;
        const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
        return drbg(seed, k2sig);
      }
      Point.BASE._setWindowSize(8);
      function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
        const sg = signature;
        msgHash = (0, utils_js_1.ensureBytes)("msgHash", msgHash);
        publicKey = (0, utils_js_1.ensureBytes)("publicKey", publicKey);
        if ("strict" in opts)
          throw new Error("options.strict was renamed to lowS");
        const { lowS, prehash } = opts;
        let _sig = void 0;
        let P;
        try {
          if (typeof sg === "string" || sg instanceof Uint8Array) {
            try {
              _sig = Signature.fromDER(sg);
            } catch (derError) {
              if (!(derError instanceof exports.DER.Err))
                throw derError;
              _sig = Signature.fromCompact(sg);
            }
          } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
            const { r: r2, s: s2 } = sg;
            _sig = new Signature(r2, s2);
          } else {
            throw new Error("PARSE");
          }
          P = Point.fromHex(publicKey);
        } catch (error) {
          if (error.message === "PARSE")
            throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
          return false;
        }
        if (lowS && _sig.hasHighS())
          return false;
        if (prehash)
          msgHash = CURVE.hash(msgHash);
        const { r, s } = _sig;
        const h = bits2int_modN(msgHash);
        const is = invN(s);
        const u1 = modN(h * is);
        const u2 = modN(r * is);
        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine();
        if (!R)
          return false;
        const v = modN(R.x);
        return v === r;
      }
      return {
        CURVE,
        getPublicKey,
        getSharedSecret,
        sign,
        verify,
        ProjectivePoint: Point,
        Signature,
        utils
      };
    }
    exports.weierstrass = weierstrass;
    function SWUFpSqrtRatio(Fp, Z) {
      const q = Fp.ORDER;
      let l = _0n;
      for (let o = q - _1n; o % _2n === _0n; o /= _2n)
        l += _1n;
      const c1 = l;
      const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;
      const _2n_pow_c1 = _2n_pow_c1_1 * _2n;
      const c2 = (q - _1n) / _2n_pow_c1;
      const c3 = (c2 - _1n) / _2n;
      const c4 = _2n_pow_c1 - _1n;
      const c5 = _2n_pow_c1_1;
      const c6 = Fp.pow(Z, c2);
      const c7 = Fp.pow(Z, (c2 + _1n) / _2n);
      let sqrtRatio = (u, v) => {
        let tv1 = c6;
        let tv2 = Fp.pow(v, c4);
        let tv3 = Fp.sqr(tv2);
        tv3 = Fp.mul(tv3, v);
        let tv5 = Fp.mul(u, tv3);
        tv5 = Fp.pow(tv5, c3);
        tv5 = Fp.mul(tv5, tv2);
        tv2 = Fp.mul(tv5, v);
        tv3 = Fp.mul(tv5, u);
        let tv4 = Fp.mul(tv3, tv2);
        tv5 = Fp.pow(tv4, c5);
        let isQR = Fp.eql(tv5, Fp.ONE);
        tv2 = Fp.mul(tv3, c7);
        tv5 = Fp.mul(tv4, tv1);
        tv3 = Fp.cmov(tv2, tv3, isQR);
        tv4 = Fp.cmov(tv5, tv4, isQR);
        for (let i = c1; i > _1n; i--) {
          let tv52 = i - _2n;
          tv52 = _2n << tv52 - _1n;
          let tvv5 = Fp.pow(tv4, tv52);
          const e1 = Fp.eql(tvv5, Fp.ONE);
          tv2 = Fp.mul(tv3, tv1);
          tv1 = Fp.mul(tv1, tv1);
          tvv5 = Fp.mul(tv4, tv1);
          tv3 = Fp.cmov(tv2, tv3, e1);
          tv4 = Fp.cmov(tvv5, tv4, e1);
        }
        return { isValid: isQR, value: tv3 };
      };
      if (Fp.ORDER % _4n === _3n) {
        const c12 = (Fp.ORDER - _3n) / _4n;
        const c22 = Fp.sqrt(Fp.neg(Z));
        sqrtRatio = (u, v) => {
          let tv1 = Fp.sqr(v);
          const tv2 = Fp.mul(u, v);
          tv1 = Fp.mul(tv1, tv2);
          let y1 = Fp.pow(tv1, c12);
          y1 = Fp.mul(y1, tv2);
          const y2 = Fp.mul(y1, c22);
          const tv3 = Fp.mul(Fp.sqr(y1), v);
          const isQR = Fp.eql(tv3, u);
          let y = Fp.cmov(y2, y1, isQR);
          return { isValid: isQR, value: y };
        };
      }
      return sqrtRatio;
    }
    exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
    function mapToCurveSimpleSWU(Fp, opts) {
      mod.validateField(Fp);
      if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))
        throw new Error("mapToCurveSimpleSWU: invalid opts");
      const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);
      if (!Fp.isOdd)
        throw new Error("Fp.isOdd is not implemented!");
      return (u) => {
        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
        tv1 = Fp.sqr(u);
        tv1 = Fp.mul(tv1, opts.Z);
        tv2 = Fp.sqr(tv1);
        tv2 = Fp.add(tv2, tv1);
        tv3 = Fp.add(tv2, Fp.ONE);
        tv3 = Fp.mul(tv3, opts.B);
        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO));
        tv4 = Fp.mul(tv4, opts.A);
        tv2 = Fp.sqr(tv3);
        tv6 = Fp.sqr(tv4);
        tv5 = Fp.mul(tv6, opts.A);
        tv2 = Fp.add(tv2, tv5);
        tv2 = Fp.mul(tv2, tv3);
        tv6 = Fp.mul(tv6, tv4);
        tv5 = Fp.mul(tv6, opts.B);
        tv2 = Fp.add(tv2, tv5);
        x = Fp.mul(tv1, tv3);
        const { isValid, value } = sqrtRatio(tv2, tv6);
        y = Fp.mul(tv1, u);
        y = Fp.mul(y, value);
        x = Fp.cmov(x, tv3, isValid);
        y = Fp.cmov(y, value, isValid);
        const e1 = Fp.isOdd(u) === Fp.isOdd(y);
        y = Fp.cmov(Fp.neg(y), y, e1);
        x = Fp.div(x, tv4);
        return { x, y };
      };
    }
    exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
  }
});

// node_modules/@noble/curves/abstract/hash-to-curve.js
var require_hash_to_curve = __commonJS({
  "node_modules/@noble/curves/abstract/hash-to-curve.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createHasher = exports.isogenyMap = exports.hash_to_field = exports.expand_message_xof = exports.expand_message_xmd = void 0;
    var modular_js_1 = require_modular();
    var utils_js_1 = require_utils7();
    function validateDST(dst) {
      if (dst instanceof Uint8Array)
        return dst;
      if (typeof dst === "string")
        return (0, utils_js_1.utf8ToBytes)(dst);
      throw new Error("DST must be Uint8Array or string");
    }
    var os2ip = utils_js_1.bytesToNumberBE;
    function i2osp(value, length) {
      if (value < 0 || value >= 1 << 8 * length) {
        throw new Error(`bad I2OSP call: value=${value} length=${length}`);
      }
      const res = Array.from({ length }).fill(0);
      for (let i = length - 1; i >= 0; i--) {
        res[i] = value & 255;
        value >>>= 8;
      }
      return new Uint8Array(res);
    }
    function strxor(a, b) {
      const arr = new Uint8Array(a.length);
      for (let i = 0; i < a.length; i++) {
        arr[i] = a[i] ^ b[i];
      }
      return arr;
    }
    function isBytes(item) {
      if (!(item instanceof Uint8Array))
        throw new Error("Uint8Array expected");
    }
    function isNum(item) {
      if (!Number.isSafeInteger(item))
        throw new Error("number expected");
    }
    function expand_message_xmd(msg, DST, lenInBytes, H) {
      isBytes(msg);
      isBytes(DST);
      isNum(lenInBytes);
      if (DST.length > 255)
        DST = H((0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-"), DST));
      const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
      const ell = Math.ceil(lenInBytes / b_in_bytes);
      if (ell > 255)
        throw new Error("Invalid xmd length");
      const DST_prime = (0, utils_js_1.concatBytes)(DST, i2osp(DST.length, 1));
      const Z_pad = i2osp(0, r_in_bytes);
      const l_i_b_str = i2osp(lenInBytes, 2);
      const b = new Array(ell);
      const b_0 = H((0, utils_js_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
      b[0] = H((0, utils_js_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
      for (let i = 1; i <= ell; i++) {
        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
        b[i] = H((0, utils_js_1.concatBytes)(...args));
      }
      const pseudo_random_bytes = (0, utils_js_1.concatBytes)(...b);
      return pseudo_random_bytes.slice(0, lenInBytes);
    }
    exports.expand_message_xmd = expand_message_xmd;
    function expand_message_xof(msg, DST, lenInBytes, k, H) {
      isBytes(msg);
      isBytes(DST);
      isNum(lenInBytes);
      if (DST.length > 255) {
        const dkLen = Math.ceil(2 * k / 8);
        DST = H.create({ dkLen }).update((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(DST).digest();
      }
      if (lenInBytes > 65535 || DST.length > 255)
        throw new Error("expand_message_xof: invalid lenInBytes");
      return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
    }
    exports.expand_message_xof = expand_message_xof;
    function hash_to_field(msg, count, options) {
      (0, utils_js_1.validateObject)(options, {
        DST: "stringOrUint8Array",
        p: "bigint",
        m: "isSafeInteger",
        k: "isSafeInteger",
        hash: "hash"
      });
      const { p, k, m, hash, expand, DST: _DST } = options;
      isBytes(msg);
      isNum(count);
      const DST = validateDST(_DST);
      const log2p = p.toString(2).length;
      const L = Math.ceil((log2p + k) / 8);
      const len_in_bytes = count * m * L;
      let prb;
      if (expand === "xmd") {
        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
      } else if (expand === "xof") {
        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
      } else if (expand === "_internal_pass") {
        prb = msg;
      } else {
        throw new Error('expand must be "xmd" or "xof"');
      }
      const u = new Array(count);
      for (let i = 0; i < count; i++) {
        const e = new Array(m);
        for (let j = 0; j < m; j++) {
          const elm_offset = L * (j + i * m);
          const tv = prb.subarray(elm_offset, elm_offset + L);
          e[j] = (0, modular_js_1.mod)(os2ip(tv), p);
        }
        u[i] = e;
      }
      return u;
    }
    exports.hash_to_field = hash_to_field;
    function isogenyMap(field, map) {
      const COEFF = map.map((i) => Array.from(i).reverse());
      return (x, y) => {
        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
        x = field.div(xNum, xDen);
        y = field.mul(y, field.div(yNum, yDen));
        return { x, y };
      };
    }
    exports.isogenyMap = isogenyMap;
    function createHasher(Point, mapToCurve, def) {
      if (typeof mapToCurve !== "function")
        throw new Error("mapToCurve() must be defined");
      return {
        // Encodes byte string to elliptic curve.
        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        hashToCurve(msg, options) {
          const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
          const u0 = Point.fromAffine(mapToCurve(u[0]));
          const u1 = Point.fromAffine(mapToCurve(u[1]));
          const P = u0.add(u1).clearCofactor();
          P.assertValidity();
          return P;
        },
        // Encodes byte string to elliptic curve.
        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        encodeToCurve(msg, options) {
          const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
          const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();
          P.assertValidity();
          return P;
        }
      };
    }
    exports.createHasher = createHasher;
  }
});

// node_modules/@noble/hashes/hmac.js
var require_hmac = __commonJS({
  "node_modules/@noble/hashes/hmac.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hmac = exports.HMAC = void 0;
    var _assert_js_1 = require_assert();
    var utils_js_1 = require_utils5();
    var HMAC = class extends utils_js_1.Hash {
      constructor(hash, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        (0, _assert_js_1.hash)(hash);
        const key = (0, utils_js_1.toBytes)(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== "function")
          throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54;
        this.iHash.update(pad);
        this.oHash = hash.create();
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54 ^ 92;
        this.oHash.update(pad);
        pad.fill(0);
      }
      update(buf) {
        (0, _assert_js_1.exists)(this);
        this.iHash.update(buf);
        return this;
      }
      digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.bytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
      digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
      _cloneInto(to) {
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
      }
      destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    };
    exports.HMAC = HMAC;
    var hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
    exports.hmac = hmac;
    exports.hmac.create = (hash, key) => new HMAC(hash, key);
  }
});

// node_modules/@noble/curves/_shortw_utils.js
var require_shortw_utils = __commonJS({
  "node_modules/@noble/curves/_shortw_utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createCurve = exports.getHash = void 0;
    var hmac_1 = require_hmac();
    var utils_1 = require_utils5();
    var weierstrass_js_1 = require_weierstrass();
    function getHash(hash) {
      return {
        hash,
        hmac: (key, ...msgs) => (0, hmac_1.hmac)(hash, key, (0, utils_1.concatBytes)(...msgs)),
        randomBytes: utils_1.randomBytes
      };
    }
    exports.getHash = getHash;
    function createCurve(curveDef, defHash) {
      const create = (hash) => (0, weierstrass_js_1.weierstrass)({ ...curveDef, ...getHash(hash) });
      return Object.freeze({ ...create(defHash), create });
    }
    exports.createCurve = createCurve;
  }
});

// node_modules/@noble/curves/secp256k1.js
var require_secp256k1 = __commonJS({
  "node_modules/@noble/curves/secp256k1.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeToCurve = exports.hashToCurve = exports.schnorr = exports.secp256k1 = void 0;
    var sha256_1 = require_sha256();
    var utils_1 = require_utils5();
    var modular_js_1 = require_modular();
    var weierstrass_js_1 = require_weierstrass();
    var utils_js_1 = require_utils7();
    var hash_to_curve_js_1 = require_hash_to_curve();
    var _shortw_utils_js_1 = require_shortw_utils();
    var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
    var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var divNearest = (a, b) => (a + b / _2n) / b;
    function sqrtMod(y) {
      const P = secp256k1P;
      const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
      const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
      const b2 = y * y * y % P;
      const b3 = b2 * b2 * y % P;
      const b6 = (0, modular_js_1.pow2)(b3, _3n, P) * b3 % P;
      const b9 = (0, modular_js_1.pow2)(b6, _3n, P) * b3 % P;
      const b11 = (0, modular_js_1.pow2)(b9, _2n, P) * b2 % P;
      const b22 = (0, modular_js_1.pow2)(b11, _11n, P) * b11 % P;
      const b44 = (0, modular_js_1.pow2)(b22, _22n, P) * b22 % P;
      const b88 = (0, modular_js_1.pow2)(b44, _44n, P) * b44 % P;
      const b176 = (0, modular_js_1.pow2)(b88, _88n, P) * b88 % P;
      const b220 = (0, modular_js_1.pow2)(b176, _44n, P) * b44 % P;
      const b223 = (0, modular_js_1.pow2)(b220, _3n, P) * b3 % P;
      const t1 = (0, modular_js_1.pow2)(b223, _23n, P) * b22 % P;
      const t2 = (0, modular_js_1.pow2)(t1, _6n, P) * b2 % P;
      const root = (0, modular_js_1.pow2)(t2, _2n, P);
      if (!Fp.eql(Fp.sqr(root), y))
        throw new Error("Cannot find square root");
      return root;
    }
    var Fp = (0, modular_js_1.Field)(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
    exports.secp256k1 = (0, _shortw_utils_js_1.createCurve)({
      a: BigInt(0),
      b: BigInt(7),
      Fp,
      n: secp256k1N,
      // Base point (x, y) aka generator point
      Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
      Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
      h: BigInt(1),
      lowS: true,
      /**
       * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
       * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
       * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
       * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
       */
      endo: {
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
        splitScalar: (k) => {
          const n = secp256k1N;
          const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
          const b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
          const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
          const b2 = a1;
          const POW_2_128 = BigInt("0x100000000000000000000000000000000");
          const c1 = divNearest(b2 * k, n);
          const c2 = divNearest(-b1 * k, n);
          let k1 = (0, modular_js_1.mod)(k - c1 * a1 - c2 * a2, n);
          let k2 = (0, modular_js_1.mod)(-c1 * b1 - c2 * b2, n);
          const k1neg = k1 > POW_2_128;
          const k2neg = k2 > POW_2_128;
          if (k1neg)
            k1 = n - k1;
          if (k2neg)
            k2 = n - k2;
          if (k1 > POW_2_128 || k2 > POW_2_128) {
            throw new Error("splitScalar: Endomorphism failed, k=" + k);
          }
          return { k1neg, k1, k2neg, k2 };
        }
      }
    }, sha256_1.sha256);
    var _0n = BigInt(0);
    var fe = (x) => typeof x === "bigint" && _0n < x && x < secp256k1P;
    var ge = (x) => typeof x === "bigint" && _0n < x && x < secp256k1N;
    var TAGGED_HASH_PREFIXES = {};
    function taggedHash(tag, ...messages) {
      let tagP = TAGGED_HASH_PREFIXES[tag];
      if (tagP === void 0) {
        const tagH = (0, sha256_1.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
        tagP = (0, utils_js_1.concatBytes)(tagH, tagH);
        TAGGED_HASH_PREFIXES[tag] = tagP;
      }
      return (0, sha256_1.sha256)((0, utils_js_1.concatBytes)(tagP, ...messages));
    }
    var pointToBytes = (point) => point.toRawBytes(true).slice(1);
    var numTo32b = (n) => (0, utils_js_1.numberToBytesBE)(n, 32);
    var modP = (x) => (0, modular_js_1.mod)(x, secp256k1P);
    var modN = (x) => (0, modular_js_1.mod)(x, secp256k1N);
    var Point = exports.secp256k1.ProjectivePoint;
    var GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);
    function schnorrGetExtPubKey(priv) {
      let d_ = exports.secp256k1.utils.normPrivateKeyToScalar(priv);
      let p = Point.fromPrivateKey(d_);
      const scalar = p.hasEvenY() ? d_ : modN(-d_);
      return { scalar, bytes: pointToBytes(p) };
    }
    function lift_x(x) {
      if (!fe(x))
        throw new Error("bad x: need 0 < x < p");
      const xx = modP(x * x);
      const c = modP(xx * x + BigInt(7));
      let y = sqrtMod(c);
      if (y % _2n !== _0n)
        y = modP(-y);
      const p = new Point(x, y, _1n);
      p.assertValidity();
      return p;
    }
    function challenge(...args) {
      return modN((0, utils_js_1.bytesToNumberBE)(taggedHash("BIP0340/challenge", ...args)));
    }
    function schnorrGetPublicKey(privateKey) {
      return schnorrGetExtPubKey(privateKey).bytes;
    }
    function schnorrSign(message, privateKey, auxRand = (0, utils_1.randomBytes)(32)) {
      const m = (0, utils_js_1.ensureBytes)("message", message);
      const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey);
      const a = (0, utils_js_1.ensureBytes)("auxRand", auxRand, 32);
      const t = numTo32b(d ^ (0, utils_js_1.bytesToNumberBE)(taggedHash("BIP0340/aux", a)));
      const rand = taggedHash("BIP0340/nonce", t, px, m);
      const k_ = modN((0, utils_js_1.bytesToNumberBE)(rand));
      if (k_ === _0n)
        throw new Error("sign failed: k is zero");
      const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_);
      const e = challenge(rx, px, m);
      const sig = new Uint8Array(64);
      sig.set(rx, 0);
      sig.set(numTo32b(modN(k + e * d)), 32);
      if (!schnorrVerify(sig, m, px))
        throw new Error("sign: Invalid signature produced");
      return sig;
    }
    function schnorrVerify(signature, message, publicKey) {
      const sig = (0, utils_js_1.ensureBytes)("signature", signature, 64);
      const m = (0, utils_js_1.ensureBytes)("message", message);
      const pub = (0, utils_js_1.ensureBytes)("publicKey", publicKey, 32);
      try {
        const P = lift_x((0, utils_js_1.bytesToNumberBE)(pub));
        const r = (0, utils_js_1.bytesToNumberBE)(sig.subarray(0, 32));
        if (!fe(r))
          return false;
        const s = (0, utils_js_1.bytesToNumberBE)(sig.subarray(32, 64));
        if (!ge(s))
          return false;
        const e = challenge(numTo32b(r), pointToBytes(P), m);
        const R = GmulAdd(P, s, modN(-e));
        if (!R || !R.hasEvenY() || R.toAffine().x !== r)
          return false;
        return true;
      } catch (error) {
        return false;
      }
    }
    exports.schnorr = (() => ({
      getPublicKey: schnorrGetPublicKey,
      sign: schnorrSign,
      verify: schnorrVerify,
      utils: {
        randomPrivateKey: exports.secp256k1.utils.randomPrivateKey,
        lift_x,
        pointToBytes,
        numberToBytesBE: utils_js_1.numberToBytesBE,
        bytesToNumberBE: utils_js_1.bytesToNumberBE,
        taggedHash,
        mod: modular_js_1.mod
      }
    }))();
    var isoMap = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.isogenyMap)(Fp, [
      // xNum
      [
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
        "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
        "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
      ],
      // xDen
      [
        "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
        "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
        // LAST 1
      ],
      // yNum
      [
        "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
        "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
        "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
        "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
      ],
      // yDen
      [
        "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
        "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
        "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
        // LAST 1
      ]
    ].map((i) => i.map((j) => BigInt(j)))))();
    var mapSWU = /* @__PURE__ */ (() => (0, weierstrass_js_1.mapToCurveSimpleSWU)(Fp, {
      A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
      B: BigInt("1771"),
      Z: Fp.create(BigInt("-11"))
    }))();
    var htf = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.createHasher)(exports.secp256k1.ProjectivePoint, (scalars) => {
      const { x, y } = mapSWU(Fp.create(scalars[0]));
      return isoMap(x, y);
    }, {
      DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
      encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
      p: Fp.ORDER,
      m: 1,
      k: 128,
      expand: "xmd",
      hash: sha256_1.sha256
    }))();
    exports.hashToCurve = (() => htf.hashToCurve)();
    exports.encodeToCurve = (() => htf.encodeToCurve)();
  }
});

// node_modules/viem/_cjs/utils/signature/recoverPublicKey.js
var require_recoverPublicKey = __commonJS({
  "node_modules/viem/_cjs/utils/signature/recoverPublicKey.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.recoverPublicKey = void 0;
    var isHex_js_1 = require_isHex();
    var fromHex_js_1 = require_fromHex();
    var toHex_js_1 = require_toHex();
    async function recoverPublicKey({ hash, signature }) {
      const signatureHex = (0, isHex_js_1.isHex)(signature) ? signature : (0, toHex_js_1.toHex)(signature);
      const hashHex = (0, isHex_js_1.isHex)(hash) ? hash : (0, toHex_js_1.toHex)(hash);
      let v = (0, fromHex_js_1.hexToNumber)(`0x${signatureHex.slice(130)}`);
      if (v === 0 || v === 1)
        v += 27;
      const { secp256k1 } = await Promise.resolve().then(() => require_secp256k1());
      const publicKey = secp256k1.Signature.fromCompact(signatureHex.substring(2, 130)).addRecoveryBit(v - 27).recoverPublicKey(hashHex.substring(2)).toHex(false);
      return `0x${publicKey}`;
    }
    exports.recoverPublicKey = recoverPublicKey;
  }
});

// node_modules/viem/_cjs/utils/signature/recoverAddress.js
var require_recoverAddress = __commonJS({
  "node_modules/viem/_cjs/utils/signature/recoverAddress.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.recoverAddress = void 0;
    var publicKeyToAddress_js_1 = require_publicKeyToAddress();
    var recoverPublicKey_js_1 = require_recoverPublicKey();
    async function recoverAddress({ hash, signature }) {
      return (0, publicKeyToAddress_js_1.publicKeyToAddress)(await (0, recoverPublicKey_js_1.recoverPublicKey)({ hash, signature }));
    }
    exports.recoverAddress = recoverAddress;
  }
});

// node_modules/viem/_cjs/utils/signature/hashMessage.js
var require_hashMessage = __commonJS({
  "node_modules/viem/_cjs/utils/signature/hashMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashMessage = void 0;
    var concat_js_1 = require_concat();
    var toBytes_js_1 = require_toBytes();
    var keccak256_js_1 = require_keccak256();
    function hashMessage(message, to_) {
      const messageBytes = (() => {
        if (typeof message === "string")
          return (0, toBytes_js_1.stringToBytes)(message);
        if (message.raw instanceof Uint8Array)
          return message.raw;
        return (0, toBytes_js_1.toBytes)(message.raw);
      })();
      const prefixBytes = (0, toBytes_js_1.stringToBytes)(`Ethereum Signed Message:
${messageBytes.length}`);
      return (0, keccak256_js_1.keccak256)((0, concat_js_1.concat)([prefixBytes, messageBytes]), to_);
    }
    exports.hashMessage = hashMessage;
  }
});

// node_modules/viem/_cjs/utils/signature/recoverMessageAddress.js
var require_recoverMessageAddress = __commonJS({
  "node_modules/viem/_cjs/utils/signature/recoverMessageAddress.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.recoverMessageAddress = void 0;
    var hashMessage_js_1 = require_hashMessage();
    var recoverAddress_js_1 = require_recoverAddress();
    async function recoverMessageAddress({ message, signature }) {
      return (0, recoverAddress_js_1.recoverAddress)({ hash: (0, hashMessage_js_1.hashMessage)(message), signature });
    }
    exports.recoverMessageAddress = recoverMessageAddress;
  }
});

// node_modules/viem/_cjs/utils/signature/recoverTypedDataAddress.js
var require_recoverTypedDataAddress = __commonJS({
  "node_modules/viem/_cjs/utils/signature/recoverTypedDataAddress.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.recoverTypedDataAddress = void 0;
    var hashTypedData_js_1 = require_hashTypedData();
    var recoverAddress_js_1 = require_recoverAddress();
    async function recoverTypedDataAddress({ domain, message, primaryType, signature, types }) {
      return (0, recoverAddress_js_1.recoverAddress)({
        hash: (0, hashTypedData_js_1.hashTypedData)({
          domain,
          message,
          primaryType,
          types
        }),
        signature
      });
    }
    exports.recoverTypedDataAddress = recoverTypedDataAddress;
  }
});

// node_modules/viem/_cjs/utils/signature/verifyMessage.js
var require_verifyMessage = __commonJS({
  "node_modules/viem/_cjs/utils/signature/verifyMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.verifyMessage = void 0;
    var getAddress_js_1 = require_getAddress();
    var isAddressEqual_js_1 = require_isAddressEqual();
    var recoverMessageAddress_js_1 = require_recoverMessageAddress();
    async function verifyMessage({ address, message, signature }) {
      return (0, isAddressEqual_js_1.isAddressEqual)((0, getAddress_js_1.getAddress)(address), await (0, recoverMessageAddress_js_1.recoverMessageAddress)({ message, signature }));
    }
    exports.verifyMessage = verifyMessage;
  }
});

// node_modules/viem/_cjs/utils/signature/verifyTypedData.js
var require_verifyTypedData = __commonJS({
  "node_modules/viem/_cjs/utils/signature/verifyTypedData.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.verifyTypedData = void 0;
    var getAddress_js_1 = require_getAddress();
    var isAddressEqual_js_1 = require_isAddressEqual();
    var recoverTypedDataAddress_js_1 = require_recoverTypedDataAddress();
    async function verifyTypedData({ address, domain, message, primaryType, signature, types }) {
      return (0, isAddressEqual_js_1.isAddressEqual)((0, getAddress_js_1.getAddress)(address), await (0, recoverTypedDataAddress_js_1.recoverTypedDataAddress)({
        domain,
        message,
        primaryType,
        signature,
        types
      }));
    }
    exports.verifyTypedData = verifyTypedData;
  }
});

// node_modules/viem/_cjs/utils/transaction/getSerializedTransactionType.js
var require_getSerializedTransactionType = __commonJS({
  "node_modules/viem/_cjs/utils/transaction/getSerializedTransactionType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSerializedTransactionType = void 0;
    var transaction_js_1 = require_transaction2();
    var slice_js_1 = require_slice();
    var fromHex_js_1 = require_fromHex();
    function getSerializedTransactionType(serializedTransaction) {
      const serializedType = (0, slice_js_1.sliceHex)(serializedTransaction, 0, 1);
      if (serializedType === "0x02")
        return "eip1559";
      if (serializedType === "0x01")
        return "eip2930";
      if (serializedType !== "0x" && (0, fromHex_js_1.hexToNumber)(serializedType) >= 192)
        return "legacy";
      throw new transaction_js_1.InvalidSerializedTransactionTypeError({ serializedType });
    }
    exports.getSerializedTransactionType = getSerializedTransactionType;
  }
});

// node_modules/viem/_cjs/utils/transaction/parseTransaction.js
var require_parseTransaction = __commonJS({
  "node_modules/viem/_cjs/utils/transaction/parseTransaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseAccessList = exports.toTransactionArray = exports.parseTransaction = void 0;
    var address_js_1 = require_address();
    var transaction_js_1 = require_transaction2();
    var isAddress_js_1 = require_isAddress();
    var isHex_js_1 = require_isHex();
    var pad_js_1 = require_pad();
    var trim_js_1 = require_trim();
    var fromHex_js_1 = require_fromHex();
    var fromRlp_js_1 = require_fromRlp();
    var isHash_js_1 = require_isHash();
    var assertTransaction_js_1 = require_assertTransaction();
    var getSerializedTransactionType_js_1 = require_getSerializedTransactionType();
    function parseTransaction(serializedTransaction) {
      const type = (0, getSerializedTransactionType_js_1.getSerializedTransactionType)(serializedTransaction);
      if (type === "eip1559")
        return parseTransactionEIP1559(serializedTransaction);
      if (type === "eip2930")
        return parseTransactionEIP2930(serializedTransaction);
      return parseTransactionLegacy(serializedTransaction);
    }
    exports.parseTransaction = parseTransaction;
    function parseTransactionEIP1559(serializedTransaction) {
      const transactionArray = toTransactionArray(serializedTransaction);
      const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList, v, r, s] = transactionArray;
      if (!(transactionArray.length === 9 || transactionArray.length === 12))
        throw new transaction_js_1.InvalidSerializedTransactionError({
          attributes: {
            chainId,
            nonce,
            maxPriorityFeePerGas,
            maxFeePerGas,
            gas,
            to,
            value,
            data,
            accessList,
            ...transactionArray.length > 9 ? {
              v,
              r,
              s
            } : {}
          },
          serializedTransaction,
          type: "eip1559"
        });
      const transaction = {
        chainId: (0, fromHex_js_1.hexToNumber)(chainId),
        type: "eip1559"
      };
      if ((0, isHex_js_1.isHex)(to) && to !== "0x")
        transaction.to = to;
      if ((0, isHex_js_1.isHex)(gas) && gas !== "0x")
        transaction.gas = (0, fromHex_js_1.hexToBigInt)(gas);
      if ((0, isHex_js_1.isHex)(data) && data !== "0x")
        transaction.data = data;
      if ((0, isHex_js_1.isHex)(nonce) && nonce !== "0x")
        transaction.nonce = (0, fromHex_js_1.hexToNumber)(nonce);
      if ((0, isHex_js_1.isHex)(value) && value !== "0x")
        transaction.value = (0, fromHex_js_1.hexToBigInt)(value);
      if ((0, isHex_js_1.isHex)(maxFeePerGas) && maxFeePerGas !== "0x")
        transaction.maxFeePerGas = (0, fromHex_js_1.hexToBigInt)(maxFeePerGas);
      if ((0, isHex_js_1.isHex)(maxPriorityFeePerGas) && maxPriorityFeePerGas !== "0x")
        transaction.maxPriorityFeePerGas = (0, fromHex_js_1.hexToBigInt)(maxPriorityFeePerGas);
      if (accessList.length !== 0 && accessList !== "0x")
        transaction.accessList = parseAccessList(accessList);
      (0, assertTransaction_js_1.assertTransactionEIP1559)(transaction);
      const signature = transactionArray.length === 12 ? parseEIP155Signature(transactionArray) : void 0;
      return { ...signature, ...transaction };
    }
    function parseTransactionEIP2930(serializedTransaction) {
      const transactionArray = toTransactionArray(serializedTransaction);
      const [chainId, nonce, gasPrice, gas, to, value, data, accessList, v, r, s] = transactionArray;
      if (!(transactionArray.length === 8 || transactionArray.length === 11))
        throw new transaction_js_1.InvalidSerializedTransactionError({
          attributes: {
            chainId,
            nonce,
            gasPrice,
            gas,
            to,
            value,
            data,
            accessList,
            ...transactionArray.length > 8 ? {
              v,
              r,
              s
            } : {}
          },
          serializedTransaction,
          type: "eip2930"
        });
      const transaction = {
        chainId: (0, fromHex_js_1.hexToNumber)(chainId),
        type: "eip2930"
      };
      if ((0, isHex_js_1.isHex)(to) && to !== "0x")
        transaction.to = to;
      if ((0, isHex_js_1.isHex)(gas) && gas !== "0x")
        transaction.gas = (0, fromHex_js_1.hexToBigInt)(gas);
      if ((0, isHex_js_1.isHex)(data) && data !== "0x")
        transaction.data = data;
      if ((0, isHex_js_1.isHex)(nonce) && nonce !== "0x")
        transaction.nonce = (0, fromHex_js_1.hexToNumber)(nonce);
      if ((0, isHex_js_1.isHex)(value) && value !== "0x")
        transaction.value = (0, fromHex_js_1.hexToBigInt)(value);
      if ((0, isHex_js_1.isHex)(gasPrice) && gasPrice !== "0x")
        transaction.gasPrice = (0, fromHex_js_1.hexToBigInt)(gasPrice);
      if (accessList.length !== 0 && accessList !== "0x")
        transaction.accessList = parseAccessList(accessList);
      (0, assertTransaction_js_1.assertTransactionEIP2930)(transaction);
      const signature = transactionArray.length === 11 ? parseEIP155Signature(transactionArray) : void 0;
      return { ...signature, ...transaction };
    }
    function parseTransactionLegacy(serializedTransaction) {
      const transactionArray = (0, fromRlp_js_1.fromRlp)(serializedTransaction, "hex");
      const [nonce, gasPrice, gas, to, value, data, chainIdOrV_, r, s] = transactionArray;
      if (!(transactionArray.length === 6 || transactionArray.length === 9))
        throw new transaction_js_1.InvalidSerializedTransactionError({
          attributes: {
            nonce,
            gasPrice,
            gas,
            to,
            value,
            data,
            ...transactionArray.length > 6 ? {
              v: chainIdOrV_,
              r,
              s
            } : {}
          },
          serializedTransaction,
          type: "legacy"
        });
      const transaction = {
        type: "legacy"
      };
      if ((0, isHex_js_1.isHex)(to) && to !== "0x")
        transaction.to = to;
      if ((0, isHex_js_1.isHex)(gas) && gas !== "0x")
        transaction.gas = (0, fromHex_js_1.hexToBigInt)(gas);
      if ((0, isHex_js_1.isHex)(data) && data !== "0x")
        transaction.data = data;
      if ((0, isHex_js_1.isHex)(nonce) && nonce !== "0x")
        transaction.nonce = (0, fromHex_js_1.hexToNumber)(nonce);
      if ((0, isHex_js_1.isHex)(value) && value !== "0x")
        transaction.value = (0, fromHex_js_1.hexToBigInt)(value);
      if ((0, isHex_js_1.isHex)(gasPrice) && gasPrice !== "0x")
        transaction.gasPrice = (0, fromHex_js_1.hexToBigInt)(gasPrice);
      (0, assertTransaction_js_1.assertTransactionLegacy)(transaction);
      if (transactionArray.length === 6)
        return transaction;
      const chainIdOrV = (0, isHex_js_1.isHex)(chainIdOrV_) && chainIdOrV_ !== "0x" ? (0, fromHex_js_1.hexToBigInt)(chainIdOrV_) : 0n;
      if (s === "0x" && r === "0x") {
        if (chainIdOrV > 0)
          transaction.chainId = Number(chainIdOrV);
        return transaction;
      }
      const v = chainIdOrV;
      const chainId = Number((v - 35n) / 2n);
      if (chainId > 0)
        transaction.chainId = chainId;
      else if (v !== 27n && v !== 28n)
        throw new transaction_js_1.InvalidLegacyVError({ v });
      transaction.v = v;
      transaction.s = s;
      transaction.r = r;
      return transaction;
    }
    function toTransactionArray(serializedTransaction) {
      return (0, fromRlp_js_1.fromRlp)(`0x${serializedTransaction.slice(4)}`, "hex");
    }
    exports.toTransactionArray = toTransactionArray;
    function parseAccessList(accessList_) {
      const accessList = [];
      for (let i = 0; i < accessList_.length; i++) {
        const [address, storageKeys] = accessList_[i];
        if (!(0, isAddress_js_1.isAddress)(address))
          throw new address_js_1.InvalidAddressError({ address });
        accessList.push({
          address,
          storageKeys: storageKeys.map((key) => (0, isHash_js_1.isHash)(key) ? key : (0, trim_js_1.trim)(key))
        });
      }
      return accessList;
    }
    exports.parseAccessList = parseAccessList;
    function parseEIP155Signature(transactionArray) {
      const signature = transactionArray.slice(-3);
      const v = signature[0] === "0x" || (0, fromHex_js_1.hexToBigInt)(signature[0]) === 0n ? 27n : 28n;
      return {
        r: (0, pad_js_1.padHex)(signature[1], { size: 32 }),
        s: (0, pad_js_1.padHex)(signature[2], { size: 32 }),
        v,
        yParity: v === 27n ? 0 : 1
      };
    }
  }
});

// node_modules/viem/_cjs/utils/unit/parseUnits.js
var require_parseUnits = __commonJS({
  "node_modules/viem/_cjs/utils/unit/parseUnits.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseUnits = void 0;
    function parseUnits(value, decimals) {
      let [integer, fraction = "0"] = value.split(".");
      const negative = integer.startsWith("-");
      if (negative)
        integer = integer.slice(1);
      fraction = fraction.replace(/(0+)$/, "");
      if (decimals === 0) {
        if (Math.round(Number(`.${fraction}`)) === 1)
          integer = `${BigInt(integer) + 1n}`;
        fraction = "";
      } else if (fraction.length > decimals) {
        const [left, unit, right] = [
          fraction.slice(0, decimals - 1),
          fraction.slice(decimals - 1, decimals),
          fraction.slice(decimals)
        ];
        const rounded = Math.round(Number(`${unit}.${right}`));
        if (rounded > 9)
          fraction = `${BigInt(left) + BigInt(1)}0`.padStart(left.length + 1, "0");
        else
          fraction = `${left}${rounded}`;
        if (fraction.length > decimals) {
          fraction = fraction.slice(1);
          integer = `${BigInt(integer) + 1n}`;
        }
        fraction = fraction.slice(0, decimals);
      } else {
        fraction = fraction.padEnd(decimals, "0");
      }
      return BigInt(`${negative ? "-" : ""}${integer}${fraction}`);
    }
    exports.parseUnits = parseUnits;
  }
});

// node_modules/viem/_cjs/utils/unit/parseEther.js
var require_parseEther = __commonJS({
  "node_modules/viem/_cjs/utils/unit/parseEther.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseEther = void 0;
    var unit_js_1 = require_unit();
    var parseUnits_js_1 = require_parseUnits();
    function parseEther(ether, unit = "wei") {
      return (0, parseUnits_js_1.parseUnits)(ether, unit_js_1.etherUnits[unit]);
    }
    exports.parseEther = parseEther;
  }
});

// node_modules/viem/_cjs/utils/unit/parseGwei.js
var require_parseGwei = __commonJS({
  "node_modules/viem/_cjs/utils/unit/parseGwei.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseGwei = void 0;
    var unit_js_1 = require_unit();
    var parseUnits_js_1 = require_parseUnits();
    function parseGwei(ether, unit = "wei") {
      return (0, parseUnits_js_1.parseUnits)(ether, unit_js_1.gweiUnits[unit]);
    }
    exports.parseGwei = parseGwei;
  }
});

// node_modules/viem/_cjs/utils/index.js
var require_utils8 = __commonJS({
  "node_modules/viem/_cjs/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.concatHex = exports.concatBytes = exports.concat = exports.extractFunctionParts = exports.extractFunctionType = exports.extractFunctionParams = exports.extractFunctionName = exports.isAddressEqual = exports.isAddress = exports.getAddress = exports.getCreate2Address = exports.getCreateAddress = exports.getContractAddress = exports.publicKeyToAddress = exports.parseAccount = exports.formatAbiParams = exports.formatAbiItem = exports.formatAbiItemWithArgs = exports.encodePacked = exports.parseAbiParameters = exports.parseAbiParameter = exports.parseAbiItem = exports.parseAbi = exports.getAbiItem = exports.encodeFunctionResult = exports.encodeFunctionData = exports.encodeEventTopics = exports.encodeErrorResult = exports.encodeDeployData = exports.encodeAbiParameters = exports.decodeFunctionResult = exports.decodeFunctionData = exports.decodeEventLog = exports.decodeErrorResult = exports.decodeAbiParameters = exports.validateTypedData = exports.stringify = exports.rpc = exports.getSocket = exports.integerRegex = exports.bytesRegex = exports.arrayRegex = exports.getChainContractAddress = exports.defineChain = exports.assertCurrentChain = exports.offchainLookupSignature = exports.offchainLookupAbiItem = exports.offchainLookup = exports.ccipFetch = exports.buildRequest = void 0;
    exports.getEventSelector = exports.defineFormatter = exports.getTransactionError = exports.getEstimateGasError = exports.getContractError = exports.getCallError = exports.getNodeError = exports.containsNodeError = exports.fromRlp = exports.hexToString = exports.hexToNumber = exports.hexToBigInt = exports.hexToBool = exports.fromHex = exports.fromBytes = exports.bytesToString = exports.bytesToNumber = exports.bytesToBool = exports.bytesToBigint = exports.stringToHex = exports.numberToHex = exports.toHex = exports.bytesToHex = exports.boolToHex = exports.stringToBytes = exports.numberToBytes = exports.hexToBytes = exports.toBytes = exports.boolToBytes = exports.toRlp = exports.extract = exports.formatTransactionRequest = exports.defineTransactionRequest = exports.defineTransactionReceipt = exports.formatLog = exports.transactionType = exports.formatTransaction = exports.defineTransaction = exports.formatBlock = exports.defineBlock = exports.trim = exports.sliceHex = exports.sliceBytes = exports.slice = exports.size = exports.padHex = exports.padBytes = exports.pad = exports.isHex = exports.isBytes = void 0;
    exports.parseGwei = exports.parseEther = exports.parseUnits = exports.formatUnits = exports.formatGwei = exports.formatEther = exports.serializeAccessList = exports.serializeTransaction = exports.prepareTransactionRequest = exports.parseTransaction = exports.assertTransactionLegacy = exports.assertTransactionEIP2930 = exports.assertTransactionEIP1559 = exports.assertRequest = exports.getTransactionType = exports.getSerializedTransactionType = exports.hashMessage = exports.verifyTypedData = exports.verifyMessage = exports.recoverTypedDataAddress = exports.recoverPublicKey = exports.recoverMessageAddress = exports.recoverAddress = exports.hashTypedData = exports.keccak256 = exports.isHash = exports.getFunctionSelector = void 0;
    var buildRequest_js_1 = require_buildRequest();
    Object.defineProperty(exports, "buildRequest", { enumerable: true, get: function() {
      return buildRequest_js_1.buildRequest;
    } });
    var ccip_js_1 = require_ccip2();
    Object.defineProperty(exports, "ccipFetch", { enumerable: true, get: function() {
      return ccip_js_1.ccipFetch;
    } });
    Object.defineProperty(exports, "offchainLookup", { enumerable: true, get: function() {
      return ccip_js_1.offchainLookup;
    } });
    Object.defineProperty(exports, "offchainLookupAbiItem", { enumerable: true, get: function() {
      return ccip_js_1.offchainLookupAbiItem;
    } });
    Object.defineProperty(exports, "offchainLookupSignature", { enumerable: true, get: function() {
      return ccip_js_1.offchainLookupSignature;
    } });
    var chain_js_1 = require_chain2();
    Object.defineProperty(exports, "assertCurrentChain", { enumerable: true, get: function() {
      return chain_js_1.assertCurrentChain;
    } });
    Object.defineProperty(exports, "defineChain", { enumerable: true, get: function() {
      return chain_js_1.defineChain;
    } });
    Object.defineProperty(exports, "getChainContractAddress", { enumerable: true, get: function() {
      return chain_js_1.getChainContractAddress;
    } });
    var regex_js_1 = require_regex2();
    Object.defineProperty(exports, "arrayRegex", { enumerable: true, get: function() {
      return regex_js_1.arrayRegex;
    } });
    Object.defineProperty(exports, "bytesRegex", { enumerable: true, get: function() {
      return regex_js_1.bytesRegex;
    } });
    Object.defineProperty(exports, "integerRegex", { enumerable: true, get: function() {
      return regex_js_1.integerRegex;
    } });
    var rpc_js_1 = require_rpc2();
    Object.defineProperty(exports, "getSocket", { enumerable: true, get: function() {
      return rpc_js_1.getSocket;
    } });
    Object.defineProperty(exports, "rpc", { enumerable: true, get: function() {
      return rpc_js_1.rpc;
    } });
    var stringify_js_1 = require_stringify();
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return stringify_js_1.stringify;
    } });
    var typedData_js_1 = require_typedData();
    Object.defineProperty(exports, "validateTypedData", { enumerable: true, get: function() {
      return typedData_js_1.validateTypedData;
    } });
    var decodeAbiParameters_js_1 = require_decodeAbiParameters();
    Object.defineProperty(exports, "decodeAbiParameters", { enumerable: true, get: function() {
      return decodeAbiParameters_js_1.decodeAbiParameters;
    } });
    var decodeErrorResult_js_1 = require_decodeErrorResult();
    Object.defineProperty(exports, "decodeErrorResult", { enumerable: true, get: function() {
      return decodeErrorResult_js_1.decodeErrorResult;
    } });
    var decodeEventLog_js_1 = require_decodeEventLog();
    Object.defineProperty(exports, "decodeEventLog", { enumerable: true, get: function() {
      return decodeEventLog_js_1.decodeEventLog;
    } });
    var decodeFunctionData_js_1 = require_decodeFunctionData();
    Object.defineProperty(exports, "decodeFunctionData", { enumerable: true, get: function() {
      return decodeFunctionData_js_1.decodeFunctionData;
    } });
    var decodeFunctionResult_js_1 = require_decodeFunctionResult();
    Object.defineProperty(exports, "decodeFunctionResult", { enumerable: true, get: function() {
      return decodeFunctionResult_js_1.decodeFunctionResult;
    } });
    var encodeAbiParameters_js_1 = require_encodeAbiParameters();
    Object.defineProperty(exports, "encodeAbiParameters", { enumerable: true, get: function() {
      return encodeAbiParameters_js_1.encodeAbiParameters;
    } });
    var encodeDeployData_js_1 = require_encodeDeployData();
    Object.defineProperty(exports, "encodeDeployData", { enumerable: true, get: function() {
      return encodeDeployData_js_1.encodeDeployData;
    } });
    var encodeErrorResult_js_1 = require_encodeErrorResult();
    Object.defineProperty(exports, "encodeErrorResult", { enumerable: true, get: function() {
      return encodeErrorResult_js_1.encodeErrorResult;
    } });
    var encodeEventTopics_js_1 = require_encodeEventTopics();
    Object.defineProperty(exports, "encodeEventTopics", { enumerable: true, get: function() {
      return encodeEventTopics_js_1.encodeEventTopics;
    } });
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    Object.defineProperty(exports, "encodeFunctionData", { enumerable: true, get: function() {
      return encodeFunctionData_js_1.encodeFunctionData;
    } });
    var encodeFunctionResult_js_1 = require_encodeFunctionResult();
    Object.defineProperty(exports, "encodeFunctionResult", { enumerable: true, get: function() {
      return encodeFunctionResult_js_1.encodeFunctionResult;
    } });
    var getAbiItem_js_1 = require_getAbiItem();
    Object.defineProperty(exports, "getAbiItem", { enumerable: true, get: function() {
      return getAbiItem_js_1.getAbiItem;
    } });
    var abitype_1 = require_cjs();
    Object.defineProperty(exports, "parseAbi", { enumerable: true, get: function() {
      return abitype_1.parseAbi;
    } });
    Object.defineProperty(exports, "parseAbiItem", { enumerable: true, get: function() {
      return abitype_1.parseAbiItem;
    } });
    Object.defineProperty(exports, "parseAbiParameter", { enumerable: true, get: function() {
      return abitype_1.parseAbiParameter;
    } });
    Object.defineProperty(exports, "parseAbiParameters", { enumerable: true, get: function() {
      return abitype_1.parseAbiParameters;
    } });
    var encodePacked_js_1 = require_encodePacked();
    Object.defineProperty(exports, "encodePacked", { enumerable: true, get: function() {
      return encodePacked_js_1.encodePacked;
    } });
    var formatAbiItemWithArgs_js_1 = require_formatAbiItemWithArgs();
    Object.defineProperty(exports, "formatAbiItemWithArgs", { enumerable: true, get: function() {
      return formatAbiItemWithArgs_js_1.formatAbiItemWithArgs;
    } });
    var formatAbiItem_js_1 = require_formatAbiItem2();
    Object.defineProperty(exports, "formatAbiItem", { enumerable: true, get: function() {
      return formatAbiItem_js_1.formatAbiItem;
    } });
    Object.defineProperty(exports, "formatAbiParams", { enumerable: true, get: function() {
      return formatAbiItem_js_1.formatAbiParams;
    } });
    var parseAccount_js_1 = require_parseAccount();
    Object.defineProperty(exports, "parseAccount", { enumerable: true, get: function() {
      return parseAccount_js_1.parseAccount;
    } });
    var publicKeyToAddress_js_1 = require_publicKeyToAddress();
    Object.defineProperty(exports, "publicKeyToAddress", { enumerable: true, get: function() {
      return publicKeyToAddress_js_1.publicKeyToAddress;
    } });
    var getContractAddress_js_1 = require_getContractAddress();
    Object.defineProperty(exports, "getContractAddress", { enumerable: true, get: function() {
      return getContractAddress_js_1.getContractAddress;
    } });
    Object.defineProperty(exports, "getCreateAddress", { enumerable: true, get: function() {
      return getContractAddress_js_1.getCreateAddress;
    } });
    Object.defineProperty(exports, "getCreate2Address", { enumerable: true, get: function() {
      return getContractAddress_js_1.getCreate2Address;
    } });
    var getAddress_js_1 = require_getAddress();
    Object.defineProperty(exports, "getAddress", { enumerable: true, get: function() {
      return getAddress_js_1.getAddress;
    } });
    var isAddress_js_1 = require_isAddress();
    Object.defineProperty(exports, "isAddress", { enumerable: true, get: function() {
      return isAddress_js_1.isAddress;
    } });
    var isAddressEqual_js_1 = require_isAddressEqual();
    Object.defineProperty(exports, "isAddressEqual", { enumerable: true, get: function() {
      return isAddressEqual_js_1.isAddressEqual;
    } });
    var extractFunctionParts_js_1 = require_extractFunctionParts();
    Object.defineProperty(exports, "extractFunctionName", { enumerable: true, get: function() {
      return extractFunctionParts_js_1.extractFunctionName;
    } });
    Object.defineProperty(exports, "extractFunctionParams", { enumerable: true, get: function() {
      return extractFunctionParts_js_1.extractFunctionParams;
    } });
    Object.defineProperty(exports, "extractFunctionType", { enumerable: true, get: function() {
      return extractFunctionParts_js_1.extractFunctionType;
    } });
    Object.defineProperty(exports, "extractFunctionParts", { enumerable: true, get: function() {
      return extractFunctionParts_js_1.extractFunctionParts;
    } });
    var concat_js_1 = require_concat();
    Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
      return concat_js_1.concat;
    } });
    Object.defineProperty(exports, "concatBytes", { enumerable: true, get: function() {
      return concat_js_1.concatBytes;
    } });
    Object.defineProperty(exports, "concatHex", { enumerable: true, get: function() {
      return concat_js_1.concatHex;
    } });
    var isBytes_js_1 = require_isBytes();
    Object.defineProperty(exports, "isBytes", { enumerable: true, get: function() {
      return isBytes_js_1.isBytes;
    } });
    var isHex_js_1 = require_isHex();
    Object.defineProperty(exports, "isHex", { enumerable: true, get: function() {
      return isHex_js_1.isHex;
    } });
    var pad_js_1 = require_pad();
    Object.defineProperty(exports, "pad", { enumerable: true, get: function() {
      return pad_js_1.pad;
    } });
    Object.defineProperty(exports, "padBytes", { enumerable: true, get: function() {
      return pad_js_1.padBytes;
    } });
    Object.defineProperty(exports, "padHex", { enumerable: true, get: function() {
      return pad_js_1.padHex;
    } });
    var size_js_1 = require_size();
    Object.defineProperty(exports, "size", { enumerable: true, get: function() {
      return size_js_1.size;
    } });
    var slice_js_1 = require_slice();
    Object.defineProperty(exports, "slice", { enumerable: true, get: function() {
      return slice_js_1.slice;
    } });
    Object.defineProperty(exports, "sliceBytes", { enumerable: true, get: function() {
      return slice_js_1.sliceBytes;
    } });
    Object.defineProperty(exports, "sliceHex", { enumerable: true, get: function() {
      return slice_js_1.sliceHex;
    } });
    var trim_js_1 = require_trim();
    Object.defineProperty(exports, "trim", { enumerable: true, get: function() {
      return trim_js_1.trim;
    } });
    var block_js_1 = require_block();
    Object.defineProperty(exports, "defineBlock", { enumerable: true, get: function() {
      return block_js_1.defineBlock;
    } });
    Object.defineProperty(exports, "formatBlock", { enumerable: true, get: function() {
      return block_js_1.formatBlock;
    } });
    var transaction_js_1 = require_transaction();
    Object.defineProperty(exports, "defineTransaction", { enumerable: true, get: function() {
      return transaction_js_1.defineTransaction;
    } });
    Object.defineProperty(exports, "formatTransaction", { enumerable: true, get: function() {
      return transaction_js_1.formatTransaction;
    } });
    Object.defineProperty(exports, "transactionType", { enumerable: true, get: function() {
      return transaction_js_1.transactionType;
    } });
    var log_js_1 = require_log();
    Object.defineProperty(exports, "formatLog", { enumerable: true, get: function() {
      return log_js_1.formatLog;
    } });
    var transactionReceipt_js_1 = require_transactionReceipt();
    Object.defineProperty(exports, "defineTransactionReceipt", { enumerable: true, get: function() {
      return transactionReceipt_js_1.defineTransactionReceipt;
    } });
    var transactionRequest_js_1 = require_transactionRequest();
    Object.defineProperty(exports, "defineTransactionRequest", { enumerable: true, get: function() {
      return transactionRequest_js_1.defineTransactionRequest;
    } });
    Object.defineProperty(exports, "formatTransactionRequest", { enumerable: true, get: function() {
      return transactionRequest_js_1.formatTransactionRequest;
    } });
    var extract_js_1 = require_extract();
    Object.defineProperty(exports, "extract", { enumerable: true, get: function() {
      return extract_js_1.extract;
    } });
    var toRlp_js_1 = require_toRlp();
    Object.defineProperty(exports, "toRlp", { enumerable: true, get: function() {
      return toRlp_js_1.toRlp;
    } });
    var toBytes_js_1 = require_toBytes();
    Object.defineProperty(exports, "boolToBytes", { enumerable: true, get: function() {
      return toBytes_js_1.boolToBytes;
    } });
    Object.defineProperty(exports, "toBytes", { enumerable: true, get: function() {
      return toBytes_js_1.toBytes;
    } });
    Object.defineProperty(exports, "hexToBytes", { enumerable: true, get: function() {
      return toBytes_js_1.hexToBytes;
    } });
    Object.defineProperty(exports, "numberToBytes", { enumerable: true, get: function() {
      return toBytes_js_1.numberToBytes;
    } });
    Object.defineProperty(exports, "stringToBytes", { enumerable: true, get: function() {
      return toBytes_js_1.stringToBytes;
    } });
    var toHex_js_1 = require_toHex();
    Object.defineProperty(exports, "boolToHex", { enumerable: true, get: function() {
      return toHex_js_1.boolToHex;
    } });
    Object.defineProperty(exports, "bytesToHex", { enumerable: true, get: function() {
      return toHex_js_1.bytesToHex;
    } });
    Object.defineProperty(exports, "toHex", { enumerable: true, get: function() {
      return toHex_js_1.toHex;
    } });
    Object.defineProperty(exports, "numberToHex", { enumerable: true, get: function() {
      return toHex_js_1.numberToHex;
    } });
    Object.defineProperty(exports, "stringToHex", { enumerable: true, get: function() {
      return toHex_js_1.stringToHex;
    } });
    var fromBytes_js_1 = require_fromBytes();
    Object.defineProperty(exports, "bytesToBigint", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToBigint;
    } });
    Object.defineProperty(exports, "bytesToBool", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToBool;
    } });
    Object.defineProperty(exports, "bytesToNumber", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToNumber;
    } });
    Object.defineProperty(exports, "bytesToString", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToString;
    } });
    Object.defineProperty(exports, "fromBytes", { enumerable: true, get: function() {
      return fromBytes_js_1.fromBytes;
    } });
    var fromHex_js_1 = require_fromHex();
    Object.defineProperty(exports, "fromHex", { enumerable: true, get: function() {
      return fromHex_js_1.fromHex;
    } });
    Object.defineProperty(exports, "hexToBool", { enumerable: true, get: function() {
      return fromHex_js_1.hexToBool;
    } });
    Object.defineProperty(exports, "hexToBigInt", { enumerable: true, get: function() {
      return fromHex_js_1.hexToBigInt;
    } });
    Object.defineProperty(exports, "hexToNumber", { enumerable: true, get: function() {
      return fromHex_js_1.hexToNumber;
    } });
    Object.defineProperty(exports, "hexToString", { enumerable: true, get: function() {
      return fromHex_js_1.hexToString;
    } });
    var fromRlp_js_1 = require_fromRlp();
    Object.defineProperty(exports, "fromRlp", { enumerable: true, get: function() {
      return fromRlp_js_1.fromRlp;
    } });
    var getNodeError_js_1 = require_getNodeError();
    Object.defineProperty(exports, "containsNodeError", { enumerable: true, get: function() {
      return getNodeError_js_1.containsNodeError;
    } });
    Object.defineProperty(exports, "getNodeError", { enumerable: true, get: function() {
      return getNodeError_js_1.getNodeError;
    } });
    var getCallError_js_1 = require_getCallError();
    Object.defineProperty(exports, "getCallError", { enumerable: true, get: function() {
      return getCallError_js_1.getCallError;
    } });
    var getContractError_js_1 = require_getContractError();
    Object.defineProperty(exports, "getContractError", { enumerable: true, get: function() {
      return getContractError_js_1.getContractError;
    } });
    var getEstimateGasError_js_1 = require_getEstimateGasError();
    Object.defineProperty(exports, "getEstimateGasError", { enumerable: true, get: function() {
      return getEstimateGasError_js_1.getEstimateGasError;
    } });
    var getTransactionError_js_1 = require_getTransactionError();
    Object.defineProperty(exports, "getTransactionError", { enumerable: true, get: function() {
      return getTransactionError_js_1.getTransactionError;
    } });
    var formatter_js_1 = require_formatter();
    Object.defineProperty(exports, "defineFormatter", { enumerable: true, get: function() {
      return formatter_js_1.defineFormatter;
    } });
    var getEventSelector_js_1 = require_getEventSelector();
    Object.defineProperty(exports, "getEventSelector", { enumerable: true, get: function() {
      return getEventSelector_js_1.getEventSelector;
    } });
    var getFunctionSelector_js_1 = require_getFunctionSelector();
    Object.defineProperty(exports, "getFunctionSelector", { enumerable: true, get: function() {
      return getFunctionSelector_js_1.getFunctionSelector;
    } });
    var isHash_js_1 = require_isHash();
    Object.defineProperty(exports, "isHash", { enumerable: true, get: function() {
      return isHash_js_1.isHash;
    } });
    var keccak256_js_1 = require_keccak256();
    Object.defineProperty(exports, "keccak256", { enumerable: true, get: function() {
      return keccak256_js_1.keccak256;
    } });
    var hashTypedData_js_1 = require_hashTypedData();
    Object.defineProperty(exports, "hashTypedData", { enumerable: true, get: function() {
      return hashTypedData_js_1.hashTypedData;
    } });
    var recoverAddress_js_1 = require_recoverAddress();
    Object.defineProperty(exports, "recoverAddress", { enumerable: true, get: function() {
      return recoverAddress_js_1.recoverAddress;
    } });
    var recoverMessageAddress_js_1 = require_recoverMessageAddress();
    Object.defineProperty(exports, "recoverMessageAddress", { enumerable: true, get: function() {
      return recoverMessageAddress_js_1.recoverMessageAddress;
    } });
    var recoverPublicKey_js_1 = require_recoverPublicKey();
    Object.defineProperty(exports, "recoverPublicKey", { enumerable: true, get: function() {
      return recoverPublicKey_js_1.recoverPublicKey;
    } });
    var recoverTypedDataAddress_js_1 = require_recoverTypedDataAddress();
    Object.defineProperty(exports, "recoverTypedDataAddress", { enumerable: true, get: function() {
      return recoverTypedDataAddress_js_1.recoverTypedDataAddress;
    } });
    var verifyMessage_js_1 = require_verifyMessage();
    Object.defineProperty(exports, "verifyMessage", { enumerable: true, get: function() {
      return verifyMessage_js_1.verifyMessage;
    } });
    var verifyTypedData_js_1 = require_verifyTypedData();
    Object.defineProperty(exports, "verifyTypedData", { enumerable: true, get: function() {
      return verifyTypedData_js_1.verifyTypedData;
    } });
    var hashMessage_js_1 = require_hashMessage();
    Object.defineProperty(exports, "hashMessage", { enumerable: true, get: function() {
      return hashMessage_js_1.hashMessage;
    } });
    var getSerializedTransactionType_js_1 = require_getSerializedTransactionType();
    Object.defineProperty(exports, "getSerializedTransactionType", { enumerable: true, get: function() {
      return getSerializedTransactionType_js_1.getSerializedTransactionType;
    } });
    var getTransactionType_js_1 = require_getTransactionType();
    Object.defineProperty(exports, "getTransactionType", { enumerable: true, get: function() {
      return getTransactionType_js_1.getTransactionType;
    } });
    var assertRequest_js_1 = require_assertRequest();
    Object.defineProperty(exports, "assertRequest", { enumerable: true, get: function() {
      return assertRequest_js_1.assertRequest;
    } });
    var assertTransaction_js_1 = require_assertTransaction();
    Object.defineProperty(exports, "assertTransactionEIP1559", { enumerable: true, get: function() {
      return assertTransaction_js_1.assertTransactionEIP1559;
    } });
    Object.defineProperty(exports, "assertTransactionEIP2930", { enumerable: true, get: function() {
      return assertTransaction_js_1.assertTransactionEIP2930;
    } });
    Object.defineProperty(exports, "assertTransactionLegacy", { enumerable: true, get: function() {
      return assertTransaction_js_1.assertTransactionLegacy;
    } });
    var parseTransaction_js_1 = require_parseTransaction();
    Object.defineProperty(exports, "parseTransaction", { enumerable: true, get: function() {
      return parseTransaction_js_1.parseTransaction;
    } });
    var prepareTransactionRequest_js_1 = require_prepareTransactionRequest();
    Object.defineProperty(exports, "prepareTransactionRequest", { enumerable: true, get: function() {
      return prepareTransactionRequest_js_1.prepareTransactionRequest;
    } });
    var serializeTransaction_js_1 = require_serializeTransaction();
    Object.defineProperty(exports, "serializeTransaction", { enumerable: true, get: function() {
      return serializeTransaction_js_1.serializeTransaction;
    } });
    var serializeAccessList_js_1 = require_serializeAccessList();
    Object.defineProperty(exports, "serializeAccessList", { enumerable: true, get: function() {
      return serializeAccessList_js_1.serializeAccessList;
    } });
    var formatEther_js_1 = require_formatEther();
    Object.defineProperty(exports, "formatEther", { enumerable: true, get: function() {
      return formatEther_js_1.formatEther;
    } });
    var formatGwei_js_1 = require_formatGwei();
    Object.defineProperty(exports, "formatGwei", { enumerable: true, get: function() {
      return formatGwei_js_1.formatGwei;
    } });
    var formatUnits_js_1 = require_formatUnits();
    Object.defineProperty(exports, "formatUnits", { enumerable: true, get: function() {
      return formatUnits_js_1.formatUnits;
    } });
    var parseUnits_js_1 = require_parseUnits();
    Object.defineProperty(exports, "parseUnits", { enumerable: true, get: function() {
      return parseUnits_js_1.parseUnits;
    } });
    var parseEther_js_1 = require_parseEther();
    Object.defineProperty(exports, "parseEther", { enumerable: true, get: function() {
      return parseEther_js_1.parseEther;
    } });
    var parseGwei_js_1 = require_parseGwei();
    Object.defineProperty(exports, "parseGwei", { enumerable: true, get: function() {
      return parseGwei_js_1.parseGwei;
    } });
  }
});

// node_modules/viem/_cjs/constants/contracts.js
var require_contracts = __commonJS({
  "node_modules/viem/_cjs/constants/contracts.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.universalSignatureValidatorByteCode = void 0;
    exports.universalSignatureValidatorByteCode = "0x60806040523480156200001157600080fd5b50604051620007003803806200070083398101604081905262000034916200056f565b6000620000438484846200004f565b9050806000526001601ff35b600080846001600160a01b0316803b806020016040519081016040528181526000908060200190933c90507f6492649264926492649264926492649264926492649264926492649264926492620000a68462000451565b036200021f57600060608085806020019051810190620000c79190620005ce565b8651929550909350915060000362000192576000836001600160a01b031683604051620000f5919062000643565b6000604051808303816000865af19150503d806000811462000134576040519150601f19603f3d011682016040523d82523d6000602084013e62000139565b606091505b5050905080620001905760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b505b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90620001c4908b90869060040162000661565b602060405180830381865afa158015620001e2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200020891906200069d565b6001600160e01b031916149450505050506200044a565b805115620002b157604051630b135d3f60e11b808252906001600160a01b03871690631626ba7e9062000259908890889060040162000661565b602060405180830381865afa15801562000277573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200029d91906200069d565b6001600160e01b031916149150506200044a565b8251604114620003195760405162461bcd60e51b815260206004820152603a6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e677468000000000000606482015260840162000187565b620003236200046b565b506020830151604080850151855186939260009185919081106200034b576200034b620006c9565b016020015160f81c9050601b81148015906200036b57508060ff16601c14155b15620003cf5760405162461bcd60e51b815260206004820152603b6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c75650000000000606482015260840162000187565b6040805160008152602081018083528a905260ff83169181019190915260608101849052608081018390526001600160a01b038a169060019060a0016020604051602081039080840390855afa1580156200042e573d6000803e3d6000fd5b505050602060405103516001600160a01b031614955050505050505b9392505050565b60006020825110156200046357600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b03811681146200049f57600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b83811015620004d5578181015183820152602001620004bb565b50506000910152565b600082601f830112620004f057600080fd5b81516001600160401b03808211156200050d576200050d620004a2565b604051601f8301601f19908116603f01168101908282118183101715620005385762000538620004a2565b816040528381528660208588010111156200055257600080fd5b62000565846020830160208901620004b8565b9695505050505050565b6000806000606084860312156200058557600080fd5b8351620005928162000489565b6020850151604086015191945092506001600160401b03811115620005b657600080fd5b620005c486828701620004de565b9150509250925092565b600080600060608486031215620005e457600080fd5b8351620005f18162000489565b60208501519093506001600160401b03808211156200060f57600080fd5b6200061d87838801620004de565b935060408601519150808211156200063457600080fd5b50620005c486828701620004de565b6000825162000657818460208701620004b8565b9190910192915050565b828152604060208201526000825180604084015262000688816060850160208701620004b8565b601f01601f1916919091016060019392505050565b600060208284031215620006b057600080fd5b81516001600160e01b0319811681146200044a57600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572";
  }
});

// node_modules/viem/_cjs/utils/data/isBytesEqual.js
var require_isBytesEqual = __commonJS({
  "node_modules/viem/_cjs/utils/data/isBytesEqual.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBytesEqual = void 0;
    var utils_1 = require_utils7();
    var toBytes_js_1 = require_toBytes();
    var isHex_js_1 = require_isHex();
    function isBytesEqual(a_, b_) {
      const a = (0, isHex_js_1.isHex)(a_) ? (0, toBytes_js_1.toBytes)(a_) : a_;
      const b = (0, isHex_js_1.isHex)(b_) ? (0, toBytes_js_1.toBytes)(b_) : b_;
      return (0, utils_1.equalBytes)(a, b);
    }
    exports.isBytesEqual = isBytesEqual;
  }
});

// node_modules/viem/_cjs/actions/public/verifyHash.js
var require_verifyHash = __commonJS({
  "node_modules/viem/_cjs/actions/public/verifyHash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.verifyHash = void 0;
    var abis_js_1 = require_abis();
    var contracts_js_1 = require_contracts();
    var contract_js_1 = require_contract();
    var isBytesEqual_js_1 = require_isBytesEqual();
    var index_js_1 = require_utils8();
    var call_js_1 = require_call();
    async function verifyHash(client, { address, hash, signature, ...callRequest }) {
      const signatureHex = (0, index_js_1.isHex)(signature) ? signature : (0, index_js_1.toHex)(signature);
      try {
        const { data } = await (0, call_js_1.call)(client, {
          data: (0, index_js_1.encodeDeployData)({
            abi: abis_js_1.universalSignatureValidatorAbi,
            args: [address, hash, signatureHex],
            bytecode: contracts_js_1.universalSignatureValidatorByteCode
          }),
          ...callRequest
        });
        return (0, isBytesEqual_js_1.isBytesEqual)(data ?? "0x0", "0x1");
      } catch (error) {
        if (error instanceof contract_js_1.CallExecutionError) {
          return false;
        }
        throw error;
      }
    }
    exports.verifyHash = verifyHash;
  }
});

// node_modules/viem/_cjs/actions/public/verifyMessage.js
var require_verifyMessage2 = __commonJS({
  "node_modules/viem/_cjs/actions/public/verifyMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.verifyMessage = void 0;
    var index_js_1 = require_utils8();
    var verifyHash_js_1 = require_verifyHash();
    async function verifyMessage(client, { address, message, signature, ...callRequest }) {
      const hash = (0, index_js_1.hashMessage)(message);
      return (0, verifyHash_js_1.verifyHash)(client, {
        address,
        hash,
        signature,
        ...callRequest
      });
    }
    exports.verifyMessage = verifyMessage;
  }
});

// node_modules/viem/_cjs/actions/public/verifyTypedData.js
var require_verifyTypedData2 = __commonJS({
  "node_modules/viem/_cjs/actions/public/verifyTypedData.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.verifyTypedData = void 0;
    var hashTypedData_js_1 = require_hashTypedData();
    var verifyHash_js_1 = require_verifyHash();
    async function verifyTypedData(client, { address, signature, message, primaryType, types, domain, ...callRequest }) {
      const hash = (0, hashTypedData_js_1.hashTypedData)({ message, primaryType, types, domain });
      return (0, verifyHash_js_1.verifyHash)(client, {
        address,
        hash,
        signature,
        ...callRequest
      });
    }
    exports.verifyTypedData = verifyTypedData;
  }
});

// node_modules/viem/_cjs/actions/public/watchBlockNumber.js
var require_watchBlockNumber = __commonJS({
  "node_modules/viem/_cjs/actions/public/watchBlockNumber.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.watchBlockNumber = void 0;
    var fromHex_js_1 = require_fromHex();
    var observe_js_1 = require_observe();
    var poll_js_1 = require_poll();
    var stringify_js_1 = require_stringify();
    var getBlockNumber_js_1 = require_getBlockNumber();
    function watchBlockNumber(client, { emitOnBegin = false, emitMissed = false, onBlockNumber, onError, poll: poll_, pollingInterval = client.pollingInterval }) {
      const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
      let prevBlockNumber;
      const pollBlockNumber = () => {
        const observerId = (0, stringify_js_1.stringify)([
          "watchBlockNumber",
          client.uid,
          emitOnBegin,
          emitMissed,
          pollingInterval
        ]);
        return (0, observe_js_1.observe)(observerId, { onBlockNumber, onError }, (emit) => (0, poll_js_1.poll)(async () => {
          try {
            const blockNumber = await (0, getBlockNumber_js_1.getBlockNumber)(client, { cacheTime: 0 });
            if (prevBlockNumber) {
              if (blockNumber === prevBlockNumber)
                return;
              if (blockNumber - prevBlockNumber > 1 && emitMissed) {
                for (let i = prevBlockNumber + 1n; i < blockNumber; i++) {
                  emit.onBlockNumber(i, prevBlockNumber);
                  prevBlockNumber = i;
                }
              }
            }
            if (!prevBlockNumber || blockNumber > prevBlockNumber) {
              emit.onBlockNumber(blockNumber, prevBlockNumber);
              prevBlockNumber = blockNumber;
            }
          } catch (err) {
            emit.onError?.(err);
          }
        }, {
          emitOnBegin,
          interval: pollingInterval
        }));
      };
      const subscribeBlockNumber = () => {
        let active = true;
        let unsubscribe = () => active = false;
        (async () => {
          try {
            const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
              params: ["newHeads"],
              onData(data) {
                if (!active)
                  return;
                const blockNumber = (0, fromHex_js_1.hexToBigInt)(data.result?.number);
                onBlockNumber(blockNumber, prevBlockNumber);
                prevBlockNumber = blockNumber;
              },
              onError(error) {
                onError?.(error);
              }
            });
            unsubscribe = unsubscribe_;
            if (!active)
              unsubscribe();
          } catch (err) {
            onError?.(err);
          }
        })();
        return unsubscribe;
      };
      return enablePolling ? pollBlockNumber() : subscribeBlockNumber();
    }
    exports.watchBlockNumber = watchBlockNumber;
  }
});

// node_modules/viem/_cjs/actions/public/waitForTransactionReceipt.js
var require_waitForTransactionReceipt = __commonJS({
  "node_modules/viem/_cjs/actions/public/waitForTransactionReceipt.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.waitForTransactionReceipt = void 0;
    var transaction_js_1 = require_transaction2();
    var observe_js_1 = require_observe();
    var withRetry_js_1 = require_withRetry();
    var stringify_js_1 = require_stringify();
    var getBlock_js_1 = require_getBlock();
    var getTransaction_js_1 = require_getTransaction();
    var getTransactionReceipt_js_1 = require_getTransactionReceipt();
    var watchBlockNumber_js_1 = require_watchBlockNumber();
    async function waitForTransactionReceipt(client, { confirmations = 1, hash, onReplaced, pollingInterval = client.pollingInterval, timeout }) {
      const observerId = (0, stringify_js_1.stringify)(["waitForTransactionReceipt", client.uid, hash]);
      let transaction;
      let replacedTransaction;
      let receipt;
      let retrying = false;
      return new Promise((resolve, reject) => {
        if (timeout)
          setTimeout(() => reject(new transaction_js_1.WaitForTransactionReceiptTimeoutError({ hash })), timeout);
        const _unobserve = (0, observe_js_1.observe)(observerId, { onReplaced, resolve, reject }, (emit) => {
          const _unwatch = (0, watchBlockNumber_js_1.watchBlockNumber)(client, {
            emitMissed: true,
            emitOnBegin: true,
            poll: true,
            pollingInterval,
            async onBlockNumber(blockNumber_) {
              if (retrying)
                return;
              let blockNumber = blockNumber_;
              const done = (fn) => {
                _unwatch();
                fn();
                _unobserve();
              };
              try {
                if (receipt) {
                  if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
                    return;
                  done(() => emit.resolve(receipt));
                  return;
                }
                if (!transaction) {
                  retrying = true;
                  await (0, withRetry_js_1.withRetry)(async () => {
                    transaction = await (0, getTransaction_js_1.getTransaction)(client, { hash });
                    if (transaction.blockNumber)
                      blockNumber = transaction.blockNumber;
                  }, {
                    delay: ({ count }) => ~~(1 << count) * 200,
                    retryCount: 6
                  });
                  retrying = false;
                }
                receipt = await (0, getTransactionReceipt_js_1.getTransactionReceipt)(client, { hash });
                if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
                  return;
                done(() => emit.resolve(receipt));
              } catch (err) {
                if (transaction && (err instanceof transaction_js_1.TransactionNotFoundError || err instanceof transaction_js_1.TransactionReceiptNotFoundError)) {
                  try {
                    replacedTransaction = transaction;
                    const block = await (0, getBlock_js_1.getBlock)(client, {
                      blockNumber,
                      includeTransactions: true
                    });
                    const replacementTransaction = block.transactions.find(({ from, nonce }) => from === replacedTransaction.from && nonce === replacedTransaction.nonce);
                    if (!replacementTransaction)
                      return;
                    receipt = await (0, getTransactionReceipt_js_1.getTransactionReceipt)(client, {
                      hash: replacementTransaction.hash
                    });
                    if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations))
                      return;
                    let reason = "replaced";
                    if (replacementTransaction.to === replacedTransaction.to && replacementTransaction.value === replacedTransaction.value) {
                      reason = "repriced";
                    } else if (replacementTransaction.from === replacementTransaction.to && replacementTransaction.value === 0n) {
                      reason = "cancelled";
                    }
                    done(() => {
                      emit.onReplaced?.({
                        reason,
                        replacedTransaction,
                        transaction: replacementTransaction,
                        transactionReceipt: receipt
                      });
                      emit.resolve(receipt);
                    });
                  } catch (err_) {
                    done(() => emit.reject(err_));
                  }
                } else {
                  done(() => emit.reject(err));
                }
              }
            }
          });
        });
      });
    }
    exports.waitForTransactionReceipt = waitForTransactionReceipt;
  }
});

// node_modules/viem/_cjs/actions/public/watchBlocks.js
var require_watchBlocks = __commonJS({
  "node_modules/viem/_cjs/actions/public/watchBlocks.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.watchBlocks = void 0;
    var block_js_1 = require_block();
    var observe_js_1 = require_observe();
    var poll_js_1 = require_poll();
    var stringify_js_1 = require_stringify();
    var getBlock_js_1 = require_getBlock();
    function watchBlocks(client, { blockTag = "latest", emitMissed = false, emitOnBegin = false, onBlock, onError, includeTransactions: includeTransactions_, poll: poll_, pollingInterval = client.pollingInterval }) {
      const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
      const includeTransactions = includeTransactions_ ?? false;
      let prevBlock;
      const pollBlocks = () => {
        const observerId = (0, stringify_js_1.stringify)([
          "watchBlocks",
          client.uid,
          emitMissed,
          emitOnBegin,
          includeTransactions,
          pollingInterval
        ]);
        return (0, observe_js_1.observe)(observerId, { onBlock, onError }, (emit) => (0, poll_js_1.poll)(async () => {
          try {
            const block = await (0, getBlock_js_1.getBlock)(client, {
              blockTag,
              includeTransactions
            });
            if (block.number && prevBlock?.number) {
              if (block.number === prevBlock.number)
                return;
              if (block.number - prevBlock.number > 1 && emitMissed) {
                for (let i = prevBlock?.number + 1n; i < block.number; i++) {
                  const block2 = await (0, getBlock_js_1.getBlock)(client, {
                    blockNumber: i,
                    includeTransactions
                  });
                  emit.onBlock(block2, prevBlock);
                  prevBlock = block2;
                }
              }
            }
            if (!prevBlock?.number || blockTag === "pending" && !block?.number || block.number && block.number > prevBlock.number) {
              emit.onBlock(block, prevBlock);
              prevBlock = block;
            }
          } catch (err) {
            emit.onError?.(err);
          }
        }, {
          emitOnBegin,
          interval: pollingInterval
        }));
      };
      const subscribeBlocks = () => {
        let active = true;
        let unsubscribe = () => active = false;
        (async () => {
          try {
            const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
              params: ["newHeads"],
              onData(data) {
                if (!active)
                  return;
                const format = client.chain?.formatters?.block?.format || block_js_1.formatBlock;
                const block = format(data.result);
                onBlock(block, prevBlock);
                prevBlock = block;
              },
              onError(error) {
                onError?.(error);
              }
            });
            unsubscribe = unsubscribe_;
            if (!active)
              unsubscribe();
          } catch (err) {
            onError?.(err);
          }
        })();
        return unsubscribe;
      };
      return enablePolling ? pollBlocks() : subscribeBlocks();
    }
    exports.watchBlocks = watchBlocks;
  }
});

// node_modules/viem/_cjs/actions/public/watchEvent.js
var require_watchEvent = __commonJS({
  "node_modules/viem/_cjs/actions/public/watchEvent.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.watchEvent = void 0;
    var observe_js_1 = require_observe();
    var poll_js_1 = require_poll();
    var stringify_js_1 = require_stringify();
    var abi_js_1 = require_abi();
    var rpc_js_1 = require_rpc();
    var index_js_1 = require_utils8();
    var createEventFilter_js_1 = require_createEventFilter();
    var getBlockNumber_js_1 = require_getBlockNumber();
    var getFilterChanges_js_1 = require_getFilterChanges();
    var getLogs_js_1 = require_getLogs();
    var uninstallFilter_js_1 = require_uninstallFilter();
    function watchEvent(client, { address, args, batch = true, event, events, onError, onLogs, poll: poll_, pollingInterval = client.pollingInterval, strict: strict_ }) {
      const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
      const strict = strict_ ?? false;
      const pollEvent = () => {
        const observerId = (0, stringify_js_1.stringify)([
          "watchEvent",
          address,
          args,
          batch,
          client.uid,
          event,
          pollingInterval
        ]);
        return (0, observe_js_1.observe)(observerId, { onLogs, onError }, (emit) => {
          let previousBlockNumber;
          let filter;
          let initialized = false;
          const unwatch = (0, poll_js_1.poll)(async () => {
            if (!initialized) {
              try {
                filter = await (0, createEventFilter_js_1.createEventFilter)(client, {
                  address,
                  args,
                  event,
                  events,
                  strict
                });
              } catch {
              }
              initialized = true;
              return;
            }
            try {
              let logs;
              if (filter) {
                logs = await (0, getFilterChanges_js_1.getFilterChanges)(client, { filter });
              } else {
                const blockNumber = await (0, getBlockNumber_js_1.getBlockNumber)(client);
                if (previousBlockNumber && previousBlockNumber !== blockNumber) {
                  logs = await (0, getLogs_js_1.getLogs)(client, {
                    address,
                    args,
                    event,
                    events,
                    fromBlock: previousBlockNumber + 1n,
                    toBlock: blockNumber
                  });
                } else {
                  logs = [];
                }
                previousBlockNumber = blockNumber;
              }
              if (logs.length === 0)
                return;
              if (batch)
                emit.onLogs(logs);
              else
                logs.forEach((log) => emit.onLogs([log]));
            } catch (err) {
              if (filter && err instanceof rpc_js_1.InvalidInputRpcError)
                initialized = false;
              emit.onError?.(err);
            }
          }, {
            emitOnBegin: true,
            interval: pollingInterval
          });
          return async () => {
            if (filter)
              await (0, uninstallFilter_js_1.uninstallFilter)(client, { filter });
            unwatch();
          };
        });
      };
      const subscribeEvent = () => {
        let active = true;
        let unsubscribe = () => active = false;
        (async () => {
          try {
            const events_ = events ?? (event ? [event] : void 0);
            let topics = [];
            if (events_) {
              topics = [
                events_.flatMap((event2) => (0, index_js_1.encodeEventTopics)({
                  abi: [event2],
                  eventName: event2.name,
                  args
                }))
              ];
              if (event)
                topics = topics[0];
            }
            const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
              params: ["logs", { address, topics }],
              onData(data) {
                if (!active)
                  return;
                const log = data.result;
                try {
                  const { eventName, args: args2 } = (0, index_js_1.decodeEventLog)({
                    abi: events_,
                    data: log.data,
                    topics: log.topics,
                    strict
                  });
                  const formatted = (0, index_js_1.formatLog)(log, {
                    args: args2,
                    eventName
                  });
                  onLogs([formatted]);
                } catch (err) {
                  let eventName;
                  let isUnnamed;
                  if (err instanceof abi_js_1.DecodeLogDataMismatch || err instanceof abi_js_1.DecodeLogTopicsMismatch) {
                    if (strict_)
                      return;
                    eventName = err.abiItem.name;
                    isUnnamed = err.abiItem.inputs?.some((x) => !("name" in x && x.name));
                  }
                  const formatted = (0, index_js_1.formatLog)(log, {
                    args: isUnnamed ? [] : {},
                    eventName
                  });
                  onLogs([formatted]);
                }
              },
              onError(error) {
                onError?.(error);
              }
            });
            unsubscribe = unsubscribe_;
            if (!active)
              unsubscribe();
          } catch (err) {
            onError?.(err);
          }
        })();
        return unsubscribe;
      };
      return enablePolling ? pollEvent() : subscribeEvent();
    }
    exports.watchEvent = watchEvent;
  }
});

// node_modules/viem/_cjs/actions/public/watchPendingTransactions.js
var require_watchPendingTransactions = __commonJS({
  "node_modules/viem/_cjs/actions/public/watchPendingTransactions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.watchPendingTransactions = void 0;
    var observe_js_1 = require_observe();
    var poll_js_1 = require_poll();
    var stringify_js_1 = require_stringify();
    var createPendingTransactionFilter_js_1 = require_createPendingTransactionFilter();
    var getFilterChanges_js_1 = require_getFilterChanges();
    var uninstallFilter_js_1 = require_uninstallFilter();
    function watchPendingTransactions(client, { batch = true, onError, onTransactions, poll: poll_, pollingInterval = client.pollingInterval }) {
      const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
      const pollPendingTransactions = () => {
        const observerId = (0, stringify_js_1.stringify)([
          "watchPendingTransactions",
          client.uid,
          batch,
          pollingInterval
        ]);
        return (0, observe_js_1.observe)(observerId, { onTransactions, onError }, (emit) => {
          let filter;
          const unwatch = (0, poll_js_1.poll)(async () => {
            try {
              if (!filter) {
                try {
                  filter = await (0, createPendingTransactionFilter_js_1.createPendingTransactionFilter)(client);
                  return;
                } catch (err) {
                  unwatch();
                  throw err;
                }
              }
              const hashes = await (0, getFilterChanges_js_1.getFilterChanges)(client, { filter });
              if (hashes.length === 0)
                return;
              if (batch)
                emit.onTransactions(hashes);
              else
                hashes.forEach((hash) => emit.onTransactions([hash]));
            } catch (err) {
              emit.onError?.(err);
            }
          }, {
            emitOnBegin: true,
            interval: pollingInterval
          });
          return async () => {
            if (filter)
              await (0, uninstallFilter_js_1.uninstallFilter)(client, { filter });
            unwatch();
          };
        });
      };
      const subscribePendingTransactions = () => {
        let active = true;
        let unsubscribe = () => active = false;
        (async () => {
          try {
            const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
              params: ["newPendingTransactions"],
              onData(data) {
                if (!active)
                  return;
                const transaction = data.result;
                onTransactions([transaction]);
              },
              onError(error) {
                onError?.(error);
              }
            });
            unsubscribe = unsubscribe_;
            if (!active)
              unsubscribe();
          } catch (err) {
            onError?.(err);
          }
        })();
        return unsubscribe;
      };
      return enablePolling ? pollPendingTransactions() : subscribePendingTransactions();
    }
    exports.watchPendingTransactions = watchPendingTransactions;
  }
});

// node_modules/viem/_cjs/clients/decorators/public.js
var require_public = __commonJS({
  "node_modules/viem/_cjs/clients/decorators/public.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.publicActions = void 0;
    var getEnsAddress_js_1 = require_getEnsAddress();
    var getEnsAvatar_js_1 = require_getEnsAvatar();
    var getEnsName_js_1 = require_getEnsName();
    var getEnsResolver_js_1 = require_getEnsResolver();
    var getEnsText_js_1 = require_getEnsText();
    var call_js_1 = require_call();
    var createBlockFilter_js_1 = require_createBlockFilter();
    var createContractEventFilter_js_1 = require_createContractEventFilter();
    var createEventFilter_js_1 = require_createEventFilter();
    var createPendingTransactionFilter_js_1 = require_createPendingTransactionFilter();
    var estimateContractGas_js_1 = require_estimateContractGas();
    var estimateFeesPerGas_js_1 = require_estimateFeesPerGas();
    var estimateGas_js_1 = require_estimateGas2();
    var estimateMaxPriorityFeePerGas_js_1 = require_estimateMaxPriorityFeePerGas();
    var getBalance_js_1 = require_getBalance();
    var getBlock_js_1 = require_getBlock();
    var getBlockNumber_js_1 = require_getBlockNumber();
    var getBlockTransactionCount_js_1 = require_getBlockTransactionCount();
    var getBytecode_js_1 = require_getBytecode();
    var getChainId_js_1 = require_getChainId();
    var getFeeHistory_js_1 = require_getFeeHistory();
    var getFilterChanges_js_1 = require_getFilterChanges();
    var getFilterLogs_js_1 = require_getFilterLogs();
    var getGasPrice_js_1 = require_getGasPrice();
    var getLogs_js_1 = require_getLogs();
    var getStorageAt_js_1 = require_getStorageAt();
    var getTransaction_js_1 = require_getTransaction();
    var getTransactionConfirmations_js_1 = require_getTransactionConfirmations();
    var getTransactionCount_js_1 = require_getTransactionCount();
    var getTransactionReceipt_js_1 = require_getTransactionReceipt();
    var multicall_js_1 = require_multicall();
    var readContract_js_1 = require_readContract();
    var simulateContract_js_1 = require_simulateContract();
    var uninstallFilter_js_1 = require_uninstallFilter();
    var verifyMessage_js_1 = require_verifyMessage2();
    var verifyTypedData_js_1 = require_verifyTypedData2();
    var waitForTransactionReceipt_js_1 = require_waitForTransactionReceipt();
    var watchBlockNumber_js_1 = require_watchBlockNumber();
    var watchBlocks_js_1 = require_watchBlocks();
    var watchContractEvent_js_1 = require_watchContractEvent();
    var watchEvent_js_1 = require_watchEvent();
    var watchPendingTransactions_js_1 = require_watchPendingTransactions();
    var prepareTransactionRequest_js_1 = require_prepareTransactionRequest();
    var sendRawTransaction_js_1 = require_sendRawTransaction();
    function publicActions(client) {
      return {
        call: (args) => (0, call_js_1.call)(client, args),
        createBlockFilter: () => (0, createBlockFilter_js_1.createBlockFilter)(client),
        createContractEventFilter: (args) => (0, createContractEventFilter_js_1.createContractEventFilter)(client, args),
        createEventFilter: (args) => (0, createEventFilter_js_1.createEventFilter)(client, args),
        createPendingTransactionFilter: () => (0, createPendingTransactionFilter_js_1.createPendingTransactionFilter)(client),
        estimateContractGas: (args) => (0, estimateContractGas_js_1.estimateContractGas)(client, args),
        estimateGas: (args) => (0, estimateGas_js_1.estimateGas)(client, args),
        getBalance: (args) => (0, getBalance_js_1.getBalance)(client, args),
        getBlock: (args) => (0, getBlock_js_1.getBlock)(client, args),
        getBlockNumber: (args) => (0, getBlockNumber_js_1.getBlockNumber)(client, args),
        getBlockTransactionCount: (args) => (0, getBlockTransactionCount_js_1.getBlockTransactionCount)(client, args),
        getBytecode: (args) => (0, getBytecode_js_1.getBytecode)(client, args),
        getChainId: () => (0, getChainId_js_1.getChainId)(client),
        getEnsAddress: (args) => (0, getEnsAddress_js_1.getEnsAddress)(client, args),
        getEnsAvatar: (args) => (0, getEnsAvatar_js_1.getEnsAvatar)(client, args),
        getEnsName: (args) => (0, getEnsName_js_1.getEnsName)(client, args),
        getEnsResolver: (args) => (0, getEnsResolver_js_1.getEnsResolver)(client, args),
        getEnsText: (args) => (0, getEnsText_js_1.getEnsText)(client, args),
        getFeeHistory: (args) => (0, getFeeHistory_js_1.getFeeHistory)(client, args),
        estimateFeesPerGas: (args) => (0, estimateFeesPerGas_js_1.estimateFeesPerGas)(client, args),
        getFilterChanges: (args) => (0, getFilterChanges_js_1.getFilterChanges)(client, args),
        getFilterLogs: (args) => (0, getFilterLogs_js_1.getFilterLogs)(client, args),
        getGasPrice: () => (0, getGasPrice_js_1.getGasPrice)(client),
        getLogs: (args) => (0, getLogs_js_1.getLogs)(client, args),
        estimateMaxPriorityFeePerGas: (args) => (0, estimateMaxPriorityFeePerGas_js_1.estimateMaxPriorityFeePerGas)(client, args),
        getStorageAt: (args) => (0, getStorageAt_js_1.getStorageAt)(client, args),
        getTransaction: (args) => (0, getTransaction_js_1.getTransaction)(client, args),
        getTransactionConfirmations: (args) => (0, getTransactionConfirmations_js_1.getTransactionConfirmations)(client, args),
        getTransactionCount: (args) => (0, getTransactionCount_js_1.getTransactionCount)(client, args),
        getTransactionReceipt: (args) => (0, getTransactionReceipt_js_1.getTransactionReceipt)(client, args),
        multicall: (args) => (0, multicall_js_1.multicall)(client, args),
        prepareTransactionRequest: (args) => (0, prepareTransactionRequest_js_1.prepareTransactionRequest)(client, args),
        readContract: (args) => (0, readContract_js_1.readContract)(client, args),
        sendRawTransaction: (args) => (0, sendRawTransaction_js_1.sendRawTransaction)(client, args),
        simulateContract: (args) => (0, simulateContract_js_1.simulateContract)(client, args),
        verifyMessage: (args) => (0, verifyMessage_js_1.verifyMessage)(client, args),
        verifyTypedData: (args) => (0, verifyTypedData_js_1.verifyTypedData)(client, args),
        uninstallFilter: (args) => (0, uninstallFilter_js_1.uninstallFilter)(client, args),
        waitForTransactionReceipt: (args) => (0, waitForTransactionReceipt_js_1.waitForTransactionReceipt)(client, args),
        watchBlocks: (args) => (0, watchBlocks_js_1.watchBlocks)(client, args),
        watchBlockNumber: (args) => (0, watchBlockNumber_js_1.watchBlockNumber)(client, args),
        watchContractEvent: (args) => (0, watchContractEvent_js_1.watchContractEvent)(client, args),
        watchEvent: (args) => (0, watchEvent_js_1.watchEvent)(client, args),
        watchPendingTransactions: (args) => (0, watchPendingTransactions_js_1.watchPendingTransactions)(client, args)
      };
    }
    exports.publicActions = publicActions;
  }
});

// node_modules/viem/_cjs/clients/createPublicClient.js
var require_createPublicClient = __commonJS({
  "node_modules/viem/_cjs/clients/createPublicClient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createPublicClient = void 0;
    var createClient_js_1 = require_createClient();
    var public_js_1 = require_public();
    function createPublicClient(parameters) {
      const { key = "public", name = "Public Client" } = parameters;
      const client = (0, createClient_js_1.createClient)({
        ...parameters,
        key,
        name,
        type: "publicClient"
      });
      return client.extend(public_js_1.publicActions);
    }
    exports.createPublicClient = createPublicClient;
  }
});

// node_modules/viem/_cjs/actions/test/dropTransaction.js
var require_dropTransaction = __commonJS({
  "node_modules/viem/_cjs/actions/test/dropTransaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dropTransaction = void 0;
    async function dropTransaction(client, { hash }) {
      await client.request({
        method: `${client.mode}_dropTransaction`,
        params: [hash]
      });
    }
    exports.dropTransaction = dropTransaction;
  }
});

// node_modules/viem/_cjs/actions/test/getAutomine.js
var require_getAutomine = __commonJS({
  "node_modules/viem/_cjs/actions/test/getAutomine.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getAutomine = void 0;
    async function getAutomine(client) {
      if (client.mode === "ganache")
        return await client.request({
          method: "eth_mining"
        });
      return await client.request({
        method: `${client.mode}_getAutomine`
      });
    }
    exports.getAutomine = getAutomine;
  }
});

// node_modules/viem/_cjs/actions/test/getTxpoolContent.js
var require_getTxpoolContent = __commonJS({
  "node_modules/viem/_cjs/actions/test/getTxpoolContent.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTxpoolContent = void 0;
    async function getTxpoolContent(client) {
      return await client.request({
        method: "txpool_content"
      });
    }
    exports.getTxpoolContent = getTxpoolContent;
  }
});

// node_modules/viem/_cjs/actions/test/getTxpoolStatus.js
var require_getTxpoolStatus = __commonJS({
  "node_modules/viem/_cjs/actions/test/getTxpoolStatus.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTxpoolStatus = void 0;
    var fromHex_js_1 = require_fromHex();
    async function getTxpoolStatus(client) {
      const { pending, queued } = await client.request({
        method: "txpool_status"
      });
      return {
        pending: (0, fromHex_js_1.hexToNumber)(pending),
        queued: (0, fromHex_js_1.hexToNumber)(queued)
      };
    }
    exports.getTxpoolStatus = getTxpoolStatus;
  }
});

// node_modules/viem/_cjs/actions/test/impersonateAccount.js
var require_impersonateAccount = __commonJS({
  "node_modules/viem/_cjs/actions/test/impersonateAccount.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.impersonateAccount = void 0;
    async function impersonateAccount(client, { address }) {
      await client.request({
        method: `${client.mode}_impersonateAccount`,
        params: [address]
      });
    }
    exports.impersonateAccount = impersonateAccount;
  }
});

// node_modules/viem/_cjs/actions/test/increaseTime.js
var require_increaseTime = __commonJS({
  "node_modules/viem/_cjs/actions/test/increaseTime.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.increaseTime = void 0;
    var toHex_js_1 = require_toHex();
    async function increaseTime(client, { seconds }) {
      return await client.request({
        method: "evm_increaseTime",
        params: [(0, toHex_js_1.numberToHex)(seconds)]
      });
    }
    exports.increaseTime = increaseTime;
  }
});

// node_modules/viem/_cjs/actions/test/inspectTxpool.js
var require_inspectTxpool = __commonJS({
  "node_modules/viem/_cjs/actions/test/inspectTxpool.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.inspectTxpool = void 0;
    async function inspectTxpool(client) {
      return await client.request({
        method: "txpool_inspect"
      });
    }
    exports.inspectTxpool = inspectTxpool;
  }
});

// node_modules/viem/_cjs/actions/test/mine.js
var require_mine = __commonJS({
  "node_modules/viem/_cjs/actions/test/mine.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mine = void 0;
    var toHex_js_1 = require_toHex();
    async function mine(client, { blocks, interval }) {
      if (client.mode === "ganache")
        await client.request({
          method: "evm_mine",
          params: [{ blocks: (0, toHex_js_1.numberToHex)(blocks) }]
        });
      else
        await client.request({
          method: `${client.mode}_mine`,
          params: [(0, toHex_js_1.numberToHex)(blocks), (0, toHex_js_1.numberToHex)(interval || 0)]
        });
    }
    exports.mine = mine;
  }
});

// node_modules/viem/_cjs/actions/test/removeBlockTimestampInterval.js
var require_removeBlockTimestampInterval = __commonJS({
  "node_modules/viem/_cjs/actions/test/removeBlockTimestampInterval.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.removeBlockTimestampInterval = void 0;
    async function removeBlockTimestampInterval(client) {
      await client.request({
        method: `${client.mode}_removeBlockTimestampInterval`
      });
    }
    exports.removeBlockTimestampInterval = removeBlockTimestampInterval;
  }
});

// node_modules/viem/_cjs/actions/test/reset.js
var require_reset = __commonJS({
  "node_modules/viem/_cjs/actions/test/reset.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reset = void 0;
    async function reset(client, { blockNumber, jsonRpcUrl } = {}) {
      await client.request({
        method: `${client.mode}_reset`,
        params: [{ forking: { blockNumber: Number(blockNumber), jsonRpcUrl } }]
      });
    }
    exports.reset = reset;
  }
});

// node_modules/viem/_cjs/actions/test/revert.js
var require_revert = __commonJS({
  "node_modules/viem/_cjs/actions/test/revert.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.revert = void 0;
    async function revert(client, { id }) {
      await client.request({
        method: "evm_revert",
        params: [id]
      });
    }
    exports.revert = revert;
  }
});

// node_modules/viem/_cjs/actions/test/sendUnsignedTransaction.js
var require_sendUnsignedTransaction = __commonJS({
  "node_modules/viem/_cjs/actions/test/sendUnsignedTransaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sendUnsignedTransaction = void 0;
    var extract_js_1 = require_extract();
    var transactionRequest_js_1 = require_transactionRequest();
    async function sendUnsignedTransaction(client, args) {
      const { accessList, data, from, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = args;
      const format = client.chain?.formatters?.transactionRequest?.format || transactionRequest_js_1.formatTransactionRequest;
      const request = format({
        ...(0, extract_js_1.extract)(rest, { format }),
        accessList,
        data,
        from,
        gas,
        gasPrice,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        to,
        value
      });
      const hash = await client.request({
        method: "eth_sendUnsignedTransaction",
        params: [request]
      });
      return hash;
    }
    exports.sendUnsignedTransaction = sendUnsignedTransaction;
  }
});

// node_modules/viem/_cjs/actions/test/setAutomine.js
var require_setAutomine = __commonJS({
  "node_modules/viem/_cjs/actions/test/setAutomine.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setAutomine = void 0;
    async function setAutomine(client, enabled) {
      if (client.mode === "ganache") {
        if (enabled)
          await client.request({ method: "miner_start" });
        else
          await client.request({ method: "miner_stop" });
      } else
        await client.request({
          method: "evm_setAutomine",
          params: [enabled]
        });
    }
    exports.setAutomine = setAutomine;
  }
});

// node_modules/viem/_cjs/actions/test/setBalance.js
var require_setBalance = __commonJS({
  "node_modules/viem/_cjs/actions/test/setBalance.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setBalance = void 0;
    var toHex_js_1 = require_toHex();
    async function setBalance(client, { address, value }) {
      if (client.mode === "ganache")
        await client.request({
          method: "evm_setAccountBalance",
          params: [address, (0, toHex_js_1.numberToHex)(value)]
        });
      else
        await client.request({
          method: `${client.mode}_setBalance`,
          params: [address, (0, toHex_js_1.numberToHex)(value)]
        });
    }
    exports.setBalance = setBalance;
  }
});

// node_modules/viem/_cjs/actions/test/setBlockGasLimit.js
var require_setBlockGasLimit = __commonJS({
  "node_modules/viem/_cjs/actions/test/setBlockGasLimit.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setBlockGasLimit = void 0;
    var toHex_js_1 = require_toHex();
    async function setBlockGasLimit(client, { gasLimit }) {
      await client.request({
        method: "evm_setBlockGasLimit",
        params: [(0, toHex_js_1.numberToHex)(gasLimit)]
      });
    }
    exports.setBlockGasLimit = setBlockGasLimit;
  }
});

// node_modules/viem/_cjs/actions/test/setBlockTimestampInterval.js
var require_setBlockTimestampInterval = __commonJS({
  "node_modules/viem/_cjs/actions/test/setBlockTimestampInterval.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setBlockTimestampInterval = void 0;
    async function setBlockTimestampInterval(client, { interval }) {
      await client.request({
        method: `${client.mode}_setBlockTimestampInterval`,
        params: [interval]
      });
    }
    exports.setBlockTimestampInterval = setBlockTimestampInterval;
  }
});

// node_modules/viem/_cjs/actions/test/setCode.js
var require_setCode = __commonJS({
  "node_modules/viem/_cjs/actions/test/setCode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setCode = void 0;
    async function setCode(client, { address, bytecode }) {
      await client.request({
        method: `${client.mode}_setCode`,
        params: [address, bytecode]
      });
    }
    exports.setCode = setCode;
  }
});

// node_modules/viem/_cjs/actions/test/setCoinbase.js
var require_setCoinbase = __commonJS({
  "node_modules/viem/_cjs/actions/test/setCoinbase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setCoinbase = void 0;
    async function setCoinbase(client, { address }) {
      await client.request({
        method: `${client.mode}_setCoinbase`,
        params: [address]
      });
    }
    exports.setCoinbase = setCoinbase;
  }
});

// node_modules/viem/_cjs/actions/test/setIntervalMining.js
var require_setIntervalMining = __commonJS({
  "node_modules/viem/_cjs/actions/test/setIntervalMining.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setIntervalMining = void 0;
    async function setIntervalMining(client, { interval }) {
      await client.request({
        method: "evm_setIntervalMining",
        params: [interval]
      });
    }
    exports.setIntervalMining = setIntervalMining;
  }
});

// node_modules/viem/_cjs/actions/test/setLoggingEnabled.js
var require_setLoggingEnabled = __commonJS({
  "node_modules/viem/_cjs/actions/test/setLoggingEnabled.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setLoggingEnabled = void 0;
    async function setLoggingEnabled(client, enabled) {
      await client.request({
        method: `${client.mode}_setLoggingEnabled`,
        params: [enabled]
      });
    }
    exports.setLoggingEnabled = setLoggingEnabled;
  }
});

// node_modules/viem/_cjs/actions/test/setMinGasPrice.js
var require_setMinGasPrice = __commonJS({
  "node_modules/viem/_cjs/actions/test/setMinGasPrice.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setMinGasPrice = void 0;
    var toHex_js_1 = require_toHex();
    async function setMinGasPrice(client, { gasPrice }) {
      await client.request({
        method: `${client.mode}_setMinGasPrice`,
        params: [(0, toHex_js_1.numberToHex)(gasPrice)]
      });
    }
    exports.setMinGasPrice = setMinGasPrice;
  }
});

// node_modules/viem/_cjs/actions/test/setNextBlockBaseFeePerGas.js
var require_setNextBlockBaseFeePerGas = __commonJS({
  "node_modules/viem/_cjs/actions/test/setNextBlockBaseFeePerGas.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setNextBlockBaseFeePerGas = void 0;
    var toHex_js_1 = require_toHex();
    async function setNextBlockBaseFeePerGas(client, { baseFeePerGas }) {
      await client.request({
        method: `${client.mode}_setNextBlockBaseFeePerGas`,
        params: [(0, toHex_js_1.numberToHex)(baseFeePerGas)]
      });
    }
    exports.setNextBlockBaseFeePerGas = setNextBlockBaseFeePerGas;
  }
});

// node_modules/viem/_cjs/actions/test/setNextBlockTimestamp.js
var require_setNextBlockTimestamp = __commonJS({
  "node_modules/viem/_cjs/actions/test/setNextBlockTimestamp.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setNextBlockTimestamp = void 0;
    var toHex_js_1 = require_toHex();
    async function setNextBlockTimestamp(client, { timestamp }) {
      await client.request({
        method: "evm_setNextBlockTimestamp",
        params: [(0, toHex_js_1.numberToHex)(timestamp)]
      });
    }
    exports.setNextBlockTimestamp = setNextBlockTimestamp;
  }
});

// node_modules/viem/_cjs/actions/test/setNonce.js
var require_setNonce = __commonJS({
  "node_modules/viem/_cjs/actions/test/setNonce.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setNonce = void 0;
    var toHex_js_1 = require_toHex();
    async function setNonce(client, { address, nonce }) {
      await client.request({
        method: `${client.mode}_setNonce`,
        params: [address, (0, toHex_js_1.numberToHex)(nonce)]
      });
    }
    exports.setNonce = setNonce;
  }
});

// node_modules/viem/_cjs/actions/test/setRpcUrl.js
var require_setRpcUrl = __commonJS({
  "node_modules/viem/_cjs/actions/test/setRpcUrl.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setRpcUrl = void 0;
    async function setRpcUrl(client, jsonRpcUrl) {
      await client.request({
        method: `${client.mode}_setRpcUrl`,
        params: [jsonRpcUrl]
      });
    }
    exports.setRpcUrl = setRpcUrl;
  }
});

// node_modules/viem/_cjs/actions/test/setStorageAt.js
var require_setStorageAt = __commonJS({
  "node_modules/viem/_cjs/actions/test/setStorageAt.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setStorageAt = void 0;
    var toHex_js_1 = require_toHex();
    async function setStorageAt(client, { address, index, value }) {
      await client.request({
        method: `${client.mode}_setStorageAt`,
        params: [
          address,
          typeof index === "number" ? (0, toHex_js_1.numberToHex)(index) : index,
          value
        ]
      });
    }
    exports.setStorageAt = setStorageAt;
  }
});

// node_modules/viem/_cjs/actions/test/snapshot.js
var require_snapshot = __commonJS({
  "node_modules/viem/_cjs/actions/test/snapshot.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.snapshot = void 0;
    async function snapshot(client) {
      return await client.request({
        method: "evm_snapshot"
      });
    }
    exports.snapshot = snapshot;
  }
});

// node_modules/viem/_cjs/actions/test/stopImpersonatingAccount.js
var require_stopImpersonatingAccount = __commonJS({
  "node_modules/viem/_cjs/actions/test/stopImpersonatingAccount.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stopImpersonatingAccount = void 0;
    async function stopImpersonatingAccount(client, { address }) {
      await client.request({
        method: `${client.mode}_stopImpersonatingAccount`,
        params: [address]
      });
    }
    exports.stopImpersonatingAccount = stopImpersonatingAccount;
  }
});

// node_modules/viem/_cjs/clients/decorators/test.js
var require_test = __commonJS({
  "node_modules/viem/_cjs/clients/decorators/test.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.testActions = void 0;
    var dropTransaction_js_1 = require_dropTransaction();
    var getAutomine_js_1 = require_getAutomine();
    var getTxpoolContent_js_1 = require_getTxpoolContent();
    var getTxpoolStatus_js_1 = require_getTxpoolStatus();
    var impersonateAccount_js_1 = require_impersonateAccount();
    var increaseTime_js_1 = require_increaseTime();
    var inspectTxpool_js_1 = require_inspectTxpool();
    var mine_js_1 = require_mine();
    var removeBlockTimestampInterval_js_1 = require_removeBlockTimestampInterval();
    var reset_js_1 = require_reset();
    var revert_js_1 = require_revert();
    var sendUnsignedTransaction_js_1 = require_sendUnsignedTransaction();
    var setAutomine_js_1 = require_setAutomine();
    var setBalance_js_1 = require_setBalance();
    var setBlockGasLimit_js_1 = require_setBlockGasLimit();
    var setBlockTimestampInterval_js_1 = require_setBlockTimestampInterval();
    var setCode_js_1 = require_setCode();
    var setCoinbase_js_1 = require_setCoinbase();
    var setIntervalMining_js_1 = require_setIntervalMining();
    var setLoggingEnabled_js_1 = require_setLoggingEnabled();
    var setMinGasPrice_js_1 = require_setMinGasPrice();
    var setNextBlockBaseFeePerGas_js_1 = require_setNextBlockBaseFeePerGas();
    var setNextBlockTimestamp_js_1 = require_setNextBlockTimestamp();
    var setNonce_js_1 = require_setNonce();
    var setRpcUrl_js_1 = require_setRpcUrl();
    var setStorageAt_js_1 = require_setStorageAt();
    var snapshot_js_1 = require_snapshot();
    var stopImpersonatingAccount_js_1 = require_stopImpersonatingAccount();
    function testActions({ mode }) {
      return (client_) => {
        const client = client_.extend(() => ({
          mode
        }));
        return {
          dropTransaction: (args) => (0, dropTransaction_js_1.dropTransaction)(client, args),
          getAutomine: () => (0, getAutomine_js_1.getAutomine)(client),
          getTxpoolContent: () => (0, getTxpoolContent_js_1.getTxpoolContent)(client),
          getTxpoolStatus: () => (0, getTxpoolStatus_js_1.getTxpoolStatus)(client),
          impersonateAccount: (args) => (0, impersonateAccount_js_1.impersonateAccount)(client, args),
          increaseTime: (args) => (0, increaseTime_js_1.increaseTime)(client, args),
          inspectTxpool: () => (0, inspectTxpool_js_1.inspectTxpool)(client),
          mine: (args) => (0, mine_js_1.mine)(client, args),
          removeBlockTimestampInterval: () => (0, removeBlockTimestampInterval_js_1.removeBlockTimestampInterval)(client),
          reset: (args) => (0, reset_js_1.reset)(client, args),
          revert: (args) => (0, revert_js_1.revert)(client, args),
          sendUnsignedTransaction: (args) => (0, sendUnsignedTransaction_js_1.sendUnsignedTransaction)(client, args),
          setAutomine: (args) => (0, setAutomine_js_1.setAutomine)(client, args),
          setBalance: (args) => (0, setBalance_js_1.setBalance)(client, args),
          setBlockGasLimit: (args) => (0, setBlockGasLimit_js_1.setBlockGasLimit)(client, args),
          setBlockTimestampInterval: (args) => (0, setBlockTimestampInterval_js_1.setBlockTimestampInterval)(client, args),
          setCode: (args) => (0, setCode_js_1.setCode)(client, args),
          setCoinbase: (args) => (0, setCoinbase_js_1.setCoinbase)(client, args),
          setIntervalMining: (args) => (0, setIntervalMining_js_1.setIntervalMining)(client, args),
          setLoggingEnabled: (args) => (0, setLoggingEnabled_js_1.setLoggingEnabled)(client, args),
          setMinGasPrice: (args) => (0, setMinGasPrice_js_1.setMinGasPrice)(client, args),
          setNextBlockBaseFeePerGas: (args) => (0, setNextBlockBaseFeePerGas_js_1.setNextBlockBaseFeePerGas)(client, args),
          setNextBlockTimestamp: (args) => (0, setNextBlockTimestamp_js_1.setNextBlockTimestamp)(client, args),
          setNonce: (args) => (0, setNonce_js_1.setNonce)(client, args),
          setRpcUrl: (args) => (0, setRpcUrl_js_1.setRpcUrl)(client, args),
          setStorageAt: (args) => (0, setStorageAt_js_1.setStorageAt)(client, args),
          snapshot: () => (0, snapshot_js_1.snapshot)(client),
          stopImpersonatingAccount: (args) => (0, stopImpersonatingAccount_js_1.stopImpersonatingAccount)(client, args)
        };
      };
    }
    exports.testActions = testActions;
  }
});

// node_modules/viem/_cjs/clients/createTestClient.js
var require_createTestClient = __commonJS({
  "node_modules/viem/_cjs/clients/createTestClient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createTestClient = void 0;
    var createClient_js_1 = require_createClient();
    var test_js_1 = require_test();
    function createTestClient(parameters) {
      const { key = "test", name = "Test Client", mode } = parameters;
      const client = (0, createClient_js_1.createClient)({
        ...parameters,
        key,
        name,
        type: "testClient"
      });
      return client.extend((config) => ({
        mode,
        ...(0, test_js_1.testActions)({ mode })(config)
      }));
    }
    exports.createTestClient = createTestClient;
  }
});

// node_modules/viem/_cjs/actions/wallet/addChain.js
var require_addChain = __commonJS({
  "node_modules/viem/_cjs/actions/wallet/addChain.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.addChain = void 0;
    var toHex_js_1 = require_toHex();
    async function addChain(client, { chain }) {
      const { id, name, nativeCurrency, rpcUrls, blockExplorers } = chain;
      await client.request({
        method: "wallet_addEthereumChain",
        params: [
          {
            chainId: (0, toHex_js_1.numberToHex)(id),
            chainName: name,
            nativeCurrency,
            rpcUrls: rpcUrls.default.http,
            blockExplorerUrls: blockExplorers ? Object.values(blockExplorers).map(({ url }) => url) : void 0
          }
        ]
      });
    }
    exports.addChain = addChain;
  }
});

// node_modules/viem/_cjs/actions/wallet/deployContract.js
var require_deployContract = __commonJS({
  "node_modules/viem/_cjs/actions/wallet/deployContract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deployContract = void 0;
    var encodeDeployData_js_1 = require_encodeDeployData();
    var sendTransaction_js_1 = require_sendTransaction();
    function deployContract(walletClient, { abi, args, bytecode, ...request }) {
      const calldata = (0, encodeDeployData_js_1.encodeDeployData)({
        abi,
        args,
        bytecode
      });
      return (0, sendTransaction_js_1.sendTransaction)(walletClient, {
        ...request,
        data: calldata
      });
    }
    exports.deployContract = deployContract;
  }
});

// node_modules/viem/_cjs/actions/wallet/getAddresses.js
var require_getAddresses = __commonJS({
  "node_modules/viem/_cjs/actions/wallet/getAddresses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getAddresses = void 0;
    var getAddress_js_1 = require_getAddress();
    async function getAddresses(client) {
      const addresses = await client.request({ method: "eth_accounts" });
      return addresses.map((address) => (0, getAddress_js_1.checksumAddress)(address));
    }
    exports.getAddresses = getAddresses;
  }
});

// node_modules/viem/_cjs/actions/wallet/getPermissions.js
var require_getPermissions = __commonJS({
  "node_modules/viem/_cjs/actions/wallet/getPermissions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getPermissions = void 0;
    async function getPermissions(client) {
      const permissions = await client.request({ method: "wallet_getPermissions" });
      return permissions;
    }
    exports.getPermissions = getPermissions;
  }
});

// node_modules/viem/_cjs/actions/wallet/requestAddresses.js
var require_requestAddresses = __commonJS({
  "node_modules/viem/_cjs/actions/wallet/requestAddresses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.requestAddresses = void 0;
    var getAddress_js_1 = require_getAddress();
    async function requestAddresses(client) {
      const addresses = await client.request({ method: "eth_requestAccounts" });
      return addresses.map((address) => (0, getAddress_js_1.getAddress)(address));
    }
    exports.requestAddresses = requestAddresses;
  }
});

// node_modules/viem/_cjs/actions/wallet/requestPermissions.js
var require_requestPermissions = __commonJS({
  "node_modules/viem/_cjs/actions/wallet/requestPermissions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.requestPermissions = void 0;
    async function requestPermissions(client, permissions) {
      return client.request({
        method: "wallet_requestPermissions",
        params: [permissions]
      });
    }
    exports.requestPermissions = requestPermissions;
  }
});

// node_modules/viem/_cjs/actions/wallet/signMessage.js
var require_signMessage = __commonJS({
  "node_modules/viem/_cjs/actions/wallet/signMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.signMessage = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var account_js_1 = require_account();
    var toHex_js_1 = require_toHex();
    async function signMessage(client, { account: account_ = client.account, message }) {
      if (!account_)
        throw new account_js_1.AccountNotFoundError({
          docsPath: "/docs/actions/wallet/signMessage"
        });
      const account = (0, parseAccount_js_1.parseAccount)(account_);
      if (account.type === "local")
        return account.signMessage({ message });
      const message_ = (() => {
        if (typeof message === "string")
          return (0, toHex_js_1.stringToHex)(message);
        if (message.raw instanceof Uint8Array)
          return (0, toHex_js_1.toHex)(message.raw);
        return message.raw;
      })();
      return client.request({
        method: "personal_sign",
        params: [message_, account.address]
      });
    }
    exports.signMessage = signMessage;
  }
});

// node_modules/viem/_cjs/actions/wallet/signTransaction.js
var require_signTransaction = __commonJS({
  "node_modules/viem/_cjs/actions/wallet/signTransaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.signTransaction = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var account_js_1 = require_account();
    var chain_js_1 = require_chain2();
    var transactionRequest_js_1 = require_transactionRequest();
    var index_js_1 = require_utils8();
    var assertRequest_js_1 = require_assertRequest();
    var getChainId_js_1 = require_getChainId();
    async function signTransaction(client, args) {
      const { account: account_ = client.account, chain = client.chain, ...transaction } = args;
      if (!account_)
        throw new account_js_1.AccountNotFoundError({
          docsPath: "/docs/actions/wallet/signTransaction"
        });
      const account = (0, parseAccount_js_1.parseAccount)(account_);
      (0, assertRequest_js_1.assertRequest)({
        account,
        ...args
      });
      const chainId = await (0, getChainId_js_1.getChainId)(client);
      if (chain !== null)
        (0, chain_js_1.assertCurrentChain)({
          currentChainId: chainId,
          chain
        });
      const formatters = chain?.formatters || client.chain?.formatters;
      const format = formatters?.transactionRequest?.format || transactionRequest_js_1.formatTransactionRequest;
      if (account.type === "local")
        return account.signTransaction({
          chainId,
          ...transaction
        }, { serializer: client.chain?.serializers?.transaction });
      return await client.request({
        method: "eth_signTransaction",
        params: [
          {
            ...format(transaction),
            chainId: (0, index_js_1.numberToHex)(chainId),
            from: account.address
          }
        ]
      });
    }
    exports.signTransaction = signTransaction;
  }
});

// node_modules/viem/_cjs/actions/wallet/signTypedData.js
var require_signTypedData = __commonJS({
  "node_modules/viem/_cjs/actions/wallet/signTypedData.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.signTypedData = void 0;
    var parseAccount_js_1 = require_parseAccount();
    var account_js_1 = require_account();
    var isHex_js_1 = require_isHex();
    var stringify_js_1 = require_stringify();
    var typedData_js_1 = require_typedData();
    async function signTypedData(client, { account: account_ = client.account, domain, message, primaryType, types: types_ }) {
      if (!account_)
        throw new account_js_1.AccountNotFoundError({
          docsPath: "/docs/actions/wallet/signTypedData"
        });
      const account = (0, parseAccount_js_1.parseAccount)(account_);
      const types = {
        EIP712Domain: (0, typedData_js_1.getTypesForEIP712Domain)({ domain }),
        ...types_
      };
      (0, typedData_js_1.validateTypedData)({
        domain,
        message,
        primaryType,
        types
      });
      if (account.type === "local")
        return account.signTypedData({
          domain,
          primaryType,
          types,
          message
        });
      const typedData = (0, stringify_js_1.stringify)({ domain: domain ?? {}, primaryType, types, message }, (_, value) => (0, isHex_js_1.isHex)(value) ? value.toLowerCase() : value);
      return client.request({
        method: "eth_signTypedData_v4",
        params: [account.address, typedData]
      });
    }
    exports.signTypedData = signTypedData;
  }
});

// node_modules/viem/_cjs/actions/wallet/switchChain.js
var require_switchChain = __commonJS({
  "node_modules/viem/_cjs/actions/wallet/switchChain.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.switchChain = void 0;
    var toHex_js_1 = require_toHex();
    async function switchChain(client, { id }) {
      await client.request({
        method: "wallet_switchEthereumChain",
        params: [
          {
            chainId: (0, toHex_js_1.numberToHex)(id)
          }
        ]
      });
    }
    exports.switchChain = switchChain;
  }
});

// node_modules/viem/_cjs/actions/wallet/watchAsset.js
var require_watchAsset = __commonJS({
  "node_modules/viem/_cjs/actions/wallet/watchAsset.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.watchAsset = void 0;
    async function watchAsset(client, params) {
      const added = await client.request({
        method: "wallet_watchAsset",
        params
      });
      return added;
    }
    exports.watchAsset = watchAsset;
  }
});

// node_modules/viem/_cjs/clients/decorators/wallet.js
var require_wallet = __commonJS({
  "node_modules/viem/_cjs/clients/decorators/wallet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.walletActions = void 0;
    var getChainId_js_1 = require_getChainId();
    var addChain_js_1 = require_addChain();
    var deployContract_js_1 = require_deployContract();
    var getAddresses_js_1 = require_getAddresses();
    var getPermissions_js_1 = require_getPermissions();
    var prepareTransactionRequest_js_1 = require_prepareTransactionRequest();
    var requestAddresses_js_1 = require_requestAddresses();
    var requestPermissions_js_1 = require_requestPermissions();
    var sendRawTransaction_js_1 = require_sendRawTransaction();
    var sendTransaction_js_1 = require_sendTransaction();
    var signMessage_js_1 = require_signMessage();
    var signTransaction_js_1 = require_signTransaction();
    var signTypedData_js_1 = require_signTypedData();
    var switchChain_js_1 = require_switchChain();
    var watchAsset_js_1 = require_watchAsset();
    var writeContract_js_1 = require_writeContract();
    function walletActions(client) {
      return {
        addChain: (args) => (0, addChain_js_1.addChain)(client, args),
        deployContract: (args) => (0, deployContract_js_1.deployContract)(client, args),
        getAddresses: () => (0, getAddresses_js_1.getAddresses)(client),
        getChainId: () => (0, getChainId_js_1.getChainId)(client),
        getPermissions: () => (0, getPermissions_js_1.getPermissions)(client),
        prepareTransactionRequest: (args) => (0, prepareTransactionRequest_js_1.prepareTransactionRequest)(client, args),
        requestAddresses: () => (0, requestAddresses_js_1.requestAddresses)(client),
        requestPermissions: (args) => (0, requestPermissions_js_1.requestPermissions)(client, args),
        sendRawTransaction: (args) => (0, sendRawTransaction_js_1.sendRawTransaction)(client, args),
        sendTransaction: (args) => (0, sendTransaction_js_1.sendTransaction)(client, args),
        signMessage: (args) => (0, signMessage_js_1.signMessage)(client, args),
        signTransaction: (args) => (0, signTransaction_js_1.signTransaction)(client, args),
        signTypedData: (args) => (0, signTypedData_js_1.signTypedData)(client, args),
        switchChain: (args) => (0, switchChain_js_1.switchChain)(client, args),
        watchAsset: (args) => (0, watchAsset_js_1.watchAsset)(client, args),
        writeContract: (args) => (0, writeContract_js_1.writeContract)(client, args)
      };
    }
    exports.walletActions = walletActions;
  }
});

// node_modules/viem/_cjs/clients/createWalletClient.js
var require_createWalletClient = __commonJS({
  "node_modules/viem/_cjs/clients/createWalletClient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createWalletClient = void 0;
    var createClient_js_1 = require_createClient();
    var wallet_js_1 = require_wallet();
    function createWalletClient(parameters) {
      const { key = "wallet", name = "Wallet Client", transport } = parameters;
      const client = (0, createClient_js_1.createClient)({
        ...parameters,
        key,
        name,
        transport: (opts) => transport({ ...opts, retryCount: 0 }),
        type: "walletClient"
      });
      return client.extend(wallet_js_1.walletActions);
    }
    exports.createWalletClient = createWalletClient;
  }
});

// node_modules/viem/_cjs/clients/transports/webSocket.js
var require_webSocket = __commonJS({
  "node_modules/viem/_cjs/clients/transports/webSocket.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.webSocket = void 0;
    var request_js_1 = require_request();
    var transport_js_1 = require_transport();
    var rpc_js_1 = require_rpc2();
    var createTransport_js_1 = require_createTransport();
    function webSocket(url, config = {}) {
      const { key = "webSocket", name = "WebSocket JSON-RPC", retryDelay } = config;
      return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {
        const retryCount = config.retryCount ?? retryCount_;
        const timeout = timeout_ ?? config.timeout ?? 1e4;
        const url_ = url || chain?.rpcUrls.default.webSocket?.[0];
        if (!url_)
          throw new transport_js_1.UrlRequiredError();
        return (0, createTransport_js_1.createTransport)({
          key,
          name,
          async request({ method, params }) {
            const body = { method, params };
            const socket = await (0, rpc_js_1.getSocket)(url_);
            const { error, result } = await rpc_js_1.rpc.webSocketAsync(socket, {
              body,
              timeout
            });
            if (error)
              throw new request_js_1.RpcRequestError({
                body,
                error,
                url: url_
              });
            return result;
          },
          retryCount,
          retryDelay,
          timeout,
          type: "webSocket"
        }, {
          getSocket() {
            return (0, rpc_js_1.getSocket)(url_);
          },
          async subscribe({ params, onData, onError }) {
            const socket = await (0, rpc_js_1.getSocket)(url_);
            const { result: subscriptionId } = await new Promise((resolve, reject) => rpc_js_1.rpc.webSocket(socket, {
              body: {
                method: "eth_subscribe",
                params
              },
              onResponse(response) {
                if (response.error) {
                  reject(response.error);
                  onError?.(response.error);
                  return;
                }
                if (typeof response.id === "number") {
                  resolve(response);
                  return;
                }
                if (response.method !== "eth_subscription")
                  return;
                onData(response.params);
              }
            }));
            return {
              subscriptionId,
              async unsubscribe() {
                return new Promise((resolve) => rpc_js_1.rpc.webSocket(socket, {
                  body: {
                    method: "eth_unsubscribe",
                    params: [subscriptionId]
                  },
                  onResponse: resolve
                }));
              }
            };
          }
        });
      };
    }
    exports.webSocket = webSocket;
  }
});

// node_modules/viem/_cjs/constants/address.js
var require_address2 = __commonJS({
  "node_modules/viem/_cjs/constants/address.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zeroAddress = void 0;
    exports.zeroAddress = "0x0000000000000000000000000000000000000000";
  }
});

// node_modules/viem/_cjs/constants/number.js
var require_number = __commonJS({
  "node_modules/viem/_cjs/constants/number.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.minInt144 = exports.minInt136 = exports.minInt128 = exports.minInt120 = exports.minInt112 = exports.minInt104 = exports.minInt96 = exports.minInt88 = exports.minInt80 = exports.minInt72 = exports.minInt64 = exports.minInt56 = exports.minInt48 = exports.minInt40 = exports.minInt32 = exports.minInt24 = exports.minInt16 = exports.minInt8 = exports.maxInt256 = exports.maxInt248 = exports.maxInt240 = exports.maxInt232 = exports.maxInt224 = exports.maxInt216 = exports.maxInt208 = exports.maxInt200 = exports.maxInt192 = exports.maxInt184 = exports.maxInt176 = exports.maxInt168 = exports.maxInt160 = exports.maxInt152 = exports.maxInt144 = exports.maxInt136 = exports.maxInt128 = exports.maxInt120 = exports.maxInt112 = exports.maxInt104 = exports.maxInt96 = exports.maxInt88 = exports.maxInt80 = exports.maxInt72 = exports.maxInt64 = exports.maxInt56 = exports.maxInt48 = exports.maxInt40 = exports.maxInt32 = exports.maxInt24 = exports.maxInt16 = exports.maxInt8 = void 0;
    exports.maxUint256 = exports.maxUint248 = exports.maxUint240 = exports.maxUint232 = exports.maxUint224 = exports.maxUint216 = exports.maxUint208 = exports.maxUint200 = exports.maxUint192 = exports.maxUint184 = exports.maxUint176 = exports.maxUint168 = exports.maxUint160 = exports.maxUint152 = exports.maxUint144 = exports.maxUint136 = exports.maxUint128 = exports.maxUint120 = exports.maxUint112 = exports.maxUint104 = exports.maxUint96 = exports.maxUint88 = exports.maxUint80 = exports.maxUint72 = exports.maxUint64 = exports.maxUint56 = exports.maxUint48 = exports.maxUint40 = exports.maxUint32 = exports.maxUint24 = exports.maxUint16 = exports.maxUint8 = exports.minInt256 = exports.minInt248 = exports.minInt240 = exports.minInt232 = exports.minInt224 = exports.minInt216 = exports.minInt208 = exports.minInt200 = exports.minInt192 = exports.minInt184 = exports.minInt176 = exports.minInt168 = exports.minInt160 = exports.minInt152 = void 0;
    exports.maxInt8 = 2n ** (8n - 1n) - 1n;
    exports.maxInt16 = 2n ** (16n - 1n) - 1n;
    exports.maxInt24 = 2n ** (24n - 1n) - 1n;
    exports.maxInt32 = 2n ** (32n - 1n) - 1n;
    exports.maxInt40 = 2n ** (40n - 1n) - 1n;
    exports.maxInt48 = 2n ** (48n - 1n) - 1n;
    exports.maxInt56 = 2n ** (56n - 1n) - 1n;
    exports.maxInt64 = 2n ** (64n - 1n) - 1n;
    exports.maxInt72 = 2n ** (72n - 1n) - 1n;
    exports.maxInt80 = 2n ** (80n - 1n) - 1n;
    exports.maxInt88 = 2n ** (88n - 1n) - 1n;
    exports.maxInt96 = 2n ** (96n - 1n) - 1n;
    exports.maxInt104 = 2n ** (104n - 1n) - 1n;
    exports.maxInt112 = 2n ** (112n - 1n) - 1n;
    exports.maxInt120 = 2n ** (120n - 1n) - 1n;
    exports.maxInt128 = 2n ** (128n - 1n) - 1n;
    exports.maxInt136 = 2n ** (136n - 1n) - 1n;
    exports.maxInt144 = 2n ** (144n - 1n) - 1n;
    exports.maxInt152 = 2n ** (152n - 1n) - 1n;
    exports.maxInt160 = 2n ** (160n - 1n) - 1n;
    exports.maxInt168 = 2n ** (168n - 1n) - 1n;
    exports.maxInt176 = 2n ** (176n - 1n) - 1n;
    exports.maxInt184 = 2n ** (184n - 1n) - 1n;
    exports.maxInt192 = 2n ** (192n - 1n) - 1n;
    exports.maxInt200 = 2n ** (200n - 1n) - 1n;
    exports.maxInt208 = 2n ** (208n - 1n) - 1n;
    exports.maxInt216 = 2n ** (216n - 1n) - 1n;
    exports.maxInt224 = 2n ** (224n - 1n) - 1n;
    exports.maxInt232 = 2n ** (232n - 1n) - 1n;
    exports.maxInt240 = 2n ** (240n - 1n) - 1n;
    exports.maxInt248 = 2n ** (248n - 1n) - 1n;
    exports.maxInt256 = 2n ** (256n - 1n) - 1n;
    exports.minInt8 = -(2n ** (8n - 1n));
    exports.minInt16 = -(2n ** (16n - 1n));
    exports.minInt24 = -(2n ** (24n - 1n));
    exports.minInt32 = -(2n ** (32n - 1n));
    exports.minInt40 = -(2n ** (40n - 1n));
    exports.minInt48 = -(2n ** (48n - 1n));
    exports.minInt56 = -(2n ** (56n - 1n));
    exports.minInt64 = -(2n ** (64n - 1n));
    exports.minInt72 = -(2n ** (72n - 1n));
    exports.minInt80 = -(2n ** (80n - 1n));
    exports.minInt88 = -(2n ** (88n - 1n));
    exports.minInt96 = -(2n ** (96n - 1n));
    exports.minInt104 = -(2n ** (104n - 1n));
    exports.minInt112 = -(2n ** (112n - 1n));
    exports.minInt120 = -(2n ** (120n - 1n));
    exports.minInt128 = -(2n ** (128n - 1n));
    exports.minInt136 = -(2n ** (136n - 1n));
    exports.minInt144 = -(2n ** (144n - 1n));
    exports.minInt152 = -(2n ** (152n - 1n));
    exports.minInt160 = -(2n ** (160n - 1n));
    exports.minInt168 = -(2n ** (168n - 1n));
    exports.minInt176 = -(2n ** (176n - 1n));
    exports.minInt184 = -(2n ** (184n - 1n));
    exports.minInt192 = -(2n ** (192n - 1n));
    exports.minInt200 = -(2n ** (200n - 1n));
    exports.minInt208 = -(2n ** (208n - 1n));
    exports.minInt216 = -(2n ** (216n - 1n));
    exports.minInt224 = -(2n ** (224n - 1n));
    exports.minInt232 = -(2n ** (232n - 1n));
    exports.minInt240 = -(2n ** (240n - 1n));
    exports.minInt248 = -(2n ** (248n - 1n));
    exports.minInt256 = -(2n ** (256n - 1n));
    exports.maxUint8 = 2n ** 8n - 1n;
    exports.maxUint16 = 2n ** 16n - 1n;
    exports.maxUint24 = 2n ** 24n - 1n;
    exports.maxUint32 = 2n ** 32n - 1n;
    exports.maxUint40 = 2n ** 40n - 1n;
    exports.maxUint48 = 2n ** 48n - 1n;
    exports.maxUint56 = 2n ** 56n - 1n;
    exports.maxUint64 = 2n ** 64n - 1n;
    exports.maxUint72 = 2n ** 72n - 1n;
    exports.maxUint80 = 2n ** 80n - 1n;
    exports.maxUint88 = 2n ** 88n - 1n;
    exports.maxUint96 = 2n ** 96n - 1n;
    exports.maxUint104 = 2n ** 104n - 1n;
    exports.maxUint112 = 2n ** 112n - 1n;
    exports.maxUint120 = 2n ** 120n - 1n;
    exports.maxUint128 = 2n ** 128n - 1n;
    exports.maxUint136 = 2n ** 136n - 1n;
    exports.maxUint144 = 2n ** 144n - 1n;
    exports.maxUint152 = 2n ** 152n - 1n;
    exports.maxUint160 = 2n ** 160n - 1n;
    exports.maxUint168 = 2n ** 168n - 1n;
    exports.maxUint176 = 2n ** 176n - 1n;
    exports.maxUint184 = 2n ** 184n - 1n;
    exports.maxUint192 = 2n ** 192n - 1n;
    exports.maxUint200 = 2n ** 200n - 1n;
    exports.maxUint208 = 2n ** 208n - 1n;
    exports.maxUint216 = 2n ** 216n - 1n;
    exports.maxUint224 = 2n ** 224n - 1n;
    exports.maxUint232 = 2n ** 232n - 1n;
    exports.maxUint240 = 2n ** 240n - 1n;
    exports.maxUint248 = 2n ** 248n - 1n;
    exports.maxUint256 = 2n ** 256n - 1n;
  }
});

// node_modules/viem/_cjs/utils/abi/decodeDeployData.js
var require_decodeDeployData = __commonJS({
  "node_modules/viem/_cjs/utils/abi/decodeDeployData.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeDeployData = void 0;
    var abi_js_1 = require_abi();
    var decodeAbiParameters_js_1 = require_decodeAbiParameters();
    var docsPath = "/docs/contract/decodeDeployData";
    function decodeDeployData({ abi, bytecode, data }) {
      if (data === bytecode)
        return { bytecode };
      const description = abi.find((x) => "type" in x && x.type === "constructor");
      if (!description)
        throw new abi_js_1.AbiConstructorNotFoundError({ docsPath });
      if (!("inputs" in description))
        throw new abi_js_1.AbiConstructorParamsNotFoundError({ docsPath });
      if (!description.inputs || description.inputs.length === 0)
        throw new abi_js_1.AbiConstructorParamsNotFoundError({ docsPath });
      const args = (0, decodeAbiParameters_js_1.decodeAbiParameters)(description.inputs, `0x${data.replace(bytecode, "")}`);
      return { args, bytecode };
    }
    exports.decodeDeployData = decodeDeployData;
  }
});

// node_modules/viem/_cjs/utils/signature/hexToSignature.js
var require_hexToSignature = __commonJS({
  "node_modules/viem/_cjs/utils/signature/hexToSignature.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hexToSignature = void 0;
    var secp256k1_1 = require_secp256k1();
    var toHex_js_1 = require_toHex();
    function hexToSignature(signatureHex) {
      const { r, s } = secp256k1_1.secp256k1.Signature.fromCompact(signatureHex.slice(2, 130));
      const v = BigInt(`0x${signatureHex.slice(130)}`);
      return { r: (0, toHex_js_1.numberToHex)(r, { size: 32 }), s: (0, toHex_js_1.numberToHex)(s, { size: 32 }), v };
    }
    exports.hexToSignature = hexToSignature;
  }
});

// node_modules/viem/_cjs/utils/signature/signatureToHex.js
var require_signatureToHex = __commonJS({
  "node_modules/viem/_cjs/utils/signature/signatureToHex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.signatureToHex = void 0;
    var secp256k1_1 = require_secp256k1();
    var fromHex_js_1 = require_fromHex();
    var toHex_js_1 = require_toHex();
    function signatureToHex({ r, s, v }) {
      return `0x${new secp256k1_1.secp256k1.Signature((0, fromHex_js_1.hexToBigInt)(r), (0, fromHex_js_1.hexToBigInt)(s)).toCompactHex()}${(0, toHex_js_1.toHex)(v).slice(2)}`;
    }
    exports.signatureToHex = signatureToHex;
  }
});

// node_modules/viem/_cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/viem/_cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.maxInt112 = exports.maxInt104 = exports.maxInt96 = exports.maxInt88 = exports.maxInt80 = exports.maxInt72 = exports.maxInt64 = exports.maxInt56 = exports.maxInt48 = exports.maxInt40 = exports.maxInt32 = exports.maxInt24 = exports.maxInt16 = exports.maxInt8 = exports.weiUnits = exports.gweiUnits = exports.etherUnits = exports.zeroAddress = exports.multicall3Abi = exports.webSocket = exports.createWalletClient = exports.createTransport = exports.walletActions = exports.testActions = exports.publicActions = exports.createTestClient = exports.createPublicClient = exports.http = exports.fallback = exports.custom = exports.createClient = exports.getContract = exports.parseAbiParameters = exports.parseAbiParameter = exports.parseAbiItem = exports.parseAbi = exports.UnknownSignatureError = exports.UnknownTypeError = exports.SolidityProtectedKeywordError = exports.InvalidStructSignatureError = exports.InvalidSignatureError = exports.InvalidParenthesisError = exports.InvalidParameterError = exports.InvalidModifierError = exports.InvalidFunctionModifierError = exports.InvalidAbiTypeParameterError = exports.InvalidAbiItemError = exports.InvalidAbiParametersError = exports.InvalidAbiParameterError = exports.CircularReferenceError = void 0;
    exports.maxUint256 = exports.maxUint248 = exports.maxUint240 = exports.maxUint232 = exports.maxUint224 = exports.maxUint216 = exports.maxUint208 = exports.maxUint200 = exports.maxUint192 = exports.maxUint184 = exports.maxUint176 = exports.maxUint168 = exports.maxUint160 = exports.maxUint152 = exports.maxUint144 = exports.maxUint136 = exports.maxUint128 = exports.maxUint120 = exports.maxUint112 = exports.maxUint104 = exports.maxUint96 = exports.maxUint88 = exports.maxUint80 = exports.maxUint72 = exports.maxUint64 = exports.maxUint56 = exports.maxUint48 = exports.maxUint40 = exports.maxUint32 = exports.maxUint24 = exports.maxUint16 = exports.maxUint8 = exports.maxInt256 = exports.maxInt248 = exports.maxInt240 = exports.maxInt232 = exports.maxInt224 = exports.maxInt216 = exports.maxInt208 = exports.maxInt200 = exports.maxInt192 = exports.maxInt184 = exports.maxInt176 = exports.maxInt168 = exports.maxInt160 = exports.maxInt152 = exports.maxInt144 = exports.maxInt136 = exports.maxInt128 = exports.maxInt120 = void 0;
    exports.InvalidAbiEncodingTypeError = exports.InvalidAbiDecodingTypeError = exports.DecodeLogTopicsMismatch = exports.AbiFunctionSignatureNotFoundError = exports.AbiFunctionOutputsNotFoundError = exports.AbiFunctionNotFoundError = exports.AbiEventSignatureNotFoundError = exports.AbiEventSignatureEmptyTopicsError = exports.AbiEventNotFoundError = exports.AbiErrorSignatureNotFoundError = exports.AbiErrorNotFoundError = exports.AbiErrorInputsNotFoundError = exports.AbiEncodingLengthMismatchError = exports.AbiEncodingArrayLengthMismatchError = exports.AbiDecodingZeroDataError = exports.AbiDecodingDataSizeInvalidError = exports.AbiConstructorParamsNotFoundError = exports.AbiConstructorNotFoundError = exports.minInt256 = exports.minInt248 = exports.minInt240 = exports.minInt232 = exports.minInt224 = exports.minInt216 = exports.minInt208 = exports.minInt200 = exports.minInt192 = exports.minInt184 = exports.minInt176 = exports.minInt168 = exports.minInt160 = exports.minInt152 = exports.minInt144 = exports.minInt136 = exports.minInt128 = exports.minInt120 = exports.minInt112 = exports.minInt104 = exports.minInt96 = exports.minInt88 = exports.minInt80 = exports.minInt72 = exports.minInt64 = exports.minInt56 = exports.minInt48 = exports.minInt40 = exports.minInt32 = exports.minInt24 = exports.minInt16 = exports.minInt8 = void 0;
    exports.IntrinsicGasTooLowError = exports.IntrinsicGasTooHighError = exports.InsufficientFundsError = exports.FeeCapTooLowError = exports.FeeCapTooHighError = exports.ExecutionRevertedError = exports.EstimateGasExecutionError = exports.EnsAvatarUriResolutionError = exports.OffsetOutOfBoundsError = exports.InvalidHexValueError = exports.InvalidHexBooleanError = exports.InvalidBytesBooleanError = exports.DataLengthTooShortError = exports.DataLengthTooLongError = exports.InvalidChainIdError = exports.ClientChainNotConfiguredError = exports.ChainDoesNotSupportContract = exports.UserRejectedRequestError = exports.UnsupportedProviderMethodError = exports.UnknownRpcError = exports.UnauthorizedProviderError = exports.SwitchChainError = exports.TransactionRejectedRpcError = exports.RpcError = exports.ResourceUnavailableRpcError = exports.ResourceNotFoundRpcError = exports.ProviderRpcError = exports.ProviderDisconnectedError = exports.ParseRpcError = exports.MethodNotSupportedRpcError = exports.MethodNotFoundRpcError = exports.LimitExceededRpcError = exports.JsonRpcVersionUnsupportedError = exports.InvalidRequestRpcError = exports.InvalidParamsRpcError = exports.InvalidInputRpcError = exports.InternalRpcError = exports.ChainDisconnectedError = exports.MaxFeePerGasTooLowError = exports.Eip1559FeesNotSupportedError = exports.BaseFeeScalarError = exports.RawContractError = exports.ContractFunctionZeroDataError = exports.ContractFunctionRevertedError = exports.ContractFunctionExecutionError = exports.CallExecutionError = exports.BlockNotFoundError = exports.BaseError = exports.InvalidDefinitionTypeError = exports.InvalidArrayError = void 0;
    exports.hashTypedData = exports.getTransactionType = exports.getSerializedTransactionType = exports.getCreateAddress = exports.getCreate2Address = exports.getContractAddress = exports.getAbiItem = exports.rpcTransactionType = exports.formatTransactionRequest = exports.defineTransactionRequest = exports.defineTransactionReceipt = exports.transactionType = exports.formatTransaction = exports.defineTransaction = exports.encodeFunctionResult = exports.encodeFunctionData = exports.encodeEventTopics = exports.encodeErrorResult = exports.encodeDeployData = exports.encodeAbiParameters = exports.decodeFunctionResult = exports.decodeFunctionData = exports.decodeEventLog = exports.decodeErrorResult = exports.decodeDeployData = exports.decodeAbiParameters = exports.formatLog = exports.formatBlock = exports.defineBlock = exports.namehash = exports.labelhash = exports.UrlRequiredError = exports.SizeExceedsPaddingSizeError = exports.WaitForTransactionReceiptTimeoutError = exports.TransactionReceiptNotFoundError = exports.TransactionNotFoundError = exports.TransactionExecutionError = exports.InvalidLegacyVError = exports.InvalidAddressError = exports.WebSocketRequestError = exports.TimeoutError = exports.RpcRequestError = exports.HttpRequestError = exports.FilterTypeNotSupportedError = exports.UnknownNodeError = exports.TransactionTypeNotSupportedError = exports.TipAboveFeeCapError = exports.NonceTooLowError = exports.NonceTooHighError = exports.NonceMaxValueError = void 0;
    exports.getEventSelector = exports.getContractError = exports.getAddress = exports.fromRlp = exports.hexToString = exports.hexToNumber = exports.hexToBool = exports.hexToBigInt = exports.fromHex = exports.formatUnits = exports.formatGwei = exports.formatEther = exports.encodePacked = exports.defineChain = exports.assertCurrentChain = exports.concatHex = exports.concatBytes = exports.concat = exports.offchainLookupSignature = exports.offchainLookupAbiItem = exports.offchainLookup = exports.ccipFetch = exports.fromBytes = exports.bytesToString = exports.bytesToNumber = exports.bytesToBool = exports.bytesToBigint = exports.toHex = exports.stringToHex = exports.numberToHex = exports.bytesToHex = exports.boolToHex = exports.toBytes = exports.stringToBytes = exports.numberToBytes = exports.hexToBytes = exports.boolToBytes = exports.assertTransactionLegacy = exports.assertTransactionEIP2930 = exports.assertTransactionEIP1559 = exports.assertRequest = exports.verifyTypedData = exports.verifyMessage = exports.toRlp = exports.signatureToHex = exports.recoverTypedDataAddress = exports.recoverPublicKey = exports.recoverMessageAddress = exports.recoverAddress = exports.hexToSignature = void 0;
    exports.domainSeparator = exports.validateTypedData = exports.trim = exports.stringify = exports.sliceHex = exports.sliceBytes = exports.slice = exports.size = exports.serializeTransaction = exports.serializeAccessList = exports.parseUnits = exports.parseTransaction = exports.parseGwei = exports.parseEther = exports.padHex = exports.padBytes = exports.pad = exports.keccak256 = exports.isHex = exports.isHash = exports.isBytes = exports.isAddressEqual = exports.isAddress = exports.hashMessage = exports.getFunctionSelector = void 0;
    var abitype_1 = require_cjs();
    Object.defineProperty(exports, "CircularReferenceError", { enumerable: true, get: function() {
      return abitype_1.CircularReferenceError;
    } });
    Object.defineProperty(exports, "InvalidAbiParameterError", { enumerable: true, get: function() {
      return abitype_1.InvalidAbiParameterError;
    } });
    Object.defineProperty(exports, "InvalidAbiParametersError", { enumerable: true, get: function() {
      return abitype_1.InvalidAbiParametersError;
    } });
    Object.defineProperty(exports, "InvalidAbiItemError", { enumerable: true, get: function() {
      return abitype_1.InvalidAbiItemError;
    } });
    Object.defineProperty(exports, "InvalidAbiTypeParameterError", { enumerable: true, get: function() {
      return abitype_1.InvalidAbiTypeParameterError;
    } });
    Object.defineProperty(exports, "InvalidFunctionModifierError", { enumerable: true, get: function() {
      return abitype_1.InvalidFunctionModifierError;
    } });
    Object.defineProperty(exports, "InvalidModifierError", { enumerable: true, get: function() {
      return abitype_1.InvalidModifierError;
    } });
    Object.defineProperty(exports, "InvalidParameterError", { enumerable: true, get: function() {
      return abitype_1.InvalidParameterError;
    } });
    Object.defineProperty(exports, "InvalidParenthesisError", { enumerable: true, get: function() {
      return abitype_1.InvalidParenthesisError;
    } });
    Object.defineProperty(exports, "InvalidSignatureError", { enumerable: true, get: function() {
      return abitype_1.InvalidSignatureError;
    } });
    Object.defineProperty(exports, "InvalidStructSignatureError", { enumerable: true, get: function() {
      return abitype_1.InvalidStructSignatureError;
    } });
    Object.defineProperty(exports, "SolidityProtectedKeywordError", { enumerable: true, get: function() {
      return abitype_1.SolidityProtectedKeywordError;
    } });
    Object.defineProperty(exports, "UnknownTypeError", { enumerable: true, get: function() {
      return abitype_1.UnknownTypeError;
    } });
    Object.defineProperty(exports, "UnknownSignatureError", { enumerable: true, get: function() {
      return abitype_1.UnknownSignatureError;
    } });
    Object.defineProperty(exports, "parseAbi", { enumerable: true, get: function() {
      return abitype_1.parseAbi;
    } });
    Object.defineProperty(exports, "parseAbiItem", { enumerable: true, get: function() {
      return abitype_1.parseAbiItem;
    } });
    Object.defineProperty(exports, "parseAbiParameter", { enumerable: true, get: function() {
      return abitype_1.parseAbiParameter;
    } });
    Object.defineProperty(exports, "parseAbiParameters", { enumerable: true, get: function() {
      return abitype_1.parseAbiParameters;
    } });
    var getContract_js_1 = require_getContract();
    Object.defineProperty(exports, "getContract", { enumerable: true, get: function() {
      return getContract_js_1.getContract;
    } });
    var createClient_js_1 = require_createClient();
    Object.defineProperty(exports, "createClient", { enumerable: true, get: function() {
      return createClient_js_1.createClient;
    } });
    var custom_js_1 = require_custom();
    Object.defineProperty(exports, "custom", { enumerable: true, get: function() {
      return custom_js_1.custom;
    } });
    var fallback_js_1 = require_fallback();
    Object.defineProperty(exports, "fallback", { enumerable: true, get: function() {
      return fallback_js_1.fallback;
    } });
    var http_js_1 = require_http();
    Object.defineProperty(exports, "http", { enumerable: true, get: function() {
      return http_js_1.http;
    } });
    var createPublicClient_js_1 = require_createPublicClient();
    Object.defineProperty(exports, "createPublicClient", { enumerable: true, get: function() {
      return createPublicClient_js_1.createPublicClient;
    } });
    var createTestClient_js_1 = require_createTestClient();
    Object.defineProperty(exports, "createTestClient", { enumerable: true, get: function() {
      return createTestClient_js_1.createTestClient;
    } });
    var public_js_1 = require_public();
    Object.defineProperty(exports, "publicActions", { enumerable: true, get: function() {
      return public_js_1.publicActions;
    } });
    var test_js_1 = require_test();
    Object.defineProperty(exports, "testActions", { enumerable: true, get: function() {
      return test_js_1.testActions;
    } });
    var wallet_js_1 = require_wallet();
    Object.defineProperty(exports, "walletActions", { enumerable: true, get: function() {
      return wallet_js_1.walletActions;
    } });
    var createTransport_js_1 = require_createTransport();
    Object.defineProperty(exports, "createTransport", { enumerable: true, get: function() {
      return createTransport_js_1.createTransport;
    } });
    var createWalletClient_js_1 = require_createWalletClient();
    Object.defineProperty(exports, "createWalletClient", { enumerable: true, get: function() {
      return createWalletClient_js_1.createWalletClient;
    } });
    var webSocket_js_1 = require_webSocket();
    Object.defineProperty(exports, "webSocket", { enumerable: true, get: function() {
      return webSocket_js_1.webSocket;
    } });
    var abis_js_1 = require_abis();
    Object.defineProperty(exports, "multicall3Abi", { enumerable: true, get: function() {
      return abis_js_1.multicall3Abi;
    } });
    var address_js_1 = require_address2();
    Object.defineProperty(exports, "zeroAddress", { enumerable: true, get: function() {
      return address_js_1.zeroAddress;
    } });
    var unit_js_1 = require_unit();
    Object.defineProperty(exports, "etherUnits", { enumerable: true, get: function() {
      return unit_js_1.etherUnits;
    } });
    Object.defineProperty(exports, "gweiUnits", { enumerable: true, get: function() {
      return unit_js_1.gweiUnits;
    } });
    Object.defineProperty(exports, "weiUnits", { enumerable: true, get: function() {
      return unit_js_1.weiUnits;
    } });
    var number_js_1 = require_number();
    Object.defineProperty(exports, "maxInt8", { enumerable: true, get: function() {
      return number_js_1.maxInt8;
    } });
    Object.defineProperty(exports, "maxInt16", { enumerable: true, get: function() {
      return number_js_1.maxInt16;
    } });
    Object.defineProperty(exports, "maxInt24", { enumerable: true, get: function() {
      return number_js_1.maxInt24;
    } });
    Object.defineProperty(exports, "maxInt32", { enumerable: true, get: function() {
      return number_js_1.maxInt32;
    } });
    Object.defineProperty(exports, "maxInt40", { enumerable: true, get: function() {
      return number_js_1.maxInt40;
    } });
    Object.defineProperty(exports, "maxInt48", { enumerable: true, get: function() {
      return number_js_1.maxInt48;
    } });
    Object.defineProperty(exports, "maxInt56", { enumerable: true, get: function() {
      return number_js_1.maxInt56;
    } });
    Object.defineProperty(exports, "maxInt64", { enumerable: true, get: function() {
      return number_js_1.maxInt64;
    } });
    Object.defineProperty(exports, "maxInt72", { enumerable: true, get: function() {
      return number_js_1.maxInt72;
    } });
    Object.defineProperty(exports, "maxInt80", { enumerable: true, get: function() {
      return number_js_1.maxInt80;
    } });
    Object.defineProperty(exports, "maxInt88", { enumerable: true, get: function() {
      return number_js_1.maxInt88;
    } });
    Object.defineProperty(exports, "maxInt96", { enumerable: true, get: function() {
      return number_js_1.maxInt96;
    } });
    Object.defineProperty(exports, "maxInt104", { enumerable: true, get: function() {
      return number_js_1.maxInt104;
    } });
    Object.defineProperty(exports, "maxInt112", { enumerable: true, get: function() {
      return number_js_1.maxInt112;
    } });
    Object.defineProperty(exports, "maxInt120", { enumerable: true, get: function() {
      return number_js_1.maxInt120;
    } });
    Object.defineProperty(exports, "maxInt128", { enumerable: true, get: function() {
      return number_js_1.maxInt128;
    } });
    Object.defineProperty(exports, "maxInt136", { enumerable: true, get: function() {
      return number_js_1.maxInt136;
    } });
    Object.defineProperty(exports, "maxInt144", { enumerable: true, get: function() {
      return number_js_1.maxInt144;
    } });
    Object.defineProperty(exports, "maxInt152", { enumerable: true, get: function() {
      return number_js_1.maxInt152;
    } });
    Object.defineProperty(exports, "maxInt160", { enumerable: true, get: function() {
      return number_js_1.maxInt160;
    } });
    Object.defineProperty(exports, "maxInt168", { enumerable: true, get: function() {
      return number_js_1.maxInt168;
    } });
    Object.defineProperty(exports, "maxInt176", { enumerable: true, get: function() {
      return number_js_1.maxInt176;
    } });
    Object.defineProperty(exports, "maxInt184", { enumerable: true, get: function() {
      return number_js_1.maxInt184;
    } });
    Object.defineProperty(exports, "maxInt192", { enumerable: true, get: function() {
      return number_js_1.maxInt192;
    } });
    Object.defineProperty(exports, "maxInt200", { enumerable: true, get: function() {
      return number_js_1.maxInt200;
    } });
    Object.defineProperty(exports, "maxInt208", { enumerable: true, get: function() {
      return number_js_1.maxInt208;
    } });
    Object.defineProperty(exports, "maxInt216", { enumerable: true, get: function() {
      return number_js_1.maxInt216;
    } });
    Object.defineProperty(exports, "maxInt224", { enumerable: true, get: function() {
      return number_js_1.maxInt224;
    } });
    Object.defineProperty(exports, "maxInt232", { enumerable: true, get: function() {
      return number_js_1.maxInt232;
    } });
    Object.defineProperty(exports, "maxInt240", { enumerable: true, get: function() {
      return number_js_1.maxInt240;
    } });
    Object.defineProperty(exports, "maxInt248", { enumerable: true, get: function() {
      return number_js_1.maxInt248;
    } });
    Object.defineProperty(exports, "maxInt256", { enumerable: true, get: function() {
      return number_js_1.maxInt256;
    } });
    Object.defineProperty(exports, "maxUint8", { enumerable: true, get: function() {
      return number_js_1.maxUint8;
    } });
    Object.defineProperty(exports, "maxUint16", { enumerable: true, get: function() {
      return number_js_1.maxUint16;
    } });
    Object.defineProperty(exports, "maxUint24", { enumerable: true, get: function() {
      return number_js_1.maxUint24;
    } });
    Object.defineProperty(exports, "maxUint32", { enumerable: true, get: function() {
      return number_js_1.maxUint32;
    } });
    Object.defineProperty(exports, "maxUint40", { enumerable: true, get: function() {
      return number_js_1.maxUint40;
    } });
    Object.defineProperty(exports, "maxUint48", { enumerable: true, get: function() {
      return number_js_1.maxUint48;
    } });
    Object.defineProperty(exports, "maxUint56", { enumerable: true, get: function() {
      return number_js_1.maxUint56;
    } });
    Object.defineProperty(exports, "maxUint64", { enumerable: true, get: function() {
      return number_js_1.maxUint64;
    } });
    Object.defineProperty(exports, "maxUint72", { enumerable: true, get: function() {
      return number_js_1.maxUint72;
    } });
    Object.defineProperty(exports, "maxUint80", { enumerable: true, get: function() {
      return number_js_1.maxUint80;
    } });
    Object.defineProperty(exports, "maxUint88", { enumerable: true, get: function() {
      return number_js_1.maxUint88;
    } });
    Object.defineProperty(exports, "maxUint96", { enumerable: true, get: function() {
      return number_js_1.maxUint96;
    } });
    Object.defineProperty(exports, "maxUint104", { enumerable: true, get: function() {
      return number_js_1.maxUint104;
    } });
    Object.defineProperty(exports, "maxUint112", { enumerable: true, get: function() {
      return number_js_1.maxUint112;
    } });
    Object.defineProperty(exports, "maxUint120", { enumerable: true, get: function() {
      return number_js_1.maxUint120;
    } });
    Object.defineProperty(exports, "maxUint128", { enumerable: true, get: function() {
      return number_js_1.maxUint128;
    } });
    Object.defineProperty(exports, "maxUint136", { enumerable: true, get: function() {
      return number_js_1.maxUint136;
    } });
    Object.defineProperty(exports, "maxUint144", { enumerable: true, get: function() {
      return number_js_1.maxUint144;
    } });
    Object.defineProperty(exports, "maxUint152", { enumerable: true, get: function() {
      return number_js_1.maxUint152;
    } });
    Object.defineProperty(exports, "maxUint160", { enumerable: true, get: function() {
      return number_js_1.maxUint160;
    } });
    Object.defineProperty(exports, "maxUint168", { enumerable: true, get: function() {
      return number_js_1.maxUint168;
    } });
    Object.defineProperty(exports, "maxUint176", { enumerable: true, get: function() {
      return number_js_1.maxUint176;
    } });
    Object.defineProperty(exports, "maxUint184", { enumerable: true, get: function() {
      return number_js_1.maxUint184;
    } });
    Object.defineProperty(exports, "maxUint192", { enumerable: true, get: function() {
      return number_js_1.maxUint192;
    } });
    Object.defineProperty(exports, "maxUint200", { enumerable: true, get: function() {
      return number_js_1.maxUint200;
    } });
    Object.defineProperty(exports, "maxUint208", { enumerable: true, get: function() {
      return number_js_1.maxUint208;
    } });
    Object.defineProperty(exports, "maxUint216", { enumerable: true, get: function() {
      return number_js_1.maxUint216;
    } });
    Object.defineProperty(exports, "maxUint224", { enumerable: true, get: function() {
      return number_js_1.maxUint224;
    } });
    Object.defineProperty(exports, "maxUint232", { enumerable: true, get: function() {
      return number_js_1.maxUint232;
    } });
    Object.defineProperty(exports, "maxUint240", { enumerable: true, get: function() {
      return number_js_1.maxUint240;
    } });
    Object.defineProperty(exports, "maxUint248", { enumerable: true, get: function() {
      return number_js_1.maxUint248;
    } });
    Object.defineProperty(exports, "maxUint256", { enumerable: true, get: function() {
      return number_js_1.maxUint256;
    } });
    Object.defineProperty(exports, "minInt8", { enumerable: true, get: function() {
      return number_js_1.minInt8;
    } });
    Object.defineProperty(exports, "minInt16", { enumerable: true, get: function() {
      return number_js_1.minInt16;
    } });
    Object.defineProperty(exports, "minInt24", { enumerable: true, get: function() {
      return number_js_1.minInt24;
    } });
    Object.defineProperty(exports, "minInt32", { enumerable: true, get: function() {
      return number_js_1.minInt32;
    } });
    Object.defineProperty(exports, "minInt40", { enumerable: true, get: function() {
      return number_js_1.minInt40;
    } });
    Object.defineProperty(exports, "minInt48", { enumerable: true, get: function() {
      return number_js_1.minInt48;
    } });
    Object.defineProperty(exports, "minInt56", { enumerable: true, get: function() {
      return number_js_1.minInt56;
    } });
    Object.defineProperty(exports, "minInt64", { enumerable: true, get: function() {
      return number_js_1.minInt64;
    } });
    Object.defineProperty(exports, "minInt72", { enumerable: true, get: function() {
      return number_js_1.minInt72;
    } });
    Object.defineProperty(exports, "minInt80", { enumerable: true, get: function() {
      return number_js_1.minInt80;
    } });
    Object.defineProperty(exports, "minInt88", { enumerable: true, get: function() {
      return number_js_1.minInt88;
    } });
    Object.defineProperty(exports, "minInt96", { enumerable: true, get: function() {
      return number_js_1.minInt96;
    } });
    Object.defineProperty(exports, "minInt104", { enumerable: true, get: function() {
      return number_js_1.minInt104;
    } });
    Object.defineProperty(exports, "minInt112", { enumerable: true, get: function() {
      return number_js_1.minInt112;
    } });
    Object.defineProperty(exports, "minInt120", { enumerable: true, get: function() {
      return number_js_1.minInt120;
    } });
    Object.defineProperty(exports, "minInt128", { enumerable: true, get: function() {
      return number_js_1.minInt128;
    } });
    Object.defineProperty(exports, "minInt136", { enumerable: true, get: function() {
      return number_js_1.minInt136;
    } });
    Object.defineProperty(exports, "minInt144", { enumerable: true, get: function() {
      return number_js_1.minInt144;
    } });
    Object.defineProperty(exports, "minInt152", { enumerable: true, get: function() {
      return number_js_1.minInt152;
    } });
    Object.defineProperty(exports, "minInt160", { enumerable: true, get: function() {
      return number_js_1.minInt160;
    } });
    Object.defineProperty(exports, "minInt168", { enumerable: true, get: function() {
      return number_js_1.minInt168;
    } });
    Object.defineProperty(exports, "minInt176", { enumerable: true, get: function() {
      return number_js_1.minInt176;
    } });
    Object.defineProperty(exports, "minInt184", { enumerable: true, get: function() {
      return number_js_1.minInt184;
    } });
    Object.defineProperty(exports, "minInt192", { enumerable: true, get: function() {
      return number_js_1.minInt192;
    } });
    Object.defineProperty(exports, "minInt200", { enumerable: true, get: function() {
      return number_js_1.minInt200;
    } });
    Object.defineProperty(exports, "minInt208", { enumerable: true, get: function() {
      return number_js_1.minInt208;
    } });
    Object.defineProperty(exports, "minInt216", { enumerable: true, get: function() {
      return number_js_1.minInt216;
    } });
    Object.defineProperty(exports, "minInt224", { enumerable: true, get: function() {
      return number_js_1.minInt224;
    } });
    Object.defineProperty(exports, "minInt232", { enumerable: true, get: function() {
      return number_js_1.minInt232;
    } });
    Object.defineProperty(exports, "minInt240", { enumerable: true, get: function() {
      return number_js_1.minInt240;
    } });
    Object.defineProperty(exports, "minInt248", { enumerable: true, get: function() {
      return number_js_1.minInt248;
    } });
    Object.defineProperty(exports, "minInt256", { enumerable: true, get: function() {
      return number_js_1.minInt256;
    } });
    var abi_js_1 = require_abi();
    Object.defineProperty(exports, "AbiConstructorNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiConstructorNotFoundError;
    } });
    Object.defineProperty(exports, "AbiConstructorParamsNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiConstructorParamsNotFoundError;
    } });
    Object.defineProperty(exports, "AbiDecodingDataSizeInvalidError", { enumerable: true, get: function() {
      return abi_js_1.AbiDecodingDataSizeInvalidError;
    } });
    Object.defineProperty(exports, "AbiDecodingZeroDataError", { enumerable: true, get: function() {
      return abi_js_1.AbiDecodingZeroDataError;
    } });
    Object.defineProperty(exports, "AbiEncodingArrayLengthMismatchError", { enumerable: true, get: function() {
      return abi_js_1.AbiEncodingArrayLengthMismatchError;
    } });
    Object.defineProperty(exports, "AbiEncodingLengthMismatchError", { enumerable: true, get: function() {
      return abi_js_1.AbiEncodingLengthMismatchError;
    } });
    Object.defineProperty(exports, "AbiErrorInputsNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiErrorInputsNotFoundError;
    } });
    Object.defineProperty(exports, "AbiErrorNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiErrorNotFoundError;
    } });
    Object.defineProperty(exports, "AbiErrorSignatureNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiErrorSignatureNotFoundError;
    } });
    Object.defineProperty(exports, "AbiEventNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiEventNotFoundError;
    } });
    Object.defineProperty(exports, "AbiEventSignatureEmptyTopicsError", { enumerable: true, get: function() {
      return abi_js_1.AbiEventSignatureEmptyTopicsError;
    } });
    Object.defineProperty(exports, "AbiEventSignatureNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiEventSignatureNotFoundError;
    } });
    Object.defineProperty(exports, "AbiFunctionNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiFunctionNotFoundError;
    } });
    Object.defineProperty(exports, "AbiFunctionOutputsNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiFunctionOutputsNotFoundError;
    } });
    Object.defineProperty(exports, "AbiFunctionSignatureNotFoundError", { enumerable: true, get: function() {
      return abi_js_1.AbiFunctionSignatureNotFoundError;
    } });
    Object.defineProperty(exports, "DecodeLogTopicsMismatch", { enumerable: true, get: function() {
      return abi_js_1.DecodeLogTopicsMismatch;
    } });
    Object.defineProperty(exports, "InvalidAbiDecodingTypeError", { enumerable: true, get: function() {
      return abi_js_1.InvalidAbiDecodingTypeError;
    } });
    Object.defineProperty(exports, "InvalidAbiEncodingTypeError", { enumerable: true, get: function() {
      return abi_js_1.InvalidAbiEncodingTypeError;
    } });
    Object.defineProperty(exports, "InvalidArrayError", { enumerable: true, get: function() {
      return abi_js_1.InvalidArrayError;
    } });
    Object.defineProperty(exports, "InvalidDefinitionTypeError", { enumerable: true, get: function() {
      return abi_js_1.InvalidDefinitionTypeError;
    } });
    var base_js_1 = require_base();
    Object.defineProperty(exports, "BaseError", { enumerable: true, get: function() {
      return base_js_1.BaseError;
    } });
    var block_js_1 = require_block2();
    Object.defineProperty(exports, "BlockNotFoundError", { enumerable: true, get: function() {
      return block_js_1.BlockNotFoundError;
    } });
    var contract_js_1 = require_contract();
    Object.defineProperty(exports, "CallExecutionError", { enumerable: true, get: function() {
      return contract_js_1.CallExecutionError;
    } });
    Object.defineProperty(exports, "ContractFunctionExecutionError", { enumerable: true, get: function() {
      return contract_js_1.ContractFunctionExecutionError;
    } });
    Object.defineProperty(exports, "ContractFunctionRevertedError", { enumerable: true, get: function() {
      return contract_js_1.ContractFunctionRevertedError;
    } });
    Object.defineProperty(exports, "ContractFunctionZeroDataError", { enumerable: true, get: function() {
      return contract_js_1.ContractFunctionZeroDataError;
    } });
    Object.defineProperty(exports, "RawContractError", { enumerable: true, get: function() {
      return contract_js_1.RawContractError;
    } });
    var fee_js_1 = require_fee();
    Object.defineProperty(exports, "BaseFeeScalarError", { enumerable: true, get: function() {
      return fee_js_1.BaseFeeScalarError;
    } });
    Object.defineProperty(exports, "Eip1559FeesNotSupportedError", { enumerable: true, get: function() {
      return fee_js_1.Eip1559FeesNotSupportedError;
    } });
    Object.defineProperty(exports, "MaxFeePerGasTooLowError", { enumerable: true, get: function() {
      return fee_js_1.MaxFeePerGasTooLowError;
    } });
    var rpc_js_1 = require_rpc();
    Object.defineProperty(exports, "ChainDisconnectedError", { enumerable: true, get: function() {
      return rpc_js_1.ChainDisconnectedError;
    } });
    Object.defineProperty(exports, "InternalRpcError", { enumerable: true, get: function() {
      return rpc_js_1.InternalRpcError;
    } });
    Object.defineProperty(exports, "InvalidInputRpcError", { enumerable: true, get: function() {
      return rpc_js_1.InvalidInputRpcError;
    } });
    Object.defineProperty(exports, "InvalidParamsRpcError", { enumerable: true, get: function() {
      return rpc_js_1.InvalidParamsRpcError;
    } });
    Object.defineProperty(exports, "InvalidRequestRpcError", { enumerable: true, get: function() {
      return rpc_js_1.InvalidRequestRpcError;
    } });
    Object.defineProperty(exports, "JsonRpcVersionUnsupportedError", { enumerable: true, get: function() {
      return rpc_js_1.JsonRpcVersionUnsupportedError;
    } });
    Object.defineProperty(exports, "LimitExceededRpcError", { enumerable: true, get: function() {
      return rpc_js_1.LimitExceededRpcError;
    } });
    Object.defineProperty(exports, "MethodNotFoundRpcError", { enumerable: true, get: function() {
      return rpc_js_1.MethodNotFoundRpcError;
    } });
    Object.defineProperty(exports, "MethodNotSupportedRpcError", { enumerable: true, get: function() {
      return rpc_js_1.MethodNotSupportedRpcError;
    } });
    Object.defineProperty(exports, "ParseRpcError", { enumerable: true, get: function() {
      return rpc_js_1.ParseRpcError;
    } });
    Object.defineProperty(exports, "ProviderDisconnectedError", { enumerable: true, get: function() {
      return rpc_js_1.ProviderDisconnectedError;
    } });
    Object.defineProperty(exports, "ProviderRpcError", { enumerable: true, get: function() {
      return rpc_js_1.ProviderRpcError;
    } });
    Object.defineProperty(exports, "ResourceNotFoundRpcError", { enumerable: true, get: function() {
      return rpc_js_1.ResourceNotFoundRpcError;
    } });
    Object.defineProperty(exports, "ResourceUnavailableRpcError", { enumerable: true, get: function() {
      return rpc_js_1.ResourceUnavailableRpcError;
    } });
    Object.defineProperty(exports, "RpcError", { enumerable: true, get: function() {
      return rpc_js_1.RpcError;
    } });
    Object.defineProperty(exports, "TransactionRejectedRpcError", { enumerable: true, get: function() {
      return rpc_js_1.TransactionRejectedRpcError;
    } });
    Object.defineProperty(exports, "SwitchChainError", { enumerable: true, get: function() {
      return rpc_js_1.SwitchChainError;
    } });
    Object.defineProperty(exports, "UnauthorizedProviderError", { enumerable: true, get: function() {
      return rpc_js_1.UnauthorizedProviderError;
    } });
    Object.defineProperty(exports, "UnknownRpcError", { enumerable: true, get: function() {
      return rpc_js_1.UnknownRpcError;
    } });
    Object.defineProperty(exports, "UnsupportedProviderMethodError", { enumerable: true, get: function() {
      return rpc_js_1.UnsupportedProviderMethodError;
    } });
    Object.defineProperty(exports, "UserRejectedRequestError", { enumerable: true, get: function() {
      return rpc_js_1.UserRejectedRequestError;
    } });
    var chain_js_1 = require_chain();
    Object.defineProperty(exports, "ChainDoesNotSupportContract", { enumerable: true, get: function() {
      return chain_js_1.ChainDoesNotSupportContract;
    } });
    Object.defineProperty(exports, "ClientChainNotConfiguredError", { enumerable: true, get: function() {
      return chain_js_1.ClientChainNotConfiguredError;
    } });
    Object.defineProperty(exports, "InvalidChainIdError", { enumerable: true, get: function() {
      return chain_js_1.InvalidChainIdError;
    } });
    var encoding_js_1 = require_encoding();
    Object.defineProperty(exports, "DataLengthTooLongError", { enumerable: true, get: function() {
      return encoding_js_1.DataLengthTooLongError;
    } });
    Object.defineProperty(exports, "DataLengthTooShortError", { enumerable: true, get: function() {
      return encoding_js_1.DataLengthTooShortError;
    } });
    Object.defineProperty(exports, "InvalidBytesBooleanError", { enumerable: true, get: function() {
      return encoding_js_1.InvalidBytesBooleanError;
    } });
    Object.defineProperty(exports, "InvalidHexBooleanError", { enumerable: true, get: function() {
      return encoding_js_1.InvalidHexBooleanError;
    } });
    Object.defineProperty(exports, "InvalidHexValueError", { enumerable: true, get: function() {
      return encoding_js_1.InvalidHexValueError;
    } });
    Object.defineProperty(exports, "OffsetOutOfBoundsError", { enumerable: true, get: function() {
      return encoding_js_1.OffsetOutOfBoundsError;
    } });
    var ens_js_1 = require_ens();
    Object.defineProperty(exports, "EnsAvatarUriResolutionError", { enumerable: true, get: function() {
      return ens_js_1.EnsAvatarUriResolutionError;
    } });
    var estimateGas_js_1 = require_estimateGas();
    Object.defineProperty(exports, "EstimateGasExecutionError", { enumerable: true, get: function() {
      return estimateGas_js_1.EstimateGasExecutionError;
    } });
    var node_js_1 = require_node();
    Object.defineProperty(exports, "ExecutionRevertedError", { enumerable: true, get: function() {
      return node_js_1.ExecutionRevertedError;
    } });
    Object.defineProperty(exports, "FeeCapTooHighError", { enumerable: true, get: function() {
      return node_js_1.FeeCapTooHighError;
    } });
    Object.defineProperty(exports, "FeeCapTooLowError", { enumerable: true, get: function() {
      return node_js_1.FeeCapTooLowError;
    } });
    Object.defineProperty(exports, "InsufficientFundsError", { enumerable: true, get: function() {
      return node_js_1.InsufficientFundsError;
    } });
    Object.defineProperty(exports, "IntrinsicGasTooHighError", { enumerable: true, get: function() {
      return node_js_1.IntrinsicGasTooHighError;
    } });
    Object.defineProperty(exports, "IntrinsicGasTooLowError", { enumerable: true, get: function() {
      return node_js_1.IntrinsicGasTooLowError;
    } });
    Object.defineProperty(exports, "NonceMaxValueError", { enumerable: true, get: function() {
      return node_js_1.NonceMaxValueError;
    } });
    Object.defineProperty(exports, "NonceTooHighError", { enumerable: true, get: function() {
      return node_js_1.NonceTooHighError;
    } });
    Object.defineProperty(exports, "NonceTooLowError", { enumerable: true, get: function() {
      return node_js_1.NonceTooLowError;
    } });
    Object.defineProperty(exports, "TipAboveFeeCapError", { enumerable: true, get: function() {
      return node_js_1.TipAboveFeeCapError;
    } });
    Object.defineProperty(exports, "TransactionTypeNotSupportedError", { enumerable: true, get: function() {
      return node_js_1.TransactionTypeNotSupportedError;
    } });
    Object.defineProperty(exports, "UnknownNodeError", { enumerable: true, get: function() {
      return node_js_1.UnknownNodeError;
    } });
    var log_js_1 = require_log2();
    Object.defineProperty(exports, "FilterTypeNotSupportedError", { enumerable: true, get: function() {
      return log_js_1.FilterTypeNotSupportedError;
    } });
    var request_js_1 = require_request();
    Object.defineProperty(exports, "HttpRequestError", { enumerable: true, get: function() {
      return request_js_1.HttpRequestError;
    } });
    Object.defineProperty(exports, "RpcRequestError", { enumerable: true, get: function() {
      return request_js_1.RpcRequestError;
    } });
    Object.defineProperty(exports, "TimeoutError", { enumerable: true, get: function() {
      return request_js_1.TimeoutError;
    } });
    Object.defineProperty(exports, "WebSocketRequestError", { enumerable: true, get: function() {
      return request_js_1.WebSocketRequestError;
    } });
    var address_js_2 = require_address();
    Object.defineProperty(exports, "InvalidAddressError", { enumerable: true, get: function() {
      return address_js_2.InvalidAddressError;
    } });
    var transaction_js_1 = require_transaction2();
    Object.defineProperty(exports, "InvalidLegacyVError", { enumerable: true, get: function() {
      return transaction_js_1.InvalidLegacyVError;
    } });
    Object.defineProperty(exports, "TransactionExecutionError", { enumerable: true, get: function() {
      return transaction_js_1.TransactionExecutionError;
    } });
    Object.defineProperty(exports, "TransactionNotFoundError", { enumerable: true, get: function() {
      return transaction_js_1.TransactionNotFoundError;
    } });
    Object.defineProperty(exports, "TransactionReceiptNotFoundError", { enumerable: true, get: function() {
      return transaction_js_1.TransactionReceiptNotFoundError;
    } });
    Object.defineProperty(exports, "WaitForTransactionReceiptTimeoutError", { enumerable: true, get: function() {
      return transaction_js_1.WaitForTransactionReceiptTimeoutError;
    } });
    var data_js_1 = require_data();
    Object.defineProperty(exports, "SizeExceedsPaddingSizeError", { enumerable: true, get: function() {
      return data_js_1.SizeExceedsPaddingSizeError;
    } });
    var transport_js_1 = require_transport();
    Object.defineProperty(exports, "UrlRequiredError", { enumerable: true, get: function() {
      return transport_js_1.UrlRequiredError;
    } });
    var labelhash_js_1 = require_labelhash();
    Object.defineProperty(exports, "labelhash", { enumerable: true, get: function() {
      return labelhash_js_1.labelhash;
    } });
    var namehash_js_1 = require_namehash();
    Object.defineProperty(exports, "namehash", { enumerable: true, get: function() {
      return namehash_js_1.namehash;
    } });
    var block_js_2 = require_block();
    Object.defineProperty(exports, "defineBlock", { enumerable: true, get: function() {
      return block_js_2.defineBlock;
    } });
    Object.defineProperty(exports, "formatBlock", { enumerable: true, get: function() {
      return block_js_2.formatBlock;
    } });
    var log_js_2 = require_log();
    Object.defineProperty(exports, "formatLog", { enumerable: true, get: function() {
      return log_js_2.formatLog;
    } });
    var decodeAbiParameters_js_1 = require_decodeAbiParameters();
    Object.defineProperty(exports, "decodeAbiParameters", { enumerable: true, get: function() {
      return decodeAbiParameters_js_1.decodeAbiParameters;
    } });
    var decodeDeployData_js_1 = require_decodeDeployData();
    Object.defineProperty(exports, "decodeDeployData", { enumerable: true, get: function() {
      return decodeDeployData_js_1.decodeDeployData;
    } });
    var decodeErrorResult_js_1 = require_decodeErrorResult();
    Object.defineProperty(exports, "decodeErrorResult", { enumerable: true, get: function() {
      return decodeErrorResult_js_1.decodeErrorResult;
    } });
    var decodeEventLog_js_1 = require_decodeEventLog();
    Object.defineProperty(exports, "decodeEventLog", { enumerable: true, get: function() {
      return decodeEventLog_js_1.decodeEventLog;
    } });
    var decodeFunctionData_js_1 = require_decodeFunctionData();
    Object.defineProperty(exports, "decodeFunctionData", { enumerable: true, get: function() {
      return decodeFunctionData_js_1.decodeFunctionData;
    } });
    var decodeFunctionResult_js_1 = require_decodeFunctionResult();
    Object.defineProperty(exports, "decodeFunctionResult", { enumerable: true, get: function() {
      return decodeFunctionResult_js_1.decodeFunctionResult;
    } });
    var encodeAbiParameters_js_1 = require_encodeAbiParameters();
    Object.defineProperty(exports, "encodeAbiParameters", { enumerable: true, get: function() {
      return encodeAbiParameters_js_1.encodeAbiParameters;
    } });
    var encodeDeployData_js_1 = require_encodeDeployData();
    Object.defineProperty(exports, "encodeDeployData", { enumerable: true, get: function() {
      return encodeDeployData_js_1.encodeDeployData;
    } });
    var encodeErrorResult_js_1 = require_encodeErrorResult();
    Object.defineProperty(exports, "encodeErrorResult", { enumerable: true, get: function() {
      return encodeErrorResult_js_1.encodeErrorResult;
    } });
    var encodeEventTopics_js_1 = require_encodeEventTopics();
    Object.defineProperty(exports, "encodeEventTopics", { enumerable: true, get: function() {
      return encodeEventTopics_js_1.encodeEventTopics;
    } });
    var encodeFunctionData_js_1 = require_encodeFunctionData();
    Object.defineProperty(exports, "encodeFunctionData", { enumerable: true, get: function() {
      return encodeFunctionData_js_1.encodeFunctionData;
    } });
    var encodeFunctionResult_js_1 = require_encodeFunctionResult();
    Object.defineProperty(exports, "encodeFunctionResult", { enumerable: true, get: function() {
      return encodeFunctionResult_js_1.encodeFunctionResult;
    } });
    var transaction_js_2 = require_transaction();
    Object.defineProperty(exports, "defineTransaction", { enumerable: true, get: function() {
      return transaction_js_2.defineTransaction;
    } });
    Object.defineProperty(exports, "formatTransaction", { enumerable: true, get: function() {
      return transaction_js_2.formatTransaction;
    } });
    Object.defineProperty(exports, "transactionType", { enumerable: true, get: function() {
      return transaction_js_2.transactionType;
    } });
    var transactionReceipt_js_1 = require_transactionReceipt();
    Object.defineProperty(exports, "defineTransactionReceipt", { enumerable: true, get: function() {
      return transactionReceipt_js_1.defineTransactionReceipt;
    } });
    var transactionRequest_js_1 = require_transactionRequest();
    Object.defineProperty(exports, "defineTransactionRequest", { enumerable: true, get: function() {
      return transactionRequest_js_1.defineTransactionRequest;
    } });
    Object.defineProperty(exports, "formatTransactionRequest", { enumerable: true, get: function() {
      return transactionRequest_js_1.formatTransactionRequest;
    } });
    Object.defineProperty(exports, "rpcTransactionType", { enumerable: true, get: function() {
      return transactionRequest_js_1.rpcTransactionType;
    } });
    var getAbiItem_js_1 = require_getAbiItem();
    Object.defineProperty(exports, "getAbiItem", { enumerable: true, get: function() {
      return getAbiItem_js_1.getAbiItem;
    } });
    var getContractAddress_js_1 = require_getContractAddress();
    Object.defineProperty(exports, "getContractAddress", { enumerable: true, get: function() {
      return getContractAddress_js_1.getContractAddress;
    } });
    Object.defineProperty(exports, "getCreate2Address", { enumerable: true, get: function() {
      return getContractAddress_js_1.getCreate2Address;
    } });
    Object.defineProperty(exports, "getCreateAddress", { enumerable: true, get: function() {
      return getContractAddress_js_1.getCreateAddress;
    } });
    var getSerializedTransactionType_js_1 = require_getSerializedTransactionType();
    Object.defineProperty(exports, "getSerializedTransactionType", { enumerable: true, get: function() {
      return getSerializedTransactionType_js_1.getSerializedTransactionType;
    } });
    var getTransactionType_js_1 = require_getTransactionType();
    Object.defineProperty(exports, "getTransactionType", { enumerable: true, get: function() {
      return getTransactionType_js_1.getTransactionType;
    } });
    var hashTypedData_js_1 = require_hashTypedData();
    Object.defineProperty(exports, "hashTypedData", { enumerable: true, get: function() {
      return hashTypedData_js_1.hashTypedData;
    } });
    var hexToSignature_js_1 = require_hexToSignature();
    Object.defineProperty(exports, "hexToSignature", { enumerable: true, get: function() {
      return hexToSignature_js_1.hexToSignature;
    } });
    var recoverAddress_js_1 = require_recoverAddress();
    Object.defineProperty(exports, "recoverAddress", { enumerable: true, get: function() {
      return recoverAddress_js_1.recoverAddress;
    } });
    var recoverMessageAddress_js_1 = require_recoverMessageAddress();
    Object.defineProperty(exports, "recoverMessageAddress", { enumerable: true, get: function() {
      return recoverMessageAddress_js_1.recoverMessageAddress;
    } });
    var recoverPublicKey_js_1 = require_recoverPublicKey();
    Object.defineProperty(exports, "recoverPublicKey", { enumerable: true, get: function() {
      return recoverPublicKey_js_1.recoverPublicKey;
    } });
    var recoverTypedDataAddress_js_1 = require_recoverTypedDataAddress();
    Object.defineProperty(exports, "recoverTypedDataAddress", { enumerable: true, get: function() {
      return recoverTypedDataAddress_js_1.recoverTypedDataAddress;
    } });
    var signatureToHex_js_1 = require_signatureToHex();
    Object.defineProperty(exports, "signatureToHex", { enumerable: true, get: function() {
      return signatureToHex_js_1.signatureToHex;
    } });
    var toRlp_js_1 = require_toRlp();
    Object.defineProperty(exports, "toRlp", { enumerable: true, get: function() {
      return toRlp_js_1.toRlp;
    } });
    var verifyMessage_js_1 = require_verifyMessage();
    Object.defineProperty(exports, "verifyMessage", { enumerable: true, get: function() {
      return verifyMessage_js_1.verifyMessage;
    } });
    var verifyTypedData_js_1 = require_verifyTypedData();
    Object.defineProperty(exports, "verifyTypedData", { enumerable: true, get: function() {
      return verifyTypedData_js_1.verifyTypedData;
    } });
    var assertRequest_js_1 = require_assertRequest();
    Object.defineProperty(exports, "assertRequest", { enumerable: true, get: function() {
      return assertRequest_js_1.assertRequest;
    } });
    var assertTransaction_js_1 = require_assertTransaction();
    Object.defineProperty(exports, "assertTransactionEIP1559", { enumerable: true, get: function() {
      return assertTransaction_js_1.assertTransactionEIP1559;
    } });
    Object.defineProperty(exports, "assertTransactionEIP2930", { enumerable: true, get: function() {
      return assertTransaction_js_1.assertTransactionEIP2930;
    } });
    Object.defineProperty(exports, "assertTransactionLegacy", { enumerable: true, get: function() {
      return assertTransaction_js_1.assertTransactionLegacy;
    } });
    var toBytes_js_1 = require_toBytes();
    Object.defineProperty(exports, "boolToBytes", { enumerable: true, get: function() {
      return toBytes_js_1.boolToBytes;
    } });
    Object.defineProperty(exports, "hexToBytes", { enumerable: true, get: function() {
      return toBytes_js_1.hexToBytes;
    } });
    Object.defineProperty(exports, "numberToBytes", { enumerable: true, get: function() {
      return toBytes_js_1.numberToBytes;
    } });
    Object.defineProperty(exports, "stringToBytes", { enumerable: true, get: function() {
      return toBytes_js_1.stringToBytes;
    } });
    Object.defineProperty(exports, "toBytes", { enumerable: true, get: function() {
      return toBytes_js_1.toBytes;
    } });
    var toHex_js_1 = require_toHex();
    Object.defineProperty(exports, "boolToHex", { enumerable: true, get: function() {
      return toHex_js_1.boolToHex;
    } });
    Object.defineProperty(exports, "bytesToHex", { enumerable: true, get: function() {
      return toHex_js_1.bytesToHex;
    } });
    Object.defineProperty(exports, "numberToHex", { enumerable: true, get: function() {
      return toHex_js_1.numberToHex;
    } });
    Object.defineProperty(exports, "stringToHex", { enumerable: true, get: function() {
      return toHex_js_1.stringToHex;
    } });
    Object.defineProperty(exports, "toHex", { enumerable: true, get: function() {
      return toHex_js_1.toHex;
    } });
    var fromBytes_js_1 = require_fromBytes();
    Object.defineProperty(exports, "bytesToBigint", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToBigint;
    } });
    Object.defineProperty(exports, "bytesToBool", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToBool;
    } });
    Object.defineProperty(exports, "bytesToNumber", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToNumber;
    } });
    Object.defineProperty(exports, "bytesToString", { enumerable: true, get: function() {
      return fromBytes_js_1.bytesToString;
    } });
    Object.defineProperty(exports, "fromBytes", { enumerable: true, get: function() {
      return fromBytes_js_1.fromBytes;
    } });
    var ccip_js_1 = require_ccip2();
    Object.defineProperty(exports, "ccipFetch", { enumerable: true, get: function() {
      return ccip_js_1.ccipFetch;
    } });
    Object.defineProperty(exports, "offchainLookup", { enumerable: true, get: function() {
      return ccip_js_1.offchainLookup;
    } });
    Object.defineProperty(exports, "offchainLookupAbiItem", { enumerable: true, get: function() {
      return ccip_js_1.offchainLookupAbiItem;
    } });
    Object.defineProperty(exports, "offchainLookupSignature", { enumerable: true, get: function() {
      return ccip_js_1.offchainLookupSignature;
    } });
    var concat_js_1 = require_concat();
    Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
      return concat_js_1.concat;
    } });
    Object.defineProperty(exports, "concatBytes", { enumerable: true, get: function() {
      return concat_js_1.concatBytes;
    } });
    Object.defineProperty(exports, "concatHex", { enumerable: true, get: function() {
      return concat_js_1.concatHex;
    } });
    var chain_js_2 = require_chain2();
    Object.defineProperty(exports, "assertCurrentChain", { enumerable: true, get: function() {
      return chain_js_2.assertCurrentChain;
    } });
    Object.defineProperty(exports, "defineChain", { enumerable: true, get: function() {
      return chain_js_2.defineChain;
    } });
    var encodePacked_js_1 = require_encodePacked();
    Object.defineProperty(exports, "encodePacked", { enumerable: true, get: function() {
      return encodePacked_js_1.encodePacked;
    } });
    var formatEther_js_1 = require_formatEther();
    Object.defineProperty(exports, "formatEther", { enumerable: true, get: function() {
      return formatEther_js_1.formatEther;
    } });
    var formatGwei_js_1 = require_formatGwei();
    Object.defineProperty(exports, "formatGwei", { enumerable: true, get: function() {
      return formatGwei_js_1.formatGwei;
    } });
    var formatUnits_js_1 = require_formatUnits();
    Object.defineProperty(exports, "formatUnits", { enumerable: true, get: function() {
      return formatUnits_js_1.formatUnits;
    } });
    var fromHex_js_1 = require_fromHex();
    Object.defineProperty(exports, "fromHex", { enumerable: true, get: function() {
      return fromHex_js_1.fromHex;
    } });
    Object.defineProperty(exports, "hexToBigInt", { enumerable: true, get: function() {
      return fromHex_js_1.hexToBigInt;
    } });
    Object.defineProperty(exports, "hexToBool", { enumerable: true, get: function() {
      return fromHex_js_1.hexToBool;
    } });
    Object.defineProperty(exports, "hexToNumber", { enumerable: true, get: function() {
      return fromHex_js_1.hexToNumber;
    } });
    Object.defineProperty(exports, "hexToString", { enumerable: true, get: function() {
      return fromHex_js_1.hexToString;
    } });
    var fromRlp_js_1 = require_fromRlp();
    Object.defineProperty(exports, "fromRlp", { enumerable: true, get: function() {
      return fromRlp_js_1.fromRlp;
    } });
    var getAddress_js_1 = require_getAddress();
    Object.defineProperty(exports, "getAddress", { enumerable: true, get: function() {
      return getAddress_js_1.getAddress;
    } });
    var getContractError_js_1 = require_getContractError();
    Object.defineProperty(exports, "getContractError", { enumerable: true, get: function() {
      return getContractError_js_1.getContractError;
    } });
    var getEventSelector_js_1 = require_getEventSelector();
    Object.defineProperty(exports, "getEventSelector", { enumerable: true, get: function() {
      return getEventSelector_js_1.getEventSelector;
    } });
    var getFunctionSelector_js_1 = require_getFunctionSelector();
    Object.defineProperty(exports, "getFunctionSelector", { enumerable: true, get: function() {
      return getFunctionSelector_js_1.getFunctionSelector;
    } });
    var hashMessage_js_1 = require_hashMessage();
    Object.defineProperty(exports, "hashMessage", { enumerable: true, get: function() {
      return hashMessage_js_1.hashMessage;
    } });
    var isAddress_js_1 = require_isAddress();
    Object.defineProperty(exports, "isAddress", { enumerable: true, get: function() {
      return isAddress_js_1.isAddress;
    } });
    var isAddressEqual_js_1 = require_isAddressEqual();
    Object.defineProperty(exports, "isAddressEqual", { enumerable: true, get: function() {
      return isAddressEqual_js_1.isAddressEqual;
    } });
    var isBytes_js_1 = require_isBytes();
    Object.defineProperty(exports, "isBytes", { enumerable: true, get: function() {
      return isBytes_js_1.isBytes;
    } });
    var isHash_js_1 = require_isHash();
    Object.defineProperty(exports, "isHash", { enumerable: true, get: function() {
      return isHash_js_1.isHash;
    } });
    var isHex_js_1 = require_isHex();
    Object.defineProperty(exports, "isHex", { enumerable: true, get: function() {
      return isHex_js_1.isHex;
    } });
    var keccak256_js_1 = require_keccak256();
    Object.defineProperty(exports, "keccak256", { enumerable: true, get: function() {
      return keccak256_js_1.keccak256;
    } });
    var pad_js_1 = require_pad();
    Object.defineProperty(exports, "pad", { enumerable: true, get: function() {
      return pad_js_1.pad;
    } });
    Object.defineProperty(exports, "padBytes", { enumerable: true, get: function() {
      return pad_js_1.padBytes;
    } });
    Object.defineProperty(exports, "padHex", { enumerable: true, get: function() {
      return pad_js_1.padHex;
    } });
    var parseEther_js_1 = require_parseEther();
    Object.defineProperty(exports, "parseEther", { enumerable: true, get: function() {
      return parseEther_js_1.parseEther;
    } });
    var parseGwei_js_1 = require_parseGwei();
    Object.defineProperty(exports, "parseGwei", { enumerable: true, get: function() {
      return parseGwei_js_1.parseGwei;
    } });
    var parseTransaction_js_1 = require_parseTransaction();
    Object.defineProperty(exports, "parseTransaction", { enumerable: true, get: function() {
      return parseTransaction_js_1.parseTransaction;
    } });
    var parseUnits_js_1 = require_parseUnits();
    Object.defineProperty(exports, "parseUnits", { enumerable: true, get: function() {
      return parseUnits_js_1.parseUnits;
    } });
    var serializeAccessList_js_1 = require_serializeAccessList();
    Object.defineProperty(exports, "serializeAccessList", { enumerable: true, get: function() {
      return serializeAccessList_js_1.serializeAccessList;
    } });
    var serializeTransaction_js_1 = require_serializeTransaction();
    Object.defineProperty(exports, "serializeTransaction", { enumerable: true, get: function() {
      return serializeTransaction_js_1.serializeTransaction;
    } });
    var size_js_1 = require_size();
    Object.defineProperty(exports, "size", { enumerable: true, get: function() {
      return size_js_1.size;
    } });
    var slice_js_1 = require_slice();
    Object.defineProperty(exports, "slice", { enumerable: true, get: function() {
      return slice_js_1.slice;
    } });
    Object.defineProperty(exports, "sliceBytes", { enumerable: true, get: function() {
      return slice_js_1.sliceBytes;
    } });
    Object.defineProperty(exports, "sliceHex", { enumerable: true, get: function() {
      return slice_js_1.sliceHex;
    } });
    var stringify_js_1 = require_stringify();
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return stringify_js_1.stringify;
    } });
    var trim_js_1 = require_trim();
    Object.defineProperty(exports, "trim", { enumerable: true, get: function() {
      return trim_js_1.trim;
    } });
    var typedData_js_1 = require_typedData();
    Object.defineProperty(exports, "validateTypedData", { enumerable: true, get: function() {
      return typedData_js_1.validateTypedData;
    } });
    Object.defineProperty(exports, "domainSeparator", { enumerable: true, get: function() {
      return typedData_js_1.domainSeparator;
    } });
  }
});

// node_modules/@wagmi/connectors/dist/chunk-2UFLHRLT.js
var require_chunk_2UFLHRLT = __commonJS({
  "node_modules/@wagmi/connectors/dist/chunk-2UFLHRLT.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _nullishCoalesce(lhs, rhsFn) {
      if (lhs != null) {
        return lhs;
      } else {
        return rhsFn();
      }
    }
    function _optionalChain(ops) {
      let lastAccessLHS = void 0;
      let value = ops[0];
      let i = 1;
      while (i < ops.length) {
        const op = ops[i];
        const fn = ops[i + 1];
        i += 2;
        if ((op === "optionalAccess" || op === "optionalCall") && value == null) {
          return void 0;
        }
        if (op === "access" || op === "optionalAccess") {
          lastAccessLHS = value;
          value = fn(value);
        } else if (op === "call" || op === "optionalCall") {
          value = fn((...args) => value.call(lastAccessLHS, ...args));
          lastAccessLHS = void 0;
        }
      }
      return value;
    }
    var _chunkUGBGYVBHjs = require_chunk_UGBGYVBH();
    var _chunkOQILYQDOjs = require_chunk_OQILYQDO();
    var _chunkW65LBPLTjs = require_chunk_W65LBPLT();
    var _viem = require_cjs2();
    function getInjectedName(ethereum) {
      if (!ethereum)
        return "Injected";
      const getName = (provider) => {
        if (provider.isApexWallet)
          return "Apex Wallet";
        if (provider.isAvalanche)
          return "Core Wallet";
        if (provider.isBackpack)
          return "Backpack";
        if (provider.isBifrost)
          return "Bifrost Wallet";
        if (provider.isBitKeep)
          return "BitKeep";
        if (provider.isBitski)
          return "Bitski";
        if (provider.isBlockWallet)
          return "BlockWallet";
        if (provider.isBraveWallet)
          return "Brave Wallet";
        if (provider.isCoin98)
          return "Coin98 Wallet";
        if (provider.isCoinbaseWallet)
          return "Coinbase Wallet";
        if (provider.isDawn)
          return "Dawn Wallet";
        if (provider.isDefiant)
          return "Defiant";
        if (provider.isDesig)
          return "Desig Wallet";
        if (provider.isEnkrypt)
          return "Enkrypt";
        if (provider.isExodus)
          return "Exodus";
        if (provider.isFordefi)
          return "Fordefi";
        if (provider.isFrame)
          return "Frame";
        if (provider.isFrontier)
          return "Frontier Wallet";
        if (provider.isGamestop)
          return "GameStop Wallet";
        if (provider.isHaqqWallet)
          return "HAQQ Wallet";
        if (provider.isHyperPay)
          return "HyperPay Wallet";
        if (provider.isImToken)
          return "ImToken";
        if (provider.isHaloWallet)
          return "Halo Wallet";
        if (provider.isKuCoinWallet)
          return "KuCoin Wallet";
        if (provider.isMathWallet)
          return "MathWallet";
        if (provider.isNovaWallet)
          return "Nova Wallet";
        if (provider.isOkxWallet || provider.isOKExWallet)
          return "OKX Wallet";
        if (provider.isOneInchIOSWallet || provider.isOneInchAndroidWallet)
          return "1inch Wallet";
        if (provider.isOpera)
          return "Opera";
        if (provider.isPhantom)
          return "Phantom";
        if (provider.isPortal)
          return "Ripio Portal";
        if (provider.isRabby)
          return "Rabby Wallet";
        if (provider.isRainbow)
          return "Rainbow";
        if (provider.isStatus)
          return "Status";
        if (provider.isSubWallet)
          return "SubWallet";
        if (provider.isTalisman)
          return "Talisman";
        if (provider.isTally)
          return "Taho";
        if (provider.isTokenPocket)
          return "TokenPocket";
        if (provider.isTokenary)
          return "Tokenary";
        if (provider.isTrust || provider.isTrustWallet)
          return "Trust Wallet";
        if (provider.isTTWallet)
          return "TTWallet";
        if (provider.isXDEFI)
          return "XDEFI Wallet";
        if (provider.isZeal)
          return "Zeal";
        if (provider.isZerion)
          return "Zerion";
        if (provider.isMetaMask)
          return "MetaMask";
      };
      if (_optionalChain([ethereum, "access", (_) => _.providers, "optionalAccess", (_2) => _2.length])) {
        const nameSet = /* @__PURE__ */ new Set();
        let unknownCount = 1;
        for (const provider of ethereum.providers) {
          let name = getName(provider);
          if (!name) {
            name = `Unknown Wallet #${unknownCount}`;
            unknownCount += 1;
          }
          nameSet.add(name);
        }
        const names = [...nameSet];
        if (names.length)
          return names;
        return _nullishCoalesce(names[0], () => "Injected");
      }
      return _nullishCoalesce(getName(ethereum), () => "Injected");
    }
    var _provider;
    var InjectedConnector = class extends _chunkW65LBPLTjs.Connector {
      constructor({
        chains,
        options: options_
      } = {}) {
        const options = {
          shimDisconnect: true,
          getProvider() {
            if (typeof window === "undefined")
              return;
            const ethereum = window.ethereum;
            if (_optionalChain([ethereum, "optionalAccess", (_3) => _3.providers]))
              return ethereum.providers[0];
            return ethereum;
          },
          ...options_
        };
        super({ chains, options });
        this.id = "injected";
        _chunkW65LBPLTjs.__privateAdd.call(void 0, this, _provider, void 0);
        this.shimDisconnectKey = `${this.id}.shimDisconnect`;
        this.onAccountsChanged = (accounts) => {
          if (accounts.length === 0)
            this.emit("disconnect");
          else
            this.emit("change", {
              account: _viem.getAddress.call(void 0, accounts[0])
            });
        };
        this.onChainChanged = (chainId) => {
          const id = _chunkOQILYQDOjs.normalizeChainId.call(void 0, chainId);
          const unsupported = this.isChainUnsupported(id);
          this.emit("change", { chain: { id, unsupported } });
        };
        this.onDisconnect = async (error) => {
          if (error.code === 1013) {
            const provider2 = await this.getProvider();
            if (provider2) {
              const isAuthorized = await this.getAccount();
              if (isAuthorized)
                return;
            }
          }
          this.emit("disconnect");
          if (this.options.shimDisconnect)
            _optionalChain([this, "access", (_4) => _4.storage, "optionalAccess", (_5) => _5.removeItem, "call", (_6) => _6(this.shimDisconnectKey)]);
        };
        const provider = options.getProvider();
        if (typeof options.name === "string")
          this.name = options.name;
        else if (provider) {
          const detectedName = getInjectedName(provider);
          if (options.name)
            this.name = options.name(detectedName);
          else {
            if (typeof detectedName === "string")
              this.name = detectedName;
            else
              this.name = detectedName[0];
          }
        } else
          this.name = "Injected";
        this.ready = !!provider;
      }
      async connect({ chainId } = {}) {
        try {
          const provider = await this.getProvider();
          if (!provider)
            throw new (0, _chunkUGBGYVBHjs.ConnectorNotFoundError)();
          if (provider.on) {
            provider.on("accountsChanged", this.onAccountsChanged);
            provider.on("chainChanged", this.onChainChanged);
            provider.on("disconnect", this.onDisconnect);
          }
          this.emit("message", { type: "connecting" });
          const accounts = await provider.request({
            method: "eth_requestAccounts"
          });
          const account = _viem.getAddress.call(void 0, accounts[0]);
          let id = await this.getChainId();
          let unsupported = this.isChainUnsupported(id);
          if (chainId && id !== chainId) {
            const chain = await this.switchChain(chainId);
            id = chain.id;
            unsupported = this.isChainUnsupported(id);
          }
          if (this.options.shimDisconnect)
            _optionalChain([this, "access", (_7) => _7.storage, "optionalAccess", (_8) => _8.setItem, "call", (_9) => _9(this.shimDisconnectKey, true)]);
          return { account, chain: { id, unsupported } };
        } catch (error) {
          if (this.isUserRejectedRequestError(error))
            throw new (0, _viem.UserRejectedRequestError)(error);
          if (error.code === -32002)
            throw new (0, _viem.ResourceUnavailableRpcError)(error);
          throw error;
        }
      }
      async disconnect() {
        const provider = await this.getProvider();
        if (!_optionalChain([provider, "optionalAccess", (_10) => _10.removeListener]))
          return;
        provider.removeListener("accountsChanged", this.onAccountsChanged);
        provider.removeListener("chainChanged", this.onChainChanged);
        provider.removeListener("disconnect", this.onDisconnect);
        if (this.options.shimDisconnect)
          _optionalChain([this, "access", (_11) => _11.storage, "optionalAccess", (_12) => _12.removeItem, "call", (_13) => _13(this.shimDisconnectKey)]);
      }
      async getAccount() {
        const provider = await this.getProvider();
        if (!provider)
          throw new (0, _chunkUGBGYVBHjs.ConnectorNotFoundError)();
        const accounts = await provider.request({
          method: "eth_accounts"
        });
        return _viem.getAddress.call(void 0, accounts[0]);
      }
      async getChainId() {
        const provider = await this.getProvider();
        if (!provider)
          throw new (0, _chunkUGBGYVBHjs.ConnectorNotFoundError)();
        return provider.request({ method: "eth_chainId" }).then(_chunkOQILYQDOjs.normalizeChainId);
      }
      async getProvider() {
        const provider = this.options.getProvider();
        if (provider)
          _chunkW65LBPLTjs.__privateSet.call(void 0, this, _provider, provider);
        return _chunkW65LBPLTjs.__privateGet.call(void 0, this, _provider);
      }
      async getWalletClient({
        chainId
      } = {}) {
        const [provider, account] = await Promise.all([
          this.getProvider(),
          this.getAccount()
        ]);
        const chain = this.chains.find((x) => x.id === chainId);
        if (!provider)
          throw new Error("provider is required.");
        return _viem.createWalletClient.call(void 0, {
          account,
          chain,
          transport: _viem.custom.call(void 0, provider)
        });
      }
      async isAuthorized() {
        try {
          if (this.options.shimDisconnect && !_optionalChain([this, "access", (_14) => _14.storage, "optionalAccess", (_15) => _15.getItem, "call", (_16) => _16(this.shimDisconnectKey)]))
            return false;
          const provider = await this.getProvider();
          if (!provider)
            throw new (0, _chunkUGBGYVBHjs.ConnectorNotFoundError)();
          const account = await this.getAccount();
          return !!account;
        } catch (e) {
          return false;
        }
      }
      async switchChain(chainId) {
        const provider = await this.getProvider();
        if (!provider)
          throw new (0, _chunkUGBGYVBHjs.ConnectorNotFoundError)();
        const id = _viem.numberToHex.call(void 0, chainId);
        try {
          await Promise.all([
            provider.request({
              method: "wallet_switchEthereumChain",
              params: [{ chainId: id }]
            }),
            new Promise(
              (res) => this.on("change", ({ chain }) => {
                if (_optionalChain([chain, "optionalAccess", (_17) => _17.id]) === chainId)
                  res();
              })
            )
          ]);
          return _nullishCoalesce(this.chains.find((x) => x.id === chainId), () => ({
            id: chainId,
            name: `Chain ${id}`,
            network: `${id}`,
            nativeCurrency: { name: "Ether", decimals: 18, symbol: "ETH" },
            rpcUrls: { default: { http: [""] }, public: { http: [""] } }
          }));
        } catch (error) {
          const chain = this.chains.find((x) => x.id === chainId);
          if (!chain)
            throw new (0, _chunkUGBGYVBHjs.ChainNotConfiguredForConnectorError)({
              chainId,
              connectorId: this.id
            });
          if (error.code === 4902 || _optionalChain([error, "optionalAccess", (_18) => _18.data, "optionalAccess", (_19) => _19.originalError, "optionalAccess", (_20) => _20.code]) === 4902) {
            try {
              await provider.request({
                method: "wallet_addEthereumChain",
                params: [
                  {
                    chainId: id,
                    chainName: chain.name,
                    nativeCurrency: chain.nativeCurrency,
                    rpcUrls: [_nullishCoalesce(_optionalChain([chain, "access", (_21) => _21.rpcUrls, "access", (_22) => _22.public, "optionalAccess", (_23) => _23.http, "access", (_24) => _24[0]]), () => "")],
                    blockExplorerUrls: this.getBlockExplorerUrls(chain)
                  }
                ]
              });
              const currentChainId = await this.getChainId();
              if (currentChainId !== chainId)
                throw new (0, _viem.UserRejectedRequestError)(
                  new Error("User rejected switch after adding network.")
                );
              return chain;
            } catch (error2) {
              throw new (0, _viem.UserRejectedRequestError)(error2);
            }
          }
          if (this.isUserRejectedRequestError(error))
            throw new (0, _viem.UserRejectedRequestError)(error);
          throw new (0, _viem.SwitchChainError)(error);
        }
      }
      async watchAsset({
        address,
        decimals = 18,
        image,
        symbol
      }) {
        const provider = await this.getProvider();
        if (!provider)
          throw new (0, _chunkUGBGYVBHjs.ConnectorNotFoundError)();
        return provider.request({
          method: "wallet_watchAsset",
          params: {
            type: "ERC20",
            options: {
              address,
              decimals,
              image,
              symbol
            }
          }
        });
      }
      isUserRejectedRequestError(error) {
        return error.code === 4001;
      }
    };
    _provider = /* @__PURE__ */ new WeakMap();
    exports.InjectedConnector = InjectedConnector;
  }
});

// node_modules/@wagmi/connectors/dist/injected.js
var require_injected = __commonJS({
  "node_modules/@wagmi/connectors/dist/injected.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _chunk2UFLHRLTjs = require_chunk_2UFLHRLT();
    require_chunk_UGBGYVBH();
    require_chunk_OQILYQDO();
    require_chunk_W65LBPLT();
    exports.InjectedConnector = _chunk2UFLHRLTjs.InjectedConnector;
  }
});

// node_modules/@wagmi/core/dist/chunk-BVC4KGLQ.js
var require_chunk_BVC4KGLQ = __commonJS({
  "node_modules/@wagmi/core/dist/chunk-BVC4KGLQ.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _connectors = require_dist();
    var _injected = require_injected();
    exports.Connector = _connectors.Connector;
    exports.InjectedConnector = _injected.InjectedConnector;
  }
});

// node_modules/@wagmi/core/dist/chunk-MQXBDTVK.js
var require_chunk_MQXBDTVK = __commonJS({
  "node_modules/@wagmi/core/dist/chunk-MQXBDTVK.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var __accessCheck = (obj, member, msg) => {
      if (!member.has(obj))
        throw TypeError("Cannot " + msg);
    };
    var __privateGet = (obj, member, getter) => {
      __accessCheck(obj, member, "read from private field");
      return getter ? getter.call(obj) : member.get(obj);
    };
    var __privateAdd = (obj, member, value) => {
      if (member.has(obj))
        throw TypeError("Cannot add the same private member more than once");
      member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
    };
    var __privateSet = (obj, member, value, setter) => {
      __accessCheck(obj, member, "write to private field");
      setter ? setter.call(obj, value) : member.set(obj, value);
      return value;
    };
    var __privateMethod = (obj, member, method) => {
      __accessCheck(obj, member, "access private method");
      return method;
    };
    exports.__privateGet = __privateGet;
    exports.__privateAdd = __privateAdd;
    exports.__privateSet = __privateSet;
    exports.__privateMethod = __privateMethod;
  }
});

// node_modules/zustand/esm/middleware.js
var middleware_exports = {};
__export(middleware_exports, {
  combine: () => combine,
  createJSONStorage: () => createJSONStorage,
  devtools: () => devtools,
  persist: () => persist,
  redux: () => redux,
  subscribeWithSelector: () => subscribeWithSelector
});
function createJSONStorage(getStorage, options) {
  let storage;
  try {
    storage = getStorage();
  } catch (e) {
    return;
  }
  const persistStorage = {
    getItem: (name) => {
      var _a;
      const parse = (str2) => {
        if (str2 === null) {
          return null;
        }
        return JSON.parse(str2, options == null ? void 0 : options.reviver);
      };
      const str = (_a = storage.getItem(name)) != null ? _a : null;
      if (str instanceof Promise) {
        return str.then(parse);
      }
      return parse(str);
    },
    setItem: (name, newValue) => storage.setItem(
      name,
      JSON.stringify(newValue, options == null ? void 0 : options.replacer)
    ),
    removeItem: (name) => storage.removeItem(name)
  };
  return persistStorage;
}
var reduxImpl, redux, trackedConnections, getTrackedConnectionState, extractConnectionInformation, devtoolsImpl, devtools, parseJsonThen, subscribeWithSelectorImpl, subscribeWithSelector, combine, toThenable, oldImpl, newImpl, persistImpl, persist;
var init_middleware = __esm({
  "node_modules/zustand/esm/middleware.js"() {
    reduxImpl = (reducer, initial) => (set, _get, api) => {
      api.dispatch = (action) => {
        set((state) => reducer(state, action), false, action);
        return action;
      };
      api.dispatchFromDevtools = true;
      return { dispatch: (...a) => api.dispatch(...a), ...initial };
    };
    redux = reduxImpl;
    trackedConnections = /* @__PURE__ */ new Map();
    getTrackedConnectionState = (name) => {
      const api = trackedConnections.get(name);
      if (!api)
        return {};
      return Object.fromEntries(
        Object.entries(api.stores).map(([key, api2]) => [key, api2.getState()])
      );
    };
    extractConnectionInformation = (store, extensionConnector, options) => {
      if (store === void 0) {
        return {
          type: "untracked",
          connection: extensionConnector.connect(options)
        };
      }
      const existingConnection = trackedConnections.get(options.name);
      if (existingConnection) {
        return { type: "tracked", store, ...existingConnection };
      }
      const newConnection = {
        connection: extensionConnector.connect(options),
        stores: {}
      };
      trackedConnections.set(options.name, newConnection);
      return { type: "tracked", store, ...newConnection };
    };
    devtoolsImpl = (fn, devtoolsOptions = {}) => (set, get, api) => {
      const { enabled, anonymousActionType, store, ...options } = devtoolsOptions;
      let extensionConnector;
      try {
        extensionConnector = (enabled != null ? enabled : true) && window.__REDUX_DEVTOOLS_EXTENSION__;
      } catch (e) {
      }
      if (!extensionConnector) {
        if (enabled) {
          console.warn(
            "[zustand devtools middleware] Please install/enable Redux devtools extension"
          );
        }
        return fn(set, get, api);
      }
      const { connection, ...connectionInformation } = extractConnectionInformation(store, extensionConnector, options);
      let isRecording = true;
      api.setState = (state, replace, nameOrAction) => {
        const r = set(state, replace);
        if (!isRecording)
          return r;
        const action = nameOrAction === void 0 ? { type: anonymousActionType || "anonymous" } : typeof nameOrAction === "string" ? { type: nameOrAction } : nameOrAction;
        if (store === void 0) {
          connection == null ? void 0 : connection.send(action, get());
          return r;
        }
        connection == null ? void 0 : connection.send(
          {
            ...action,
            type: `${store}/${action.type}`
          },
          {
            ...getTrackedConnectionState(options.name),
            [store]: api.getState()
          }
        );
        return r;
      };
      const setStateFromDevtools = (...a) => {
        const originalIsRecording = isRecording;
        isRecording = false;
        set(...a);
        isRecording = originalIsRecording;
      };
      const initialState = fn(api.setState, get, api);
      if (connectionInformation.type === "untracked") {
        connection == null ? void 0 : connection.init(initialState);
      } else {
        connectionInformation.stores[connectionInformation.store] = api;
        connection == null ? void 0 : connection.init(
          Object.fromEntries(
            Object.entries(connectionInformation.stores).map(([key, store2]) => [
              key,
              key === connectionInformation.store ? initialState : store2.getState()
            ])
          )
        );
      }
      if (api.dispatchFromDevtools && typeof api.dispatch === "function") {
        let didWarnAboutReservedActionType = false;
        const originalDispatch = api.dispatch;
        api.dispatch = (...a) => {
          if (a[0].type === "__setState" && !didWarnAboutReservedActionType) {
            console.warn(
              '[zustand devtools middleware] "__setState" action type is reserved to set state from the devtools. Avoid using it.'
            );
            didWarnAboutReservedActionType = true;
          }
          originalDispatch(...a);
        };
      }
      connection.subscribe((message) => {
        var _a;
        switch (message.type) {
          case "ACTION":
            if (typeof message.payload !== "string") {
              console.error(
                "[zustand devtools middleware] Unsupported action format"
              );
              return;
            }
            return parseJsonThen(
              message.payload,
              (action) => {
                if (action.type === "__setState") {
                  if (store === void 0) {
                    setStateFromDevtools(action.state);
                    return;
                  }
                  if (Object.keys(action.state).length !== 1) {
                    console.error(
                      `
                    [zustand devtools middleware] Unsupported __setState action format. 
                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),
                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }
                    `
                    );
                  }
                  const stateFromDevtools = action.state[store];
                  if (stateFromDevtools === void 0 || stateFromDevtools === null) {
                    return;
                  }
                  if (JSON.stringify(api.getState()) !== JSON.stringify(stateFromDevtools)) {
                    setStateFromDevtools(stateFromDevtools);
                  }
                  return;
                }
                if (!api.dispatchFromDevtools)
                  return;
                if (typeof api.dispatch !== "function")
                  return;
                api.dispatch(action);
              }
            );
          case "DISPATCH":
            switch (message.payload.type) {
              case "RESET":
                setStateFromDevtools(initialState);
                if (store === void 0) {
                  return connection == null ? void 0 : connection.init(api.getState());
                }
                return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
              case "COMMIT":
                if (store === void 0) {
                  connection == null ? void 0 : connection.init(api.getState());
                  return;
                }
                return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
              case "ROLLBACK":
                return parseJsonThen(message.state, (state) => {
                  if (store === void 0) {
                    setStateFromDevtools(state);
                    connection == null ? void 0 : connection.init(api.getState());
                    return;
                  }
                  setStateFromDevtools(state[store]);
                  connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
                });
              case "JUMP_TO_STATE":
              case "JUMP_TO_ACTION":
                return parseJsonThen(message.state, (state) => {
                  if (store === void 0) {
                    setStateFromDevtools(state);
                    return;
                  }
                  if (JSON.stringify(api.getState()) !== JSON.stringify(state[store])) {
                    setStateFromDevtools(state[store]);
                  }
                });
              case "IMPORT_STATE": {
                const { nextLiftedState } = message.payload;
                const lastComputedState = (_a = nextLiftedState.computedStates.slice(-1)[0]) == null ? void 0 : _a.state;
                if (!lastComputedState)
                  return;
                if (store === void 0) {
                  setStateFromDevtools(lastComputedState);
                } else {
                  setStateFromDevtools(lastComputedState[store]);
                }
                connection == null ? void 0 : connection.send(
                  null,
                  // FIXME no-any
                  nextLiftedState
                );
                return;
              }
              case "PAUSE_RECORDING":
                return isRecording = !isRecording;
            }
            return;
        }
      });
      return initialState;
    };
    devtools = devtoolsImpl;
    parseJsonThen = (stringified, f) => {
      let parsed;
      try {
        parsed = JSON.parse(stringified);
      } catch (e) {
        console.error(
          "[zustand devtools middleware] Could not parse the received json",
          e
        );
      }
      if (parsed !== void 0)
        f(parsed);
    };
    subscribeWithSelectorImpl = (fn) => (set, get, api) => {
      const origSubscribe = api.subscribe;
      api.subscribe = (selector, optListener, options) => {
        let listener = selector;
        if (optListener) {
          const equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;
          let currentSlice = selector(api.getState());
          listener = (state) => {
            const nextSlice = selector(state);
            if (!equalityFn(currentSlice, nextSlice)) {
              const previousSlice = currentSlice;
              optListener(currentSlice = nextSlice, previousSlice);
            }
          };
          if (options == null ? void 0 : options.fireImmediately) {
            optListener(currentSlice, currentSlice);
          }
        }
        return origSubscribe(listener);
      };
      const initialState = fn(set, get, api);
      return initialState;
    };
    subscribeWithSelector = subscribeWithSelectorImpl;
    combine = (initialState, create) => (...a) => Object.assign({}, initialState, create(...a));
    toThenable = (fn) => (input) => {
      try {
        const result = fn(input);
        if (result instanceof Promise) {
          return result;
        }
        return {
          then(onFulfilled) {
            return toThenable(onFulfilled)(result);
          },
          catch(_onRejected) {
            return this;
          }
        };
      } catch (e) {
        return {
          then(_onFulfilled) {
            return this;
          },
          catch(onRejected) {
            return toThenable(onRejected)(e);
          }
        };
      }
    };
    oldImpl = (config, baseOptions) => (set, get, api) => {
      let options = {
        getStorage: () => localStorage,
        serialize: JSON.stringify,
        deserialize: JSON.parse,
        partialize: (state) => state,
        version: 0,
        merge: (persistedState, currentState) => ({
          ...currentState,
          ...persistedState
        }),
        ...baseOptions
      };
      let hasHydrated = false;
      const hydrationListeners = /* @__PURE__ */ new Set();
      const finishHydrationListeners = /* @__PURE__ */ new Set();
      let storage;
      try {
        storage = options.getStorage();
      } catch (e) {
      }
      if (!storage) {
        return config(
          (...args) => {
            console.warn(
              `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`
            );
            set(...args);
          },
          get,
          api
        );
      }
      const thenableSerialize = toThenable(options.serialize);
      const setItem = () => {
        const state = options.partialize({ ...get() });
        let errorInSync;
        const thenable = thenableSerialize({ state, version: options.version }).then(
          (serializedValue) => storage.setItem(options.name, serializedValue)
        ).catch((e) => {
          errorInSync = e;
        });
        if (errorInSync) {
          throw errorInSync;
        }
        return thenable;
      };
      const savedSetState = api.setState;
      api.setState = (state, replace) => {
        savedSetState(state, replace);
        void setItem();
      };
      const configResult = config(
        (...args) => {
          set(...args);
          void setItem();
        },
        get,
        api
      );
      let stateFromStorage;
      const hydrate = () => {
        var _a;
        if (!storage)
          return;
        hasHydrated = false;
        hydrationListeners.forEach((cb) => cb(get()));
        const postRehydrationCallback = ((_a = options.onRehydrateStorage) == null ? void 0 : _a.call(options, get())) || void 0;
        return toThenable(storage.getItem.bind(storage))(options.name).then((storageValue) => {
          if (storageValue) {
            return options.deserialize(storageValue);
          }
        }).then((deserializedStorageValue) => {
          if (deserializedStorageValue) {
            if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
              if (options.migrate) {
                return options.migrate(
                  deserializedStorageValue.state,
                  deserializedStorageValue.version
                );
              }
              console.error(
                `State loaded from storage couldn't be migrated since no migrate function was provided`
              );
            } else {
              return deserializedStorageValue.state;
            }
          }
        }).then((migratedState) => {
          var _a2;
          stateFromStorage = options.merge(
            migratedState,
            (_a2 = get()) != null ? _a2 : configResult
          );
          set(stateFromStorage, true);
          return setItem();
        }).then(() => {
          postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
          hasHydrated = true;
          finishHydrationListeners.forEach((cb) => cb(stateFromStorage));
        }).catch((e) => {
          postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);
        });
      };
      api.persist = {
        setOptions: (newOptions) => {
          options = {
            ...options,
            ...newOptions
          };
          if (newOptions.getStorage) {
            storage = newOptions.getStorage();
          }
        },
        clearStorage: () => {
          storage == null ? void 0 : storage.removeItem(options.name);
        },
        getOptions: () => options,
        rehydrate: () => hydrate(),
        hasHydrated: () => hasHydrated,
        onHydrate: (cb) => {
          hydrationListeners.add(cb);
          return () => {
            hydrationListeners.delete(cb);
          };
        },
        onFinishHydration: (cb) => {
          finishHydrationListeners.add(cb);
          return () => {
            finishHydrationListeners.delete(cb);
          };
        }
      };
      hydrate();
      return stateFromStorage || configResult;
    };
    newImpl = (config, baseOptions) => (set, get, api) => {
      let options = {
        storage: createJSONStorage(() => localStorage),
        partialize: (state) => state,
        version: 0,
        merge: (persistedState, currentState) => ({
          ...currentState,
          ...persistedState
        }),
        ...baseOptions
      };
      let hasHydrated = false;
      const hydrationListeners = /* @__PURE__ */ new Set();
      const finishHydrationListeners = /* @__PURE__ */ new Set();
      let storage = options.storage;
      if (!storage) {
        return config(
          (...args) => {
            console.warn(
              `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`
            );
            set(...args);
          },
          get,
          api
        );
      }
      const setItem = () => {
        const state = options.partialize({ ...get() });
        return storage.setItem(options.name, {
          state,
          version: options.version
        });
      };
      const savedSetState = api.setState;
      api.setState = (state, replace) => {
        savedSetState(state, replace);
        void setItem();
      };
      const configResult = config(
        (...args) => {
          set(...args);
          void setItem();
        },
        get,
        api
      );
      let stateFromStorage;
      const hydrate = () => {
        var _a, _b;
        if (!storage)
          return;
        hasHydrated = false;
        hydrationListeners.forEach((cb) => {
          var _a2;
          return cb((_a2 = get()) != null ? _a2 : configResult);
        });
        const postRehydrationCallback = ((_b = options.onRehydrateStorage) == null ? void 0 : _b.call(options, (_a = get()) != null ? _a : configResult)) || void 0;
        return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {
          if (deserializedStorageValue) {
            if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
              if (options.migrate) {
                return options.migrate(
                  deserializedStorageValue.state,
                  deserializedStorageValue.version
                );
              }
              console.error(
                `State loaded from storage couldn't be migrated since no migrate function was provided`
              );
            } else {
              return deserializedStorageValue.state;
            }
          }
        }).then((migratedState) => {
          var _a2;
          stateFromStorage = options.merge(
            migratedState,
            (_a2 = get()) != null ? _a2 : configResult
          );
          set(stateFromStorage, true);
          return setItem();
        }).then(() => {
          postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
          stateFromStorage = get();
          hasHydrated = true;
          finishHydrationListeners.forEach((cb) => cb(stateFromStorage));
        }).catch((e) => {
          postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);
        });
      };
      api.persist = {
        setOptions: (newOptions) => {
          options = {
            ...options,
            ...newOptions
          };
          if (newOptions.storage) {
            storage = newOptions.storage;
          }
        },
        clearStorage: () => {
          storage == null ? void 0 : storage.removeItem(options.name);
        },
        getOptions: () => options,
        rehydrate: () => hydrate(),
        hasHydrated: () => hasHydrated,
        onHydrate: (cb) => {
          hydrationListeners.add(cb);
          return () => {
            hydrationListeners.delete(cb);
          };
        },
        onFinishHydration: (cb) => {
          finishHydrationListeners.add(cb);
          return () => {
            finishHydrationListeners.delete(cb);
          };
        }
      };
      if (!options.skipHydration) {
        hydrate();
      }
      return stateFromStorage || configResult;
    };
    persistImpl = (config, baseOptions) => {
      if ("getStorage" in baseOptions || "serialize" in baseOptions || "deserialize" in baseOptions) {
        if (true) {
          console.warn(
            "[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."
          );
        }
        return oldImpl(config, baseOptions);
      }
      return newImpl(config, baseOptions);
    };
    persist = persistImpl;
  }
});

// node_modules/zustand/esm/vanilla.js
var vanilla_exports = {};
__export(vanilla_exports, {
  createStore: () => createStore,
  default: () => vanilla
});
var createStoreImpl, createStore, vanilla;
var init_vanilla = __esm({
  "node_modules/zustand/esm/vanilla.js"() {
    createStoreImpl = (createState) => {
      let state;
      const listeners = /* @__PURE__ */ new Set();
      const setState = (partial, replace) => {
        const nextState = typeof partial === "function" ? partial(state) : partial;
        if (!Object.is(nextState, state)) {
          const previousState = state;
          state = (replace != null ? replace : typeof nextState !== "object") ? nextState : Object.assign({}, state, nextState);
          listeners.forEach((listener) => listener(state, previousState));
        }
      };
      const getState = () => state;
      const subscribe = (listener) => {
        listeners.add(listener);
        return () => listeners.delete(listener);
      };
      const destroy = () => {
        if (true) {
          console.warn(
            "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
          );
        }
        listeners.clear();
      };
      const api = { setState, getState, subscribe, destroy };
      state = createState(setState, getState, api);
      return api;
    };
    createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;
    vanilla = (createState) => {
      if (true) {
        console.warn(
          "[DEPRECATED] Default export is deprecated. Instead use import { createStore } from 'zustand/vanilla'."
        );
      }
      return createStore(createState);
    };
  }
});

// node_modules/zustand/esm/shallow.js
var shallow_exports = {};
__export(shallow_exports, {
  default: () => shallow$1,
  shallow: () => shallow
});
function shallow(objA, objB) {
  if (Object.is(objA, objB)) {
    return true;
  }
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  if (objA instanceof Map && objB instanceof Map) {
    if (objA.size !== objB.size)
      return false;
    for (const [key, value] of objA) {
      if (!Object.is(value, objB.get(key))) {
        return false;
      }
    }
    return true;
  }
  if (objA instanceof Set && objB instanceof Set) {
    if (objA.size !== objB.size)
      return false;
    for (const value of objA) {
      if (!objB.has(value)) {
        return false;
      }
    }
    return true;
  }
  const keysA = Object.keys(objA);
  if (keysA.length !== Object.keys(objB).length) {
    return false;
  }
  for (let i = 0; i < keysA.length; i++) {
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !Object.is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }
  return true;
}
var shallow$1;
var init_shallow = __esm({
  "node_modules/zustand/esm/shallow.js"() {
    shallow$1 = (objA, objB) => {
      if (true) {
        console.warn(
          "[DEPRECATED] Default export is deprecated. Instead use `import { shallow } from 'zustand/shallow'`."
        );
      }
      return shallow(objA, objB);
    };
  }
});

// node_modules/viem/node_modules/@adraffy/ens-normalize/dist/index.cjs
var require_dist2 = __commonJS({
  "node_modules/viem/node_modules/@adraffy/ens-normalize/dist/index.cjs"(exports) {
    "use strict";
    function decode_arithmetic(bytes) {
      let pos = 0;
      function u16() {
        return bytes[pos++] << 8 | bytes[pos++];
      }
      let symbol_count = u16();
      let total = 1;
      let acc = [0, 1];
      for (let i = 1; i < symbol_count; i++) {
        acc.push(total += u16());
      }
      let skip = u16();
      let pos_payload = pos;
      pos += skip;
      let read_width = 0;
      let read_buffer = 0;
      function read_bit() {
        if (read_width == 0) {
          read_buffer = read_buffer << 8 | bytes[pos++];
          read_width = 8;
        }
        return read_buffer >> --read_width & 1;
      }
      const N = 31;
      const FULL = 2 ** N;
      const HALF = FULL >>> 1;
      const QRTR = HALF >> 1;
      const MASK = FULL - 1;
      let register = 0;
      for (let i = 0; i < N; i++)
        register = register << 1 | read_bit();
      let symbols = [];
      let low = 0;
      let range = FULL;
      while (true) {
        let value = Math.floor(((register - low + 1) * total - 1) / range);
        let start = 0;
        let end = symbol_count;
        while (end - start > 1) {
          let mid = start + end >>> 1;
          if (value < acc[mid]) {
            end = mid;
          } else {
            start = mid;
          }
        }
        if (start == 0)
          break;
        symbols.push(start);
        let a = low + Math.floor(range * acc[start] / total);
        let b = low + Math.floor(range * acc[start + 1] / total) - 1;
        while (((a ^ b) & HALF) == 0) {
          register = register << 1 & MASK | read_bit();
          a = a << 1 & MASK;
          b = b << 1 & MASK | 1;
        }
        while (a & ~b & QRTR) {
          register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
          a = a << 1 ^ HALF;
          b = (b ^ HALF) << 1 | HALF | 1;
        }
        low = a;
        range = 1 + b - a;
      }
      let offset = symbol_count - 4;
      return symbols.map((x) => {
        switch (x - offset) {
          case 3:
            return offset + 65792 + (bytes[pos_payload++] << 16 | bytes[pos_payload++] << 8 | bytes[pos_payload++]);
          case 2:
            return offset + 256 + (bytes[pos_payload++] << 8 | bytes[pos_payload++]);
          case 1:
            return offset + bytes[pos_payload++];
          default:
            return x - 1;
        }
      });
    }
    function read_payload(v) {
      let pos = 0;
      return () => v[pos++];
    }
    function read_compressed_payload(s) {
      return read_payload(decode_arithmetic(unsafe_atob(s)));
    }
    function unsafe_atob(s) {
      let lookup = [];
      [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach((c, i) => lookup[c.charCodeAt(0)] = i);
      let n = s.length;
      let ret = new Uint8Array(6 * n >> 3);
      for (let i = 0, pos = 0, width = 0, carry = 0; i < n; i++) {
        carry = carry << 6 | lookup[s.charCodeAt(i)];
        width += 6;
        if (width >= 8) {
          ret[pos++] = carry >> (width -= 8);
        }
      }
      return ret;
    }
    function signed(i) {
      return i & 1 ? ~i >> 1 : i >> 1;
    }
    function read_deltas(n, next) {
      let v = Array(n);
      for (let i = 0, x = 0; i < n; i++)
        v[i] = x += signed(next());
      return v;
    }
    function read_sorted(next, prev = 0) {
      let ret = [];
      while (true) {
        let x = next();
        let n = next();
        if (!n)
          break;
        prev += x;
        for (let i = 0; i < n; i++) {
          ret.push(prev + i);
        }
        prev += n + 1;
      }
      return ret;
    }
    function read_sorted_arrays(next) {
      return read_array_while(() => {
        let v = read_sorted(next);
        if (v.length)
          return v;
      });
    }
    function read_mapped(next) {
      let ret = [];
      while (true) {
        let w = next();
        if (w == 0)
          break;
        ret.push(read_linear_table(w, next));
      }
      while (true) {
        let w = next() - 1;
        if (w < 0)
          break;
        ret.push(read_replacement_table(w, next));
      }
      return ret.flat();
    }
    function read_array_while(next) {
      let v = [];
      while (true) {
        let x = next(v.length);
        if (!x)
          break;
        v.push(x);
      }
      return v;
    }
    function read_transposed(n, w, next) {
      let m = Array(n).fill().map(() => []);
      for (let i = 0; i < w; i++) {
        read_deltas(n, next).forEach((x, j) => m[j].push(x));
      }
      return m;
    }
    function read_linear_table(w, next) {
      let dx = 1 + next();
      let dy = next();
      let vN = read_array_while(next);
      let m = read_transposed(vN.length, 1 + w, next);
      return m.flatMap((v, i) => {
        let [x, ...ys] = v;
        return Array(vN[i]).fill().map((_, j) => {
          let j_dy = j * dy;
          return [x + j * dx, ys.map((y) => y + j_dy)];
        });
      });
    }
    function read_replacement_table(w, next) {
      let n = 1 + next();
      let m = read_transposed(n, 1 + w, next);
      return m.map((v) => [v[0], v.slice(1)]);
    }
    function read_trie(next) {
      let ret = [];
      let sorted = read_sorted(next);
      expand(decode([]), []);
      return ret;
      function decode(Q) {
        let S = next();
        let B = read_array_while(() => {
          let cps = read_sorted(next).map((i) => sorted[i]);
          if (cps.length)
            return decode(cps);
        });
        return { S, B, Q };
      }
      function expand({ S, B }, cps, saved) {
        if (S & 4 && saved === cps[cps.length - 1])
          return;
        if (S & 2)
          saved = cps[cps.length - 1];
        if (S & 1)
          ret.push(cps);
        for (let br of B) {
          for (let cp of br.Q) {
            expand(br, [...cps, cp], saved);
          }
        }
      }
    }
    var r$1 = read_compressed_payload("AEITLAk1DSsBxwKEAQMBOQDpATAAngDUAHsAoABoAM4AagCNAEQAhABMAHIAOwA9ACsANgAmAGIAHgAvACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGAAeABMAFwAXBOcF2QEXE943ygXaALgArkYBbgCsCAPMAK6GNjY2NgE/rgwQ8gAEB0YG6zgFXgVfAD0yOQf2vRgFDc/IABUDz546AswKNgKOqAKG3z+Vb5ACxdICg/kBJuYQAPK0AUgCNJQKRpYA6gDpChwAHtvAzxMSRKQEIn4BBAJAGMQP8hAGMPAMBIhuDSIHNACyAHCY76ychgBiBpoCKgbwACIAQgyaFwKqAspCINYIwjADuBRCAPc0cqoAqIQfAB4ELALeHQEkAMAZ1AUBECBTPgmeCY8lIlZgTOqDSQAaABMAHAAVclsAKAAVAE71HN89+gI5X8qc5jUKFyRfVAJfPfMAGgATABwAFXIgY0CeAMPyACIAQAzMFsKqAgHavwViBekC0KYCxLcCClMjpGwUehp0TPwAwhRuAugAEjQ0kBfQmAKBggETIgDEFG4C6AASNAFPUCyYTBEDLgIFLxDecB60Ad5KAHgyEn4COBYoAy4uwD5yAEDoAfwsAM4O0rwBImqIALgMAAwCAIraUAUi3HIeAKgu2AGoBgYGBgYrNAOiAG4BCiA+9Dd7BB8eALEBzgIoAgDmMhJ6OvpQtzOoLjVPBQAGAS4FYAVftr8FcDtkQhlBWEiee5pmZqH/EhoDzA4s+H4qBKpSAlpaAnwisi4BlqqsPGIDTB4EimgQANgCBrJGNioCBzACQGQAcgFoJngAiiQgAJwBUL4ALnAeAbbMAz40KEoEWgF2YAZsAmwA+FAeAzAIDABQSACyAABkAHoAMrwGDvr2IJSGBgAQKAAwALoiTgHYAeIOEjiXf4HvABEAGAA7AEQAPzp3gNrHEGYQYwgFTRBMc0EVEgKzD60L7BEcDNgq0tPfADSwB/IDWgfyA1oDWgfyB/IDWgfyA1oDWgNaA1ocEfAh2scQZg9PBHQFlQWSBN0IiiZQEYgHLwjZVBR0JRxOA0wBAyMsSSM7mjMSJUlME00KCAM2SWyufT8DTjGyVPyQqQPSMlY5cwgFHngSpwAxD3ojNbxOhXpOcacKUk+1tYZJaU5uAsU6rz//CigJmm/Cd1UGRBAeJ6gQ+gw2AbgBPg3wS9sE9AY+BMwfgBkcD9CVnwioLeAM8CbmLqSAXSP4KoYF8Ev3POALUFFrD1wLaAnmOmaBUQMkARAijgrgDTwIcBD2CsxuDegRSAc8A9hJnQCoBwQLFB04FbgmE2KvCww5egb+GvkLkiayEyx6/wXWGiQGUAEsGwIA0i7qhbNaNFwfT2IGBgsoI8oUq1AjDShAunhLGh4HGCWsApRDc0qKUTkeliH5PEANaS4WUX8H+DwIGVILhDyhRq5FERHVPpA9SyJMTC8EOIIsMieOCdIPiAy8fHUBXAkkCbQMdBM0ERo3yAg8BxwwlycnGAgkRphgnQT6ogP2E9QDDgVCCUQHFgO4HDATMRUsBRCBJ9oC9jbYLrYCklaDARoFzg8oH+IQU0fjDuwIngJoA4Yl7gAwFSQAGiKeCEZmAGKP21MILs4IympvI3cDahTqZBF2B5QOWgeqHDYVwhzkcMteDoYLKKayCV4BeAmcAWIE5ggMNV6MoyBEZ1aLWxieIGRBQl3/AjQMaBWiRMCHewKOD24SHgE4AXYHPA0EAnoR8BFuEJgI7oYHNbgz+zooBFIhhiAUCioDUmzRCyom/Az7bAGmEmUDDzRAd/FnrmC5JxgABxwyyEFjIfQLlU/QDJ8axBhFVDEZ5wfCA/Ya9iftQVoGAgOmBhY6UDPxBMALbAiOCUIATA6mGgfaGG0KdIzTATSOAbqcA1qUhgJykgY6Bw4Aag6KBXzoACACqgimAAgA0gNaADwCsAegABwAiEQBQAMqMgEk6AKSA5YINM4BmDIB9iwEHsYMGAD6Om5NAsO0AoBtZqUF4FsCkQJMOAFQKAQIUUpUA7J05ADeAE4GFuJKARiuTc4d5kYB4nIuAMoA/gAIOAcIRAHQAfZwALoBYgs0CaW2uAFQ7CwAhgAYbgHaAowA4AA4AIL0AVYAUAVc/AXWAlJMARQ0Gy5aZAG+AyIBNgEQAHwGzpCozAoiBHAH1gIQHhXkAu8xB7gEAyLiE9BCyAK94VgAMhkKOwqqCqlgXmM2CTR1PVMAER+rPso/UQVUO1Y7WztWO1s7VjtbO1Y7WztWO1sDmsLlwuUKb19IYe4MqQ3XRMs6TBPeYFRgNRPLLboUxBXRJVkZQBq/Jwgl51UMDwct1mYzCC80eBe/AEIpa4NEY4keMwpOHOpTlFT7LR4AtEulM7INrxsYREMFSnXwYi0WEQolAmSEAmJFXlCyAF43IwKh+gJomwJmDAKfhzgeDgJmPgJmKQRxBIIDfxYDfpU5CTl6GjmFOiYmAmwgAjI5OA0CbcoCbbHyjQI2akguAWoA4QDkAE0IB5sMkAEBDsUAELgCdzICdqVCAnlORgJ4vSBf3kWxRvYCfEICessCfQwCfPNIA0iAZicALhhJW0peGBpKzwLRBALQz0sqA4hSA4fpRMiRNQLypF0GAwOxS9FMMCgG0k1PTbICi0ICitvEHgogRmoIugKOOgKOX0OahAKO3AKOX3tRt1M4AA1S11SIApP+ApMPAOwAH1UhVbJV0wksHimYiTLkeGlFPjwCl6IC77VYJKsAXCgClpICln+fAKxZr1oMhFAAPgKWuAKWUVxHXNQCmc4CmWdczV0KHAKcnjnFOqACnBkCn54CnruNACASNC0SAp30Ap6VALhAYTdh8gKe1gKgcQGsAp6iIgKeUahjy2QqKC4CJ7ICJoECoP4CoE/aAqYyAqXRAqgCAIACp/Vof2i0AAZMah9q1AKs5gKssQKtagKtBQJXIAJV3wKx5NoDH1FsmgKywBACsusabONtZm1LYgMl0AK2Xz5CbpMDKUgCuGECuUoYArktenA5cOQCvRwDLbUDMhQCvotyBQMzdAK+HXMlc1ICw84CwwdzhXROOEh04wM8qgADPJ0DPcICxX8CxkoCxhOMAshsVALIRwLJUgLJMQJkoALd1Xh8ZHixeShL0wMYpmcFAmH3GfaVJ3sOXpVevhQCz24Cz28yTlbV9haiAMmwAs92ASztA04Vfk4IAtwqAtuNAtJSA1JfA1NiAQQDVY+AjEIDzhnwY0h4AoLRg5AC2soC2eGEE4RMpz8DhqgAMgNkEYZ0XPwAWALfaALeu3Z6AuIy7RcB8zMqAfSeAfLVigLr9gLpc3wCAur8AurnAPxKAbwC7owC65+WrZcGAu5CA4XjmHxw43GkAvMGAGwDjhmZlgL3FgORcQOSigL3mwL53AL4aZofmq6+OpshA52GAv79AR4APJ8fAJ+2AwWQA6ZtA6bcANTIAwZtoYuiCAwDDEwBEgEiB3AGZLxqCAC+BG7CFI4ethAAGng8ACYDNhJQA4yCAWYqJACM8gAkAOamCqKUCLoGIqbIBQCuBRjCBfAkREUEFn8Fbz5FRzJCKEK7X3gYX8MAlswFOQCQUyCbwDstYDkYutYONhjNGJDJ/QVeBV8FXgVfBWoFXwVeBV8FXgVfBV4FXwVeBV9NHAjejG4JCQkKa17wMgTQA7gGNsLCAMIErsIA7kcwFrkFTT5wPndCRkK9X3w+X+8AWBgzsgCNBcxyzAOm7kaBRC0qCzIdLj08fnTfccH4GckscAFy13U3HgVmBXHJyMm/CNZQYgcHBwqDXoSSxQA6P4gAChbYBuy0KgwAjMoSAwgUAOVsJEQrJlFCuELDSD8qXy5gPS4/KgnIRAUKSz9KPn8+iD53PngCkELDUElCX9JVVnFUETNyWzYCcQASdSZf5zpBIgluogppKjJDJC1CskLDMswIzANf0BUmNRAPEAMGAQYpfqTfcUE0UR7JssmzCWzI0tMKZ0FmD+wQqhgAk5QkTEIsG7BtQM4/Cjo/Sj53QkYcDhEkU05zYjM0Wui8GQqE9CQyQkYcZA9REBU6W0pJPgs7SpwzCogiNEJGG/wPWikqHzc4BwyPaPBlCnhk0GASYDQqdQZKYCBACSIlYLoNCXIXbFVgVBgIBQZk7mAcYJxghGC6YFJgmG8WHga8FdxcsLxhC0MdsgHCMtTICSYcByMKJQGAAnMBNjecWYcCAZEKv04hAOsqdJUR0RQErU3xAaICjqNWBUdmAP4ARBEHOx1egRKsEysmwbZOAFYTOwMAHBO+NVsC2RJLbBEiAN9VBnwEESVhADgAvQKhLgsWdrI5P6YgAWIBjQoDA+D0FgaxBlEGwAAky1ywYRC7aBOQCy1GDsIBwgEpCU4DYQUvLy8nJSYoMxktDSgTlABbAnVel1CcCHUmBA94TgHadRbVWCcgsLdN8QcYBVNmAP4ARBEHgQYNK3MRjhKsPzc0zrZdFBIAZsMSAGpKblAoIiLGADgAvQKhLi1CFdUClxiCAVDCWM90eY7epaIO/KAVRBvzEuASDQ8iAwHOCUEQmgwXMhM9EgBCALrVAQkAqwDoAJuRNgAbAGIbzTVzfTEUyAIXCUIrStroIyUSG4QCggTIEbHxcwA+QDQOrT8u1agjB8IQABBBLtUYIAB9suEjD8IhThzUqHclAUQqZiMC8qAPBFPz6x9sDMMNAQhDCkUABccLRAJSDcIIww1DCUMKwy7VqDEOwgyYCCIPkhroBCILwhZCAKcLQhDCCwUYp3vjADtyDEMAAq0JwwUi1/UMBQ110QaCAAfCEmIYEsMBCADxCAAAexViDRbSG/x2F8IYQgAuwgLyqMIAHsICXCcxhgABwgAC6hVDFcIr8qPCz6hCCgKlJ1IAAmIA5+QZwg+lYhW/ywD7GoIIqAUR/3cA38KnwhjiARrCo5J5eQcCqaKKABLCDRsSAAOaAG3CDQALwqdCCBpCAsEIqJzRDwIHx6lCBQDhgi+9bcUDTwAD8gAVwgAHAgAJwgBpkgAawgAOwgkYwo5wFgIAAWIADnIALlIlAAbCABfCCCgADVEAusItAAPCAA6iKvIAsmEAHCIAG8IAAfIKqAAFzQscFeIAB6IAQsIBCQBpwgALggAdwgAIwgmoAAXRAG6mGdwAmAgoAAXRAAFCAAfiAB2iCCgABqEACYIAGzIAbSIA5sKHAAhiAAhCABTCAwBpAgkoAAbRAOOSAAlCC6gOy/tmAAdCAG6jQE8ATgAKwgsAA0IACbQDPgAHIgAZggACEqcCAAoiAApCAAoCp/IGwgAJIgADEgAQQgcAFEIAEXIAD5IADfIADcIAGRINFiIAFUIAbqIWugHCAMEAE0IKAGkyEQDhUgACQgAEWQAXggUiAAbXABjCBCUBgi9ZAEBMALYPBxQMeQAvMXcBqwwIZQJzKhMGBBAOdlJzZjGQJgWHGwVpND0DqAq7BgjfAB0DAgp1AX15TlkbKANWAhxFATMGCnpNxIJZgUcAMAA4CAACAAAAWhHiAIKXMwEyAH3sFBg5TQhRAF4MAAhXAQ6R0wB/QgQnrABhAN0cAJxvPiaSANRyuADW2wEdD8l8eiIfXSQQ2AGPl7IpWlpUTxlDyZAAAACGIz5HMDLnGJ5WAHkBMCw3KUkgFgM3XAT+zPUAUmzjAHECeAJGEYE6zng1NdwCAQwXGSYLGw60tQIBAQEABQIEAgIAGdMCACwBAAUFBQUFBQQEBAQEBAMEBQYHCAMEBAQEAwEBIQCMAI8AlDwA6QC6ANsAo0MAwQCxAKwApwDtAKUA2QCiAOYBBwECAMYAgABhANEA0wECAN0A8QCPAKgBMADpAN4A2woACA4xOtnZ2dm7xeHS1dNINxwBUQFbNEwBWQFoAWcBWgFLUEhKbRIBUhoMDwo5PRINACYTKiwuMT0/P0JCQkNEE0UFI1ZWVlZYWFdYLllaXFtbImJmZmVnZilrbXV0d3d3d3d3eXl5eXl5eXl5eXl7e3x7emEAQ/EASACZAHcAMQBl9wCNAFYAVgA2AnXuAIoABPf3AGMAkvEAngBOAGEAY/7+rwCEAIQAaABVALAAIwC1AIICPwJCAPsA5gD9AP0A5wD+AOgA6ADnAOUALgJ6AVABPwE9AVMBPQE9AT0BOAE3ATcBNwEbAVcWADAPBwAAUh4RHQocHRUAjQCVAKUAUABpHwIwAHUAbgCWAxQDJjEDIEhFTjAAkAJOAMYCVgKjAL8ClQKVApUClQKVApUCigKVApUClQKVApUClQKUApQClwKfApYClQKVApMCkwKTApMCkQKUAnQB0wKWAp4ClQKVApQdgBIEAP0MA54CYAI5HgFTFzwC4RgRMhoBTT4aVJgBeqtDAWhgAQQDQE4BBQCYMB4flnEAMGcAcAA1AJADm8yS8LWLYQzBMhXJARgIpNx7MQsEKmFzAbkA5IWHhoWHhYiJiYWKjYuFjI+Nh46Jj4mQhZGFkoWTkZSFlYWWiZeFmIWZhZqFm4qcj52JnoUAiXMrc6cAinNzBEIEPwRBBEQEQgRIBEUEQARGBEgERwRDBEUESACqA45zANBYc3MA1nMCE3MA/WFzAP0BIAD9APsA+wD8APvbA4sqbMUA/QD7APsA/AD7I3NzAJBhcwD9AJABIAD9AJAC8wD9AJDbA4sqbMUjcwD+YXMBIAD9AP0A+wD7APwA+wD+APsA+wD8APvbA4sqbMUjc3MAkGFzASAA/QCQAP0AkALzAP0AkNsDiypsxSNzAkoBPXMCUQFAcwJSyHNzA6UC8wOl2wOLKmzFI3NzAJBhcwEgA6UAkAOlAJAC8wOlAJDbA4sqbMUjcwQ3cwCQBDgAkA2UOHQnATNz3QdFdQoqcwEEAM1hCXNzAFthAAUaOQlzcwCQCXNE3wBQc90JcwCdbXNzQ4CD8BW5tNbewS6T/Np1iIh1Iy3DtPDAAXjPx9ENpwOgreI1z2BewtbX8Yi21FG1bBeCk7aB4sFY/Hi+/ekcwwyBHP+f0YI9G/iFY/5bObtuyY4MTYyHeQiZ62eBq/P8+68/rJI6cCQTfucgoskxeeDzvfo6MGQtbufZbw0FPGPpUNSG9SSs7NDWGUbpnlDGReZvnpkqvyGbE9edMaFydt2lujOB9XLYEAXRfM2Kx0lHbXJ4cszHh5aoooqxDeYXz4qvSy3ahNyE6DBY8J7v31dfMFEdiyjfirJ6hX3Pa2ygMOeuVytsRijRhyF9mVnMu2RxuZv3hI/Amu/2xe54SmySPFpHGxTUY0pe8SZ3I+HauujP4GbIzZYg6enubuUlyP0funGhg8HHYTHFSQD9Hm7HGbFy4n0sziYcpwdArgmsyy41VMV2ppGXMiMR4deCi34NNmlnftVdxoyCJzK+r1GvJvWDtbf4dPnrf0G9qOgEs2CpD3n+1P6MHu+kHtsR6lMcf3NcCDlg2BVcCpSVRHQRiw7qolVbxHeM9xvBMbdwjpFKXi7QUZOi6YaKam2q+tP/4Q5El2aNNWkj5UfSZY4ugEdPUnNXG3TnvpCSZ5IpiIvjM/Q7pZNYYv80gD+OdT5J+D+8K7RPkhzH4w8mJHEG67poqLR0JygXeOe4Qz7fpS6uh/vOXaryaHpamD78JfCU/VdaCwy9bCrfgh13NQynhoIdWRr1IQREtBfsr9bRjkodN4IdiTUMDdlCuM8mKFhoQzu5fn+1PZwtWpT+RAfPcOYqFvyg15NH3r44CwuiNOuJa3QiXx/LenV02OWmQIs/SX/g9e97kXeFyzzC5o3GZEj1A4edoQL/Hfudd5DbKP9jRl8TN4J6Kc1PFyNVAX5Xac6bdFhUIzF/y2fxEOMqCLdbgMjAScVBfo62Fi65kWkU5AuSnpXNEa53A8jiHAFWPQRbvChz7XzIQ1/JFkW4oI8xBV6UfjKIPDLC7squNvW2nzcUx+fOUY3Ocin2ftqIvHfTUJTRNcd7Ke70yAIwvqOtwoyPaZMBpoXD8wnXXhGcZwxMUx5c5bPIUoEI0NmMFTasTLrC3msRFOTj05Bautfl1sY/SvMF/LAsyI9YLxLDyLAdk5DR3UM3aUic2osD5OeVdqZVW/Q1m1ebiFPdS2jIqNLulNQ8bGE2SLfELriR1KiTO9P5+lrvWYO1fSrGrUt2bWuylLbZPkwOvWGZpLOHyarck2ZRqWS6sCGey7WyzKtSLDf8N998dc1hh6BN4lUthsFzHww9KK8RpC1vUV1amMjRDMR+KvY6u8hOpZEzHdLMb13izFQP3ijwSQCEFVH7Js8hL21h1Vgxap8exSPY1CBI89DYkx6Tv5XhsKTqejQ6qbBFVPb0FeZ+D1SdjxYgqAq6uvJHq7PW8hluldBOJ7puqANPsXDOtG/su5LwU1PnRExiBpZNO+7blORJ7i9gQYmu2AXSSiKxSZIyyJ+0umdON6y4aPTTM0FbgQzMWfO3PXOymBuZ9DjNH4dcMJSwm9PsU05clrl3w1WkZ04jCxhragJpQ4w9q2B/PX0G25bXPNnUGKSL3EAHAUkcsOzO66BRomJQr0Z8uQAcdKYDE3iFkuZQy+yZq2C3vghrwhw2d8jCgn3V2SEF0Obph80afZ5zohDVBkZps5UEZmSaeyACcgZ6Ecj/Z3Shx0cxedqpF4rbvSD14by33Qb4gSiKqHx0WH7WjNWW+fZz2t1PtJAPWvC6IaLarFyTSGtiv46IG1Q3YMBw5bDrisQFBnBi22oUgsO/eSzcLI5+wpv1ZX3aTHBQ79qiLoPd5uu6JrnhGzEeM0/gRT5wwCJ6uPDv35Qi4MGUO2s9+aimuET6TexV/KC9BGv9ibvW0+9hFedmTLXfrk2/sgHRe5wZPR6ao7kFwN3Egab8d2ApFPLOUgTY+d32/+XKglFsszuassqJBzo6MTbCwlYKO4yYdfk2gfjuHXxxdIjaUUcqePg/jf4AWUOsz7EjkKaPqLCzwTwkuPoskO+HPvSSIj56NBqwhlukh/SUlBPCAvpc+1hWM5aIt7e+NWicwHeXmf7JihSLmAxjDWNDmv6lSpQAYgl3KGYcLR/SwD/UbzS+YBYGKLhVlwwyGYf2autLOFuC7hdVncxFH6lx4+53/q/z8ukeP5C9jWhZLQvvvXJkWbnwQUbH8WW8VDTl7dYYgEw/d8e8PZVIP8QO8aJwNBObbcAh1bZg/ev/mIcRpHqvapWZBZJccfvQ55WYxxTdBLqYbSDjLNfI0d/IB7j1JaX07Z1abn2SGfV7zm8TU65Tqui5ZG/m8fTS7ZJVkQbJqcHfdRPbFKgIm9Q6lqhbspKIufB0JN5lyRQHiZp5cOyRLL44fHhfM56Ukt8hCMN0cSOYZcp5mvcoAcpVNPjMcA/siqAhaIn3EO6j0+ArsfN/wEexl90dGjecxE+R4JAHU9hBGZrDrJJ0L3FasUPVvPdmvrRUYY0LSEJpgUBo4pykiQr4GRZ9cAVKhzBxs86T9E+h0iOclANvJaS1ozReL9coKT4XJH2R15ed78yO6xqF3vPVSvwW+hApUYHspT4xNknEfEBks2ZT80sBfcq+kKqQeraVh2FtwOkIyPZc2PIZqDVqS2OfSXUEJ+aPajbV+aVHDMxPd4ak0ln8Lm3mlBsJjoNzm1LCOw1FWMbUNFmAyj82fesmdYwbtO9hz97ErIjkGBD8ojAOzSZzPT7bq7FxmZzdfzjVX5lq0DgHNm/HtOP0Fha40VmytaL4VvkkkmaH1vfbxgid+hNPqf//ggLAH9wOu9cN3TPGf7RkhvnFBg9Ue9dEMIY0QnUn6WfZwgFnf37KcfXeA/7qvv2NJesfukMgngn3pyJLjhbJ8DGZvbF61Q19ZVHZ/HfiOf3XZwiD/xlEDb+fuGzUrWRq7IMm/Qsd6SJc6Lqt4i6YC+L5h62FwYHiS63//p0lyL3iAb18QEPtnpbEUty0Zrt0fktA9L/YFLfrzYT6atdQjL6OMhCrZ4O3UUaYR0yme/4GNO/yHHufyAVpH/OIPEf2OzptXJ19+tA+NpivJNqCKOwUsJHqTzrT2G77O9dBe4ZcGyF0mPkzzJEpTJOjkgCt47TXZnFahlCXR9VbZ0lb1c1wAqXTKUqyPVaxz4Eu3rPJHiM3IXQQ0NjTvzUPG258V7vbrgoezETHlADY7B1WeyNMFYVE/LaWY7bSfQb7lKJ/KMRmoFwCrkwMEEkDen5KTEXCfVJrN+v4OeBxxE44mtzJOKdlLb7tqPfXrxftovGQyuaJhwlI3qpYBgfatKX2BJFeGTK5b4b9aSrMIv0QoyWUKQxoWaM41bP4QW5RbSawNQdN/0wv7aL9Jkk5J66IDpo7KQGXAKznLFeMn7t0F83ZTXPCDUhEjgWM2SA9ChmM5YEHa5l1hI1fsf77dxeRWfVHKPsN3Pbl3Dy5b4QIYb6N4Pm9jAAQLmQlaBBhZw5Ia7PfQ+xKgKJFQbR4F32mFfupbsbWLM9jDeqYdACLyf6uAKgVu9AJQpYtNbCj5wj9nXAWUWbWQL1cXcTXoVZqxjtyS/BsoaURCQi3dk09KVzUA0V6ZlrQ53Kj5AnQOcl+5F45QK+I7z2+zhbRVGq2VwcLCugx3BCQZwoiwsqtS8RQRixu4k8uRiaKZ/k7rmghRah8nMGZhmN6r12o0TqdMaPiD/n4TLE9VhVaO0KPZEGCIhU8QX+UXBAqICxssIsyKn1OrvUgTYYTO4jXEpu2+kVS6L6T5gjC1tufk8YssX4CRRcvyMaWoJuzmhC3Bq/DBUCuPaMuhQPIQfcmps2oqp9AqlngtSCo26+n5fKqSzEU3lpH1SMPRDrw6OdD/LhpNrs1YTHgMmP068bb8qMgF+/ASQedI7CvWdu04rAtlsP7kSnTDkyMw2LiZnpMx+i+ayXB7c3ckJcjFuig7H00vq2OQzM5PPevRdYi+cZJifcz1t3cNSD0yuvsuFXD/Nk2j60H5RpUU+Zrlp99wSgKEAkuC8nBJJnZ9PR+DkXPe3s4UeOKoq99964VWB9Pnva6uKI779pgq9oaspNcGV8vSOMCM8ACQn9kUPweu9UwI2n5+goo05CFaR5kALF5jhYmybPavdtAxmaC//LVF0ZLRkIcU+NGJzY3OdUKILkQKUDGABumIZHHzKw/jCOmPL+Zl8t46Wkz0WFvi9Gu4zuSn4okuXcj0BSeDVzHIf7sqCBjmC4zCJ+jyS/+Gq2fPUkgfW0bxdgVFMY+zY3TQuMfygLLiF9MzfKQiZXIgzRm4z85AALjRtWp3nO7kFP7ApIqqe2zn0NfjROHgw/hqbhgKGKjsXzu+rrdu5HeSlhWO8hxwDmVaQObSdcyTFMG/YiFD6lJGKdFb4NNS1HnW8T1P6nNQPqraOBTSnQKxz5tTGqNrbaAE4Iio3Cj50ZUqo6/O5OAtJ6Bznp4gKMgBetgD11fCO++j1RdcFdTbD0tkgfxXgzJTUtWCUmdYjl93RR27ifZGYzgK23MdwF4zvKNem782m0dQnmh47Rxz3+2MVhiiS85nTOXxmaODvzAWBE2IQowSrbzE12IJ82fOrvritWvRIF0aLCLdEytK+NVdDxLvmdW+dFeKOa/ocw1Son0O6OzX0lBLmjYSMQSrFe5X5yf6WE2ehsLrv6M8Cqjvwr+u9X+kP/f3iAk31TV+K9yZKQqAn3QOWy+9Hz7iVWRMuM9hs35+avVy4pXASFbOjGdXM1fSQkLOWmFUhyadKWYPjRZoZo0g3CS0qhz+mjygAvmtkYRBcGNpYAEYoIDEwQaswtATb9HLzTetQL8aK79YSb0vJNPSYzsij3FcXbmfnMiaOJIGrrBJnAPRqg2lmCZFXOFah9l2GRBm8HJMGeiupFvR0aRN41otN6X6tGTxS53wk+2+w+Q5ABTdCd15LYZm/a/3bxe9RDQJ5HZhLzr5x1ccTkxBkbxlYBGd8AKvkL2IR3V283R5noyhAM5o/2rKEi4U6kxCV5efr8llvLFrgjPIwS8iES5jxmV5zyPzj7TyzJTJze+9tgDNGYRyyXPkU4mtAh8XUy9vMigfO+1+ZKYW2WCFjDUfvyNiplha4LliPPg8Rc890ZT+F9pMYPAmEg3JJVUm3fp5N0IPNMAYKmbdj8dkIpjDhDJUd6o3G858DgYwPhSC+z3a78QpEmqq+tRaHEcQ30ZN5KVVdASN8NMTnLKoA+IJdapqCRgooGTkhyjB1yEmjSy52110hPaqe1upiUeObsTXtGELTk2p2NZw/3PzU281tafWNmFUPAmooj83DhoQgKPIB7f+NGTDlTOtyPgN8pIB/lnFLL/gcwigZPKDW7p6hnW/GnAzyNS46gLJAl0Eyhqx6UWLeQTU7odMYORK5zf/FV79JGVPOQpNUA58rlB0ugHsyeub8Lnf9QQ4/N5sRKaUjEEhdpF28vfgPZACBbg5UHuVHl8Lby8mVGsrtI7TjL9U3mbtcF+cXQI/5AxT2i0MyciXEKZ8OjvPoQHHU/YSnCXtEp2r08SJxUAHIz1zM+FwdRCYPffQNi2NhkPWTiYTxJ00WVZIrHwmG7jzOLcfWnquJkpOmdPzXfAu+s5EADm0X4VmatqLjVa86dS7Os55qXuRa1Y7dWGvv57LjBlKKgqsbI7lwfyBN3qkKBqe7nwUDn6xqhGPiUPT7j7s+oD52AF6oj6SFXhYWlRXy+1FL7YSbjFxfFvJt5tVXMAr8/voIg8YRiBsKB6eLeIG5Y/KmGmFBxxYzSH7W0IaK3IId+cBlEk6H3Y5BqIBfvhOOBtInLWnsAoRpqlkxd7o/+LP9UXEahdcYlifFlURgUJl0Ly6LHjSZN1CfHB7OORacnBdpIM1lRpBcvwkeyXUvndU4zrfqwtuBEpxqvk4PZPJMByJXUbXie52mfUB689h9GRV99U4gzn1aTbHPWjbB0DQ0Aes2E/ZzoCTxCef56sExSu8ynaPxuDOOeD31OWT0zHo1XxSPQbclDivD+4/v1aWdhGXLR1Ui+NzuQK1NTedznX44c5T3b+2GZZjl5RqH8KR7FTVjLAXvg64Gpc1RROH24J9jrNDyvrMxY453DRUjZ/K3zYJC+M1JxcvLkuZALsXVQ4Z7sj0EuLbRnhTKzRGwFrpXcixvnCgRbJrCl3+RjyWVipph0VLB0nDop/tvjfFmysZ+d2/k6baJMxYoqnE7PFceicrxUYyoJ2LMxicgJqrgvSR3mNJTkvfTU8BIoZz3PpSIS+Y7Ey3MXecxcxYZTeX62egI5Nub2z8Bj4Eg71YCz8Oiapkinw4RRlL+0c2/6jDqc8UK4Zzi1X4aIpgYsPJQOEz2YWBdvH6z5CuY7UvWK2F0Mg4ofRVBArX1p9Gv5VLqWYyL/raRVWkPNI4FEv9+ePcdmBSQR4CFSO6TG13hIV+cm1dkd0/Nt3r28H4NU2knSniDCeozM/Btc4i/ni4H83S2/ktAAvUM7UKJPT+RO8LOlvxhuI8HQmAuJCzVH23R/0JovidxgdJ7g7whCdVQa9/TLFUJWmNSYAaPRAXW/kk2UBmAz6f6POK1zcMlmI8P9tqW2qVXABN0L0zHarXbWHlhtYpXMEda/pIHLwu8RHqmWWMgMzkyKicSFKK10UvZRdcO8fCiSijtFIY8qW7CscvtzpP92lm+c648urehw35v1EOfO3kdny+CQm/Y0u+zPuevhCrQKhTsUq4G1rNPoGuVzvhf2Ui1f8jzvx9fJbQR69A0ETLUUC2ndk1YFQNi22yLwyZyw4xU8P3RGLM5qojKNwHAZAMAEudzg8UdfV6i4VktOLbhhHUPqpCn6dtpnr16rINs5hWJGMYXaEn0irFCuoYnJEVhdJ4PZLKuTkrP1UUVWZ0SMgJ3F2I8YRhtLwK4dhh/oKk0hdVgEH/l2/0c+cLlF7kpDuF3lC4fsFw3V0QrwH3GLNb2waS18OmYB07yaLEqhd58bSaGJZzePoroV5v3UK46/sWdKczstFIiYLmmKeaVGRNo3IWk+dYUqWy5aJClXj5tf/v47ijlkmMDP+ROUxoGk7LFzne4/0CRPl/5SUyOa679jibvdVQFZ1o0H9kBux7OSC9B+qVKE1trxr4xqTkjc1ZGZBpY0zyKBiu8wr+/KXc37u0cdXGJwY/aTic3kGj4jt3y4ZwleKskyXMFHKGwVhqpFH3ba02boSzGHyPMAe/reVqWSTT2Uz47+uYvHZGNASqYQ23uZoxalHK+PGoH9trTVaw2KB4dH8fNrXRLhiyxGdRtS0x8k3feeOvsOdKEdaOf3IrfWCZM/n3+hVJizA4zoX8MzsIf6bDfuFXIIRR2RN0rICZcMRmnRxUXT+YMOid50gg+Nt4Uucemmbd9kvJG/O04PVC0vm5gGDlIY3THI2+l1rZcMOuSDWBp6I4Eltp7naHZCdaPUWnQ07VqO49znDgCmtu5Tb+SSEQJV+rJsiXgCqoeeQciher8cqF616P8qlZeonKihdVkj+RTnjOcnoERWubvyaeFO6Ub3dhh0qmm2RD4enszxE1JaAaiezuSoCayJQP931HGcy0NmuVr/UV0pvbwICLpBbVkxC6qebjLGRXucTG0dbQDFPz049hMem2pb/FOTGYRLR0uPCa0oIwc9Z/g+Iy/zYFDThHi1cqbK824savKGMLMj7j87RT9NMwxaI0eKTfMFioi9SyLq5sN9pV8be2FrOc7xMOdv6btXyqFx63y9fIGMBP2T9Wmeeg61ZGdTE4IwybcGlXLJ3qLbRRpQ8vSzcqFobN+QPtL+51hadAWtRbF6aJpeb7Gca4/Ldh7BDvEbrUuEm+gTyVMeRQ3Ypf9uyFjVstrQIcdY+aur3LC5I5OOnJck1zLUKxLobjy9slG3hv6zylhtKbAbpX5p8Hc910fCT7FNH5/t9xEJX9kkeZ9IMCHAk9zn7L3pXEGZVvdaf85NtlemPpY7iSgSC7zRGsI5W6/UEwX6jDtNVZ9VqPDBe/EqmEEsGcs7jZPQPhi3xpj9UXWQLiy6tsxv/ft9aKQnUg0Sps/x3AZ2uK3ETGTQogPTMQPOnoU6p5KuS3uY6DfW0GeGQ1wNpGzGoUdRJRvHP9MDQpWRSZqZkE/rcNnQ5lS9BmMDW/umgZQD1C2YXfZMy7fIVXo121293Gfx9n7DQP6OxSqiSTNx48KId9kfGYOnV2Wg2TQQywNBRB0mSmqa/jwoBDYVDl6B0XFrVEAwbnhLyqGp5BH9bzsWrrFlu0x285RpqTylTZk3rgcm57prav0DUAKUd02vXdYyNBf7sfX7VYn0Syug9++ey/dHoG7GQzMbhXhtEuRXv6YR20SQgSOrgDUGPR4HhS+Qvk2zOtyH8N/lHYfQxNKt/f7uCpsBBh5eGZaeWNRTBdOObWOvyKJMfD8FLEX1v/5ywtRV27weRzSNaHEQFE0hIzzS4VPzgWtg/4bcetwXpabsePP192muNPyXiRzRZkoeudA9D9x/oVWfRieLfjdXbi/41RGNB3aIj0IxCBHSvUN7LzntO6Oh910zV9u4Glrouyr5odjs8/fW9r0buiTMWTjjLbi2k5tZ3m/134ci/d9f8zuv+4BI7F13Mjb7DTTD5ukfqNTlNC4V9PnfbGAJdKLEDJgBPKyYXCaAL9U5Cxi2j5j+IWmNg6NSnWcATzmOO4+dNBmefy6ceyd8J9/Q7amUWVVkuNVSq3iWEb3UJP7kG+P8wfL4xS0ZNuSKYuo9KpdkJ3b4PYRNSzF+8OXKDWqXuWsan/wconybIRBoGWHMuCkb35BtGfiqZ4hc2CCapKiLmrWnBLlRT+9GA0Qcykkg1B6C3kESJMu2dWyGabbhRwxUeMxARHqbXzHmHpr4Z3vmOxHZ6b1q6MJ0Vb/XKkaPF4xn/VindEJ3S8/9xcGF+PNFuAXc2Jf9uZLLtjxDAEeohd7wjie66LHvcNT0UpWif4uCox2YR/liegMgx8vEbvQClJBMBub7zJQMCr1C/Vf8siWQASp0Ewd7D2uP6f9YTISdEaUAzF9rST9JTHxez310BfdgtWKU1ZYoRuDZvGn2tj9DPjXrkgCr/13OHsP4MOC5b6YqHSedYMW9bEfS5M3nO7zTGS85BzpLTIFqAGhZJLEyLFcZXS7hDhDYVvlm10RLEslMK0cUL/9xqTMOX2iR65umsC8dW4hT0Sg6Tf3T2HAxsHKcNzoqFwuM9k3/LpYekhRc0C+f1I+vMQ4thkfSotx9GUt/cdRosaE8XwqV0k+8ZtU+jv8nn3lbcNxfXXKi5l0SL5kMmrCdrxeVVqxBobrFF+tb0wtkN+DMm88I4jWH/DcdJOjcMOLEsN70vlsfIi+NexpaT0ZsnfewPoTvUSXqqfhRcRk3jA7AdYHEFk4l6O3fe65uZNIMf1lbtJNCNaK2+c5hGKLcTSrBmwWv9TP6JDfZ6UY96g4baayVCbrDpXePgXTG6xO3rT0DAXG9OuPxkSEPLJnqxQViyYQhCp36Q2yFpF6cR04RO7Ab5HPrECqGR0Fnr2gzmjx49XjQf8N5Bk5XH0dh8NOoB62acHwMhlBM8duW9tghc7CN7oz91UEyd8fOtwDK/j7SykdllCAN5kUrcawufMV9y/EqUoKHtP5i8MgQY9RlZFZzi0BeT9Ang4mMIvWAFChZCNnb4tT5cS20jeit8JEN4tz4mUmZxDwiWkEucI1KF/FyAnvE4wybWvbaxBYjT2jdhlzd4y/eTmTl3im5YImADc2unOtmNTcgMdOb9kUgJmgzY/hDaAxqvwLEulLsjq0bsfSE3tRYCRn6xb0uv5B5yFshhewdO5KgoLcaGeqeg0pa9k2RXM32g1jE1UDWO0CaMobavPk+4u26Tmgg6VindBdYdRxpGqlvkxai0K/atC5CWUxlHuukX5b+hg83khzsZK7AVRVptyVNicu0sfQToTDEeIeDdFvDrReJUiJGZcXAhpRL3OufhL4aDfO1zsCmfGq8qFspBiJe13lgS9GguiMsdmgpWOhHkSTVkWnMOnUeIJgqZks/AwL/1yKPm00t6x6qLXQrCJrysUwR+ILJdyyyuUN4BuEtCDUXMXPU5srsAnDUhSfFM/j4RK+cK01o6lXAVbhiOLaaQtpYN6mCOwtJNcVqEpyrxXuWxvE4mbVCytBu/qKO4X2BI1NUSlj/g6FQEiYsXMAQuM9wnHngXKLZRWFHcgroF7URRzLPrMQUfALjbga6S+tGc3Tshv6PA6xeSqRPDbLG+X+0qt9crNzbaxGbStSCfYhdRY4t5BSVY9Pxl9trcYFiUdsV1BSwaZM5u8K+hUm8HV6PoLD/jlsRRzgUq6O+Qw3asFkTKm3clSTo8VtXdpTdzFAZP+tVvAjkfGq3MkSLyTYi08pvQ3h/L9o0JpUnnQeKxXk3qIsGGsH1BXzcZT+voCNv39FSdg6gNY51z9Cyq5Dql8wER5ylTwnLVeHlHAn/HNwxGYeUqrrc2gcmIybVKVD1XAPXjKks2+oHZk4OXYP6+LwVaFEApqEMyEusTgVFTzdjVa2BAaELvpyVhOSMW/ae3NwMfWId4Ue28z5IzumOF/CmY1GmXBOWBf2hgp/r3qS0GU7nGETmj+7Tudbjd1cKhgP39tVtWogjxHt6NLXz8OCbV1nIBG+mmrrZDCbH/o4Vgn3gZkRkq+iHOVW82LunJPXBZjX/ntmptWsqP8nDZBSb3TzAD4vSQeQ1GmtgGWAYfB951YKUnFVJb0z1YRjQqVksL5VpD4N/Vy31vtYY/2g9TmyMADPgCwwA6MhjQ9bd1JFJ3Vls7lD2RYjdIwQwhWzBRPfrxpKcYeu03F0/odRbEc9RZ11TxVY8mXqgJx/vDk0eF4MPV7lgBxYqxoGfEtGZBC1kZlxbcez4Ts4/TuXJ/QsfWT95Fwpc4CtiGCgU4i7LHgoDalqmBabvzV5xvq2pMVourJYZ4paytzilEG+lADOGx7qf9O5/4cP5SqyTCMG4I16I/6I5o4Y/QkWX9ctABry/8Adxz+ZB8AI1yUyNXk1Z073ECiDJ1EuVT69eIDEAlbnv24j4DJGeqIV1b1GDCHJ+OFD4W0gXUs/1bMkNESNKl2ON6DZzAXvqmr8X68yRDgIReKbX1SUwtzYnyadBLhEWS0WTE7T1IxC2SHChb1NFD+2rtJSN8OPTIZRqiizaoh7OSSNpBXJMkKcUQZV8sXw8VkU5ea8j0WZ/YK35loUxE1aG30SL/JYxZWlUenDyKrfbHWJ+z6JOsV0e1Xfw7VGavtHACLwn0tTG9e3lf++w1MCVjFIyU57uOlbTkUSnxAjzmA71qvjTzHeMDWcK099tm9rS8cnfuwxq+YRWANkfmLbCl+74mg4bccPsNY5zz7cjbaFAL0hAwId61yM5uqhMBr4Wcew3b2spG5tkKFOnADeXkGkH4vk+f+an92mWXemOFCpjRsFeEnPEAIsLemM3QfMoME5/w+7Y48y/SvkBN6/KSRVmB7/rHiW7iVkXF6Y1T853OaDg66cIfWkD5TqCDugrlaXlEL1fFjxPoKRHkP5GD/xDiscNH+Dp2fXEKUpwAvC8JTNC+k9JpaMXUB7oj4p77qiAOjXD2pT4v/v0Ukid02LpuYsS7/ScDL1SxB9hxxbkeGOMyPyL4HZPAbyagOgP5Xe2pCqMPyj/KJ0blDHzFVBqzeLIO5D4yq7IpSi9p/QlHa50sCHzGoMqrBS8l9IfRyhq8IDQtOZzjgdvgQDwH7cqa/sybwdfcQse9THS08maKkkgnOi0ShO8Gyf+WL4K9DX11CF9uIbVwJUaCv8r/6FDVOdsEjeumisIJlLJQsjjkEL2QfEc68oqsevnNAEdp4YMJivwBJnE0R2GiBFRTJZNkq/MHDP9O5unQoRoivMJkPm+A0K8CQNXL6V3apC4ROBTyJSW9oOGNF4YrwoTFyz/pexIkeWQADpi+M7q8gBlmGRUune0k7cXyacdbOsD0Q1JQat9T8nmHhyO8PNd2k4qjZsQCs6lEcmaThpVUzGzWOJQGGf2oz7+F/bMfUMARo1PD0/yIhVDK+8MGRo/uByG5UAwPfNeHAd09gkMFpZmTN2rZgoqdSjwv1SbFnFRAqYuzwW8P4+Rk9fE3PVu80HKcXyIEvPfit+o+pnlHDUKKo32HapcVtQhsNiIdH80j/lRnJ2y5RYRbECyY4vl20j/NiBAD0Z5jxWWiL6xAZIonSEJb1qhwmdRp3hISLL9Q1QYOt6C/OixU3eUtXblgBu+fGPAQE0o");
    var FENCED = /* @__PURE__ */ new Map([[8217, "apostrophe"], [8260, "fraction slash"], [12539, "middle dot"]]);
    var NSM_MAX = 4;
    function hex_cp(cp) {
      return cp.toString(16).toUpperCase().padStart(2, "0");
    }
    function quote_cp(cp) {
      return `{${hex_cp(cp)}}`;
    }
    function explode_cp(s) {
      let cps = [];
      for (let pos = 0, len = s.length; pos < len; ) {
        let cp = s.codePointAt(pos);
        pos += cp < 65536 ? 1 : 2;
        cps.push(cp);
      }
      return cps;
    }
    function str_from_cps(cps) {
      const chunk = 4096;
      let len = cps.length;
      if (len < chunk)
        return String.fromCodePoint(...cps);
      let buf = [];
      for (let i = 0; i < len; ) {
        buf.push(String.fromCodePoint(...cps.slice(i, i += chunk)));
      }
      return buf.join("");
    }
    function compare_arrays(a, b) {
      let n = a.length;
      let c = n - b.length;
      for (let i = 0; c == 0 && i < n; i++)
        c = a[i] - b[i];
      return c;
    }
    var r = read_compressed_payload("AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g");
    function unpack_cc(packed) {
      return packed >> 24 & 255;
    }
    function unpack_cp(packed) {
      return packed & 16777215;
    }
    var SHIFTED_RANK = new Map(read_sorted_arrays(r).flatMap((v, i) => v.map((x) => [x, i + 1 << 24])));
    var EXCLUSIONS = new Set(read_sorted(r));
    var DECOMP = /* @__PURE__ */ new Map();
    var RECOMP = /* @__PURE__ */ new Map();
    for (let [cp, cps] of read_mapped(r)) {
      if (!EXCLUSIONS.has(cp) && cps.length == 2) {
        let [a, b] = cps;
        let bucket = RECOMP.get(a);
        if (!bucket) {
          bucket = /* @__PURE__ */ new Map();
          RECOMP.set(a, bucket);
        }
        bucket.set(b, cp);
      }
      DECOMP.set(cp, cps.reverse());
    }
    var S0 = 44032;
    var L0 = 4352;
    var V0 = 4449;
    var T0 = 4519;
    var L_COUNT = 19;
    var V_COUNT = 21;
    var T_COUNT = 28;
    var N_COUNT = V_COUNT * T_COUNT;
    var S_COUNT = L_COUNT * N_COUNT;
    var S1 = S0 + S_COUNT;
    var L1 = L0 + L_COUNT;
    var V1 = V0 + V_COUNT;
    var T1 = T0 + T_COUNT;
    function is_hangul(cp) {
      return cp >= S0 && cp < S1;
    }
    function compose_pair(a, b) {
      if (a >= L0 && a < L1 && b >= V0 && b < V1) {
        return S0 + (a - L0) * N_COUNT + (b - V0) * T_COUNT;
      } else if (is_hangul(a) && b > T0 && b < T1 && (a - S0) % T_COUNT == 0) {
        return a + (b - T0);
      } else {
        let recomp = RECOMP.get(a);
        if (recomp) {
          recomp = recomp.get(b);
          if (recomp) {
            return recomp;
          }
        }
        return -1;
      }
    }
    function decomposed(cps) {
      let ret = [];
      let buf = [];
      let check_order = false;
      function add(cp) {
        let cc = SHIFTED_RANK.get(cp);
        if (cc) {
          check_order = true;
          cp |= cc;
        }
        ret.push(cp);
      }
      for (let cp of cps) {
        while (true) {
          if (cp < 128) {
            ret.push(cp);
          } else if (is_hangul(cp)) {
            let s_index = cp - S0;
            let l_index = s_index / N_COUNT | 0;
            let v_index = s_index % N_COUNT / T_COUNT | 0;
            let t_index = s_index % T_COUNT;
            add(L0 + l_index);
            add(V0 + v_index);
            if (t_index > 0)
              add(T0 + t_index);
          } else {
            let mapped = DECOMP.get(cp);
            if (mapped) {
              buf.push(...mapped);
            } else {
              add(cp);
            }
          }
          if (!buf.length)
            break;
          cp = buf.pop();
        }
      }
      if (check_order && ret.length > 1) {
        let prev_cc = unpack_cc(ret[0]);
        for (let i = 1; i < ret.length; i++) {
          let cc = unpack_cc(ret[i]);
          if (cc == 0 || prev_cc <= cc) {
            prev_cc = cc;
            continue;
          }
          let j = i - 1;
          while (true) {
            let tmp = ret[j + 1];
            ret[j + 1] = ret[j];
            ret[j] = tmp;
            if (!j)
              break;
            prev_cc = unpack_cc(ret[--j]);
            if (prev_cc <= cc)
              break;
          }
          prev_cc = unpack_cc(ret[i]);
        }
      }
      return ret;
    }
    function composed_from_decomposed(v) {
      let ret = [];
      let stack = [];
      let prev_cp = -1;
      let prev_cc = 0;
      for (let packed of v) {
        let cc = unpack_cc(packed);
        let cp = unpack_cp(packed);
        if (prev_cp == -1) {
          if (cc == 0) {
            prev_cp = cp;
          } else {
            ret.push(cp);
          }
        } else if (prev_cc > 0 && prev_cc >= cc) {
          if (cc == 0) {
            ret.push(prev_cp, ...stack);
            stack.length = 0;
            prev_cp = cp;
          } else {
            stack.push(cp);
          }
          prev_cc = cc;
        } else {
          let composed = compose_pair(prev_cp, cp);
          if (composed >= 0) {
            prev_cp = composed;
          } else if (prev_cc == 0 && cc == 0) {
            ret.push(prev_cp);
            prev_cp = cp;
          } else {
            stack.push(cp);
            prev_cc = cc;
          }
        }
      }
      if (prev_cp >= 0) {
        ret.push(prev_cp, ...stack);
      }
      return ret;
    }
    function nfd(cps) {
      return decomposed(cps).map(unpack_cp);
    }
    function nfc(cps) {
      return composed_from_decomposed(decomposed(cps));
    }
    var STOP = 46;
    var FE0F = 65039;
    var STOP_CH = ".";
    var UNIQUE_PH = 1;
    var HYPHEN = 45;
    function read_set() {
      return new Set(read_sorted(r$1));
    }
    var MAPPED = new Map(read_mapped(r$1));
    var IGNORED = read_set();
    var CM = read_set();
    var NSM = new Set(read_sorted(r$1).map(function(i) {
      return this[i];
    }, [...CM]));
    var ESCAPE = read_set();
    var NFC_CHECK = read_set();
    var CHUNKS = read_sorted_arrays(r$1);
    function read_chunked() {
      return new Set([read_sorted(r$1).map((i) => CHUNKS[i]), read_sorted(r$1)].flat(2));
    }
    var UNRESTRICTED = r$1();
    var GROUPS = read_array_while((i) => {
      let N = read_array_while(r$1).map((x) => x + 96);
      if (N.length) {
        let R = i >= UNRESTRICTED;
        N[0] -= 32;
        N = str_from_cps(N);
        if (R)
          N = `Restricted[${N}]`;
        let P = read_chunked();
        let Q = read_chunked();
        let V = [...P, ...Q].sort((a, b) => a - b);
        let M = !r$1();
        return { N, P, M, R, V: new Set(V) };
      }
    });
    var WHOLE_VALID = read_set();
    var WHOLE_MAP = /* @__PURE__ */ new Map();
    [...WHOLE_VALID, ...read_set()].sort((a, b) => a - b).map((cp, i, v) => {
      let d = r$1();
      let w = v[i] = d ? v[i - d] : { V: [], M: /* @__PURE__ */ new Map() };
      w.V.push(cp);
      if (!WHOLE_VALID.has(cp)) {
        WHOLE_MAP.set(cp, w);
      }
    });
    for (let { V, M } of new Set(WHOLE_MAP.values())) {
      let recs = [];
      for (let cp of V) {
        let gs = GROUPS.filter((g) => g.V.has(cp));
        let rec = recs.find(({ G }) => gs.some((g) => G.has(g)));
        if (!rec) {
          rec = { G: /* @__PURE__ */ new Set(), V: [] };
          recs.push(rec);
        }
        rec.V.push(cp);
        gs.forEach((g) => rec.G.add(g));
      }
      let union2 = recs.flatMap(({ G }) => [...G]);
      for (let { G, V: V2 } of recs) {
        let complement = new Set(union2.filter((g) => !G.has(g)));
        for (let cp of V2) {
          M.set(cp, complement);
        }
      }
    }
    var union = /* @__PURE__ */ new Set();
    var multi = /* @__PURE__ */ new Set();
    for (let g of GROUPS) {
      for (let cp of g.V) {
        (union.has(cp) ? multi : union).add(cp);
      }
    }
    for (let cp of union) {
      if (!WHOLE_MAP.has(cp) && !multi.has(cp)) {
        WHOLE_MAP.set(cp, UNIQUE_PH);
      }
    }
    var VALID = /* @__PURE__ */ new Set([...union, ...nfd(union)]);
    var Emoji = class extends Array {
      get is_emoji() {
        return true;
      }
      // free tagging system
    };
    var EMOJI_LIST = read_trie(r$1).map((v) => Emoji.from(v)).sort(compare_arrays);
    var EMOJI_ROOT = /* @__PURE__ */ new Map();
    for (let cps of EMOJI_LIST) {
      let prev = [EMOJI_ROOT];
      for (let cp of cps) {
        let next = prev.map((node) => {
          let child = node.get(cp);
          if (!child) {
            child = /* @__PURE__ */ new Map();
            node.set(cp, child);
          }
          return child;
        });
        if (cp === FE0F) {
          prev.push(...next);
        } else {
          prev = next;
        }
      }
      for (let x of prev) {
        x.V = cps;
      }
    }
    function safe_str_from_cps(cps, quoter = quote_cp) {
      let buf = [];
      if (is_combining_mark(cps[0]))
        buf.push("\u25CC");
      let prev = 0;
      let n = cps.length;
      for (let i = 0; i < n; i++) {
        let cp = cps[i];
        if (should_escape(cp)) {
          buf.push(str_from_cps(cps.slice(prev, i)));
          buf.push(quoter(cp));
          prev = i + 1;
        }
      }
      buf.push(str_from_cps(cps.slice(prev, n)));
      return buf.join("");
    }
    function quoted_cp(cp) {
      return (should_escape(cp) ? "" : `${bidi_qq(safe_str_from_cps([cp]))} `) + quote_cp(cp);
    }
    function bidi_qq(s) {
      return `"${s}"\u200E`;
    }
    function check_label_extension(cps) {
      if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {
        throw new Error(`invalid label extension: "${str_from_cps(cps.slice(0, 4))}"`);
      }
    }
    function check_leading_underscore(cps) {
      const UNDERSCORE = 95;
      for (let i = cps.lastIndexOf(UNDERSCORE); i > 0; ) {
        if (cps[--i] !== UNDERSCORE) {
          throw new Error("underscore allowed only at start");
        }
      }
    }
    function check_fenced(cps) {
      let cp = cps[0];
      let prev = FENCED.get(cp);
      if (prev)
        throw error_placement(`leading ${prev}`);
      let n = cps.length;
      let last = -1;
      for (let i = 1; i < n; i++) {
        cp = cps[i];
        let match = FENCED.get(cp);
        if (match) {
          if (last == i)
            throw error_placement(`${prev} + ${match}`);
          last = i + 1;
          prev = match;
        }
      }
      if (last == n)
        throw error_placement(`trailing ${prev}`);
    }
    function is_combining_mark(cp) {
      return CM.has(cp);
    }
    function should_escape(cp) {
      return ESCAPE.has(cp);
    }
    function ens_emoji() {
      return EMOJI_LIST.map((x) => x.slice());
    }
    function ens_normalize_fragment(frag, decompose) {
      let nf = decompose ? nfd : nfc;
      return frag.split(STOP_CH).map((label) => str_from_cps(process2(explode_cp(label), nf, filter_fe0f).flat())).join(STOP_CH);
    }
    function ens_normalize(name) {
      return flatten(split(name, nfc, filter_fe0f));
    }
    function ens_beautify(name) {
      let labels = split(name, nfc, (x) => x);
      for (let { type, output, error } of labels) {
        if (error)
          break;
        if (type !== "Greek") {
          let prev = 0;
          while (true) {
            let next = output.indexOf(958, prev);
            if (next < 0)
              break;
            output[next] = 926;
            prev = next + 1;
          }
        }
      }
      return flatten(labels);
    }
    function ens_split(name, preserve_emoji) {
      return split(name, nfc, preserve_emoji ? (x) => x.slice() : filter_fe0f);
    }
    function split(name, nf, ef) {
      if (!name)
        return [];
      let offset = 0;
      return name.split(STOP_CH).map((label) => {
        let input = explode_cp(label);
        let info = {
          input,
          offset
          // codepoint, not substring!
        };
        offset += input.length + 1;
        let norm;
        try {
          let tokens = info.tokens = process2(input, nf, ef);
          let token_count = tokens.length;
          let type;
          if (!token_count) {
            throw new Error(`empty label`);
          } else {
            norm = tokens.flat();
            check_leading_underscore(norm);
            let emoji = info.emoji = token_count > 1 || tokens[0].is_emoji;
            if (!emoji && norm.every((cp) => cp < 128)) {
              check_label_extension(norm);
              type = "ASCII";
            } else {
              let chars = tokens.flatMap((x) => x.is_emoji ? [] : x);
              if (!chars.length) {
                type = "Emoji";
              } else {
                if (CM.has(norm[0]))
                  throw error_placement("leading combining mark");
                for (let i = 1; i < token_count; i++) {
                  let cps = tokens[i];
                  if (!cps.is_emoji && CM.has(cps[0])) {
                    throw error_placement(`emoji + combining mark: "${str_from_cps(tokens[i - 1])} + ${safe_str_from_cps([cps[0]])}"`);
                  }
                }
                check_fenced(norm);
                let unique = [...new Set(chars)];
                let [g] = determine_group(unique);
                check_group(g, chars);
                check_whole(g, unique);
                type = g.N;
              }
            }
          }
          info.type = type;
        } catch (err) {
          info.error = err;
        }
        info.output = norm;
        return info;
      });
    }
    function check_whole(group, unique) {
      let maker;
      let shared = [];
      for (let cp of unique) {
        let whole = WHOLE_MAP.get(cp);
        if (whole === UNIQUE_PH)
          return;
        if (whole) {
          let set = whole.M.get(cp);
          maker = maker ? maker.filter((g) => set.has(g)) : [...set];
          if (!maker.length)
            return;
        } else {
          shared.push(cp);
        }
      }
      if (maker) {
        for (let g of maker) {
          if (shared.every((cp) => g.V.has(cp))) {
            throw new Error(`whole-script confusable: ${group.N}/${g.N}`);
          }
        }
      }
    }
    function determine_group(unique) {
      let groups = GROUPS;
      for (let cp of unique) {
        let gs = groups.filter((g) => g.V.has(cp));
        if (!gs.length) {
          if (!GROUPS.some((g) => g.V.has(cp))) {
            throw error_disallowed(cp);
          } else {
            throw error_group_member(groups[0], cp);
          }
        }
        groups = gs;
        if (gs.length == 1)
          break;
      }
      return groups;
    }
    function flatten(split2) {
      return split2.map(({ input, error, output }) => {
        if (error) {
          let msg = error.message;
          throw new Error(split2.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input))}: ${msg}`);
        }
        return str_from_cps(output);
      }).join(STOP_CH);
    }
    function error_disallowed(cp) {
      return new Error(`disallowed character: ${quoted_cp(cp)}`);
    }
    function error_group_member(g, cp) {
      let quoted = quoted_cp(cp);
      let gg = GROUPS.find((g2) => g2.P.has(cp));
      if (gg) {
        quoted = `${gg.N} ${quoted}`;
      }
      return new Error(`illegal mixture: ${g.N} + ${quoted}`);
    }
    function error_placement(where) {
      return new Error(`illegal placement: ${where}`);
    }
    function check_group(g, cps) {
      let { V, M } = g;
      for (let cp of cps) {
        if (!V.has(cp)) {
          throw error_group_member(g, cp);
        }
      }
      if (M) {
        let decomposed2 = nfd(cps);
        for (let i = 1, e = decomposed2.length; i < e; i++) {
          if (NSM.has(decomposed2[i])) {
            let j = i + 1;
            for (let cp; j < e && NSM.has(cp = decomposed2[j]); j++) {
              for (let k = i; k < j; k++) {
                if (decomposed2[k] == cp) {
                  throw new Error(`duplicate non-spacing marks: ${quoted_cp(cp)}`);
                }
              }
            }
            if (j - i > NSM_MAX) {
              throw new Error(`excessive non-spacing marks: ${bidi_qq(safe_str_from_cps(decomposed2.slice(i - 1, j)))} (${j - i}/${NSM_MAX})`);
            }
            i = j;
          }
        }
      }
    }
    function process2(input, nf, ef) {
      let ret = [];
      let chars = [];
      input = input.slice().reverse();
      while (input.length) {
        let emoji = consume_emoji_reversed(input);
        if (emoji) {
          if (chars.length) {
            ret.push(nf(chars));
            chars = [];
          }
          ret.push(ef(emoji));
        } else {
          let cp = input.pop();
          if (VALID.has(cp)) {
            chars.push(cp);
          } else {
            let cps = MAPPED.get(cp);
            if (cps) {
              chars.push(...cps);
            } else if (!IGNORED.has(cp)) {
              throw error_disallowed(cp);
            }
          }
        }
      }
      if (chars.length) {
        ret.push(nf(chars));
      }
      return ret;
    }
    function filter_fe0f(cps) {
      return cps.filter((cp) => cp != FE0F);
    }
    function consume_emoji_reversed(cps, eaten) {
      let node = EMOJI_ROOT;
      let emoji;
      let pos = cps.length;
      while (pos) {
        node = node.get(cps[--pos]);
        if (!node)
          break;
        let { V } = node;
        if (V) {
          emoji = V;
          if (eaten)
            eaten.push(...cps.slice(pos).reverse());
          cps.length = pos;
        }
      }
      return emoji;
    }
    var TY_VALID = "valid";
    var TY_MAPPED = "mapped";
    var TY_IGNORED = "ignored";
    var TY_DISALLOWED = "disallowed";
    var TY_EMOJI = "emoji";
    var TY_NFC = "nfc";
    var TY_STOP = "stop";
    function ens_tokenize(name, {
      nf = true
      // collapse unnormalized runs into a single token
    } = {}) {
      let input = explode_cp(name).reverse();
      let eaten = [];
      let tokens = [];
      while (input.length) {
        let emoji = consume_emoji_reversed(input, eaten);
        if (emoji) {
          tokens.push({
            type: TY_EMOJI,
            emoji: emoji.slice(),
            // copy emoji
            input: eaten,
            cps: filter_fe0f(emoji)
          });
          eaten = [];
        } else {
          let cp = input.pop();
          if (cp == STOP) {
            tokens.push({ type: TY_STOP, cp });
          } else if (VALID.has(cp)) {
            tokens.push({ type: TY_VALID, cps: [cp] });
          } else if (IGNORED.has(cp)) {
            tokens.push({ type: TY_IGNORED, cp });
          } else {
            let cps = MAPPED.get(cp);
            if (cps) {
              tokens.push({ type: TY_MAPPED, cp, cps: cps.slice() });
            } else {
              tokens.push({ type: TY_DISALLOWED, cp });
            }
          }
        }
      }
      if (nf) {
        for (let i = 0, start = -1; i < tokens.length; i++) {
          let token = tokens[i];
          if (is_valid_or_mapped(token.type)) {
            if (requires_check(token.cps)) {
              let end = i + 1;
              for (let pos = end; pos < tokens.length; pos++) {
                let { type, cps: cps2 } = tokens[pos];
                if (is_valid_or_mapped(type)) {
                  if (!requires_check(cps2))
                    break;
                  end = pos + 1;
                } else if (type !== TY_IGNORED) {
                  break;
                }
              }
              if (start < 0)
                start = i;
              let slice = tokens.slice(start, end);
              let cps0 = slice.flatMap((x) => is_valid_or_mapped(x.type) ? x.cps : []);
              let cps = nfc(cps0);
              if (compare_arrays(cps, cps0)) {
                tokens.splice(start, end - start, {
                  type: TY_NFC,
                  input: cps0,
                  // there are 3 states: tokens0 ==(process)=> input ==(nfc)=> tokens/cps
                  cps,
                  tokens0: collapse_valid_tokens(slice),
                  tokens: ens_tokenize(str_from_cps(cps), { nf: false })
                });
                i = start;
              } else {
                i = end - 1;
              }
              start = -1;
            } else {
              start = i;
            }
          } else if (token.type !== TY_IGNORED) {
            start = -1;
          }
        }
      }
      return collapse_valid_tokens(tokens);
    }
    function is_valid_or_mapped(type) {
      return type == TY_VALID || type == TY_MAPPED;
    }
    function requires_check(cps) {
      return cps.some((cp) => NFC_CHECK.has(cp));
    }
    function collapse_valid_tokens(tokens) {
      for (let i = 0; i < tokens.length; i++) {
        if (tokens[i].type == TY_VALID) {
          let j = i + 1;
          while (j < tokens.length && tokens[j].type == TY_VALID)
            j++;
          tokens.splice(i, j - i, { type: TY_VALID, cps: tokens.slice(i, j).flatMap((x) => x.cps) });
        }
      }
      return tokens;
    }
    exports.ens_beautify = ens_beautify;
    exports.ens_emoji = ens_emoji;
    exports.ens_normalize = ens_normalize;
    exports.ens_normalize_fragment = ens_normalize_fragment;
    exports.ens_split = ens_split;
    exports.ens_tokenize = ens_tokenize;
    exports.is_combining_mark = is_combining_mark;
    exports.nfc = nfc;
    exports.nfd = nfd;
    exports.safe_str_from_cps = safe_str_from_cps;
    exports.should_escape = should_escape;
  }
});

// node_modules/viem/_cjs/utils/ens/normalize.js
var require_normalize = __commonJS({
  "node_modules/viem/_cjs/utils/ens/normalize.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.normalize = void 0;
    var ens_normalize_1 = require_dist2();
    function normalize(name) {
      return (0, ens_normalize_1.ens_normalize)(name);
    }
    exports.normalize = normalize;
  }
});

// node_modules/viem/_cjs/ens/index.js
var require_ens2 = __commonJS({
  "node_modules/viem/_cjs/ens/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.namehash = exports.labelhash = exports.getEnsText = exports.getEnsResolver = exports.getEnsName = exports.getEnsAvatar = exports.getEnsAddress = exports.normalize = void 0;
    var normalize_js_1 = require_normalize();
    Object.defineProperty(exports, "normalize", { enumerable: true, get: function() {
      return normalize_js_1.normalize;
    } });
    var getEnsAddress_js_1 = require_getEnsAddress();
    Object.defineProperty(exports, "getEnsAddress", { enumerable: true, get: function() {
      return getEnsAddress_js_1.getEnsAddress;
    } });
    var getEnsAvatar_js_1 = require_getEnsAvatar();
    Object.defineProperty(exports, "getEnsAvatar", { enumerable: true, get: function() {
      return getEnsAvatar_js_1.getEnsAvatar;
    } });
    var getEnsName_js_1 = require_getEnsName();
    Object.defineProperty(exports, "getEnsName", { enumerable: true, get: function() {
      return getEnsName_js_1.getEnsName;
    } });
    var getEnsResolver_js_1 = require_getEnsResolver();
    Object.defineProperty(exports, "getEnsResolver", { enumerable: true, get: function() {
      return getEnsResolver_js_1.getEnsResolver;
    } });
    var getEnsText_js_1 = require_getEnsText();
    Object.defineProperty(exports, "getEnsText", { enumerable: true, get: function() {
      return getEnsText_js_1.getEnsText;
    } });
    var labelhash_js_1 = require_labelhash();
    Object.defineProperty(exports, "labelhash", { enumerable: true, get: function() {
      return labelhash_js_1.labelhash;
    } });
    var namehash_js_1 = require_namehash();
    Object.defineProperty(exports, "namehash", { enumerable: true, get: function() {
      return namehash_js_1.namehash;
    } });
  }
});

// node_modules/@wagmi/core/dist/chunk-LAFZBYO7.js
var require_chunk_LAFZBYO7 = __commonJS({
  "node_modules/@wagmi/core/dist/chunk-LAFZBYO7.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _nullishCoalesce(lhs, rhsFn) {
      if (lhs != null) {
        return lhs;
      } else {
        return rhsFn();
      }
    }
    async function _asyncNullishCoalesce(lhs, rhsFn) {
      if (lhs != null) {
        return lhs;
      } else {
        return await rhsFn();
      }
    }
    function _optionalChain(ops) {
      let lastAccessLHS = void 0;
      let value = ops[0];
      let i = 1;
      while (i < ops.length) {
        const op = ops[i];
        const fn = ops[i + 1];
        i += 2;
        if ((op === "optionalAccess" || op === "optionalCall") && value == null) {
          return void 0;
        }
        if (op === "access" || op === "optionalAccess") {
          lastAccessLHS = value;
          value = fn(value);
        } else if (op === "call" || op === "optionalCall") {
          value = fn((...args) => value.call(lastAccessLHS, ...args));
          lastAccessLHS = void 0;
        }
      }
      return value;
    }
    var _chunkBVC4KGLQjs = require_chunk_BVC4KGLQ();
    var _chunkMQXBDTVKjs = require_chunk_MQXBDTVK();
    var _viem = require_cjs2();
    function configureChains(defaultChains, providers, {
      batch = { multicall: { wait: 32 } },
      pollingInterval = 4e3,
      rank,
      retryCount,
      retryDelay,
      stallTimeout
    } = {}) {
      if (!defaultChains.length)
        throw new Error("must have at least one chain");
      let chains = [];
      const httpUrls = {};
      const wsUrls = {};
      for (const chain of defaultChains) {
        let configExists = false;
        for (const provider of providers) {
          const apiConfig = provider(chain);
          if (!apiConfig)
            continue;
          configExists = true;
          if (!chains.some(({ id }) => id === chain.id)) {
            chains = [...chains, apiConfig.chain];
          }
          httpUrls[chain.id] = [
            ...httpUrls[chain.id] || [],
            ...apiConfig.rpcUrls.http
          ];
          if (apiConfig.rpcUrls.webSocket) {
            wsUrls[chain.id] = [
              ...wsUrls[chain.id] || [],
              ...apiConfig.rpcUrls.webSocket
            ];
          }
        }
        if (!configExists) {
          throw new Error(
            [
              `Could not find valid provider configuration for chain "${chain.name}".
`,
              "You may need to add `jsonRpcProvider` to `configureChains` with the chain's RPC URLs.",
              "Read more: https://wagmi.sh/core/providers/jsonRpc"
            ].join("\n")
          );
        }
      }
      return {
        chains,
        publicClient: ({ chainId }) => {
          const activeChain = _nullishCoalesce(chains.find((x) => x.id === chainId), () => defaultChains[0]);
          const chainHttpUrls = httpUrls[activeChain.id];
          if (!chainHttpUrls || !chainHttpUrls[0])
            throw new Error(`No providers configured for chain "${activeChain.id}"`);
          const publicClient = _viem.createPublicClient.call(void 0, {
            batch,
            chain: activeChain,
            transport: _viem.fallback.call(
              void 0,
              chainHttpUrls.map((url) => _viem.http.call(void 0, url, { timeout: stallTimeout })),
              { rank, retryCount, retryDelay }
            ),
            pollingInterval
          });
          return Object.assign(publicClient, {
            chains
          });
        },
        webSocketPublicClient: ({ chainId }) => {
          const activeChain = _nullishCoalesce(chains.find((x) => x.id === chainId), () => defaultChains[0]);
          const chainWsUrls = wsUrls[activeChain.id];
          if (!chainWsUrls || !chainWsUrls[0])
            return void 0;
          const publicClient = _viem.createPublicClient.call(void 0, {
            batch,
            chain: activeChain,
            transport: _viem.fallback.call(
              void 0,
              chainWsUrls.map((url) => _viem.webSocket.call(void 0, url, { timeout: stallTimeout })),
              { rank, retryCount, retryDelay }
            ),
            pollingInterval
          });
          return Object.assign(publicClient, {
            chains
          });
        }
      };
    }
    var _connectors = require_dist();
    var ChainMismatchError = class extends Error {
      constructor({
        activeChain,
        targetChain
      }) {
        super(
          `Chain mismatch: Expected "${targetChain}", received "${activeChain}".`
        );
        this.name = "ChainMismatchError";
      }
    };
    var ChainNotConfiguredError = class extends Error {
      constructor({
        chainId,
        connectorId
      }) {
        super(
          `Chain "${chainId}" not configured${connectorId ? ` for connector "${connectorId}"` : ""}.`
        );
        this.name = "ChainNotConfigured";
      }
    };
    var ConnectorAlreadyConnectedError = class extends Error {
      constructor() {
        super(...arguments);
        this.name = "ConnectorAlreadyConnectedError";
        this.message = "Connector already connected";
      }
    };
    var ConfigChainsNotFound = class extends Error {
      constructor() {
        super(...arguments);
        this.name = "ConfigChainsNotFound";
        this.message = "No chains were found on the wagmi config. Some functions that require a chain may not work.";
      }
    };
    var SwitchChainNotSupportedError = class extends Error {
      constructor({ connector }) {
        super(`"${connector.name}" does not support programmatic chain switching.`);
        this.name = "SwitchChainNotSupportedError";
      }
    };
    function deepEqual(a, b) {
      if (a === b)
        return true;
      if (a && b && typeof a === "object" && typeof b === "object") {
        if (a.constructor !== b.constructor)
          return false;
        let length;
        let i;
        if (Array.isArray(a) && Array.isArray(b)) {
          length = a.length;
          if (length != b.length)
            return false;
          for (i = length; i-- !== 0; )
            if (!deepEqual(a[i], b[i]))
              return false;
          return true;
        }
        if (a.valueOf !== Object.prototype.valueOf)
          return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString)
          return a.toString() === b.toString();
        const keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length)
          return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
            return false;
        for (i = length; i-- !== 0; ) {
          const key = keys[i];
          if (key && !deepEqual(a[key], b[key]))
            return false;
        }
        return true;
      }
      return a !== a && b !== b;
    }
    var findAndReplace = (cacheRef, {
      find,
      replace
    }) => {
      if (cacheRef && find(cacheRef)) {
        return replace(cacheRef);
      }
      if (typeof cacheRef !== "object") {
        return cacheRef;
      }
      if (Array.isArray(cacheRef)) {
        return cacheRef.map((item) => findAndReplace(item, { find, replace }));
      }
      if (cacheRef instanceof Object) {
        return Object.entries(cacheRef).reduce(
          (curr, [key, value]) => ({
            ...curr,
            [key]: findAndReplace(value, { find, replace })
          }),
          {}
        );
      }
      return cacheRef;
    };
    function deserialize(cachedString) {
      const cache = JSON.parse(cachedString);
      const deserializedCacheWithBigInts = findAndReplace(cache, {
        find: (data) => typeof data === "string" && data.startsWith("#bigint."),
        replace: (data) => BigInt(data.replace("#bigint.", ""))
      });
      return deserializedCacheWithBigInts;
    }
    function getCallParameters(args) {
      return {
        accessList: args.accessList,
        account: args.account,
        blockNumber: args.blockNumber,
        blockTag: args.blockTag,
        data: args.data,
        gas: args.gas,
        gasPrice: args.gasPrice,
        maxFeePerGas: args.maxFeePerGas,
        maxPriorityFeePerGas: args.maxPriorityFeePerGas,
        nonce: args.nonce,
        to: args.to,
        value: args.value
      };
    }
    function getSendTransactionParameters(args) {
      return {
        accessList: args.accessList,
        account: args.account,
        data: args.data,
        gas: args.gas,
        gasPrice: args.gasPrice,
        maxFeePerGas: args.maxFeePerGas,
        maxPriorityFeePerGas: args.maxPriorityFeePerGas,
        nonce: args.nonce,
        to: args.to,
        value: args.value
      };
    }
    function getUnit(unit) {
      if (typeof unit === "number")
        return unit;
      if (unit === "wei")
        return 0;
      return Math.abs(_viem.weiUnits[unit]);
    }
    function getReferenceKey(keys, cutoff) {
      return keys.slice(0, cutoff).join(".") || ".";
    }
    function getCutoff(array, value) {
      const { length } = array;
      for (let index = 0; index < length; ++index) {
        if (array[index] === value) {
          return index + 1;
        }
      }
      return 0;
    }
    function createReplacer(replacer, circularReplacer) {
      const hasReplacer = typeof replacer === "function";
      const hasCircularReplacer = typeof circularReplacer === "function";
      const cache = [];
      const keys = [];
      return function replace(key, value) {
        if (typeof value === "object") {
          if (cache.length) {
            const thisCutoff = getCutoff(cache, this);
            if (thisCutoff === 0) {
              cache[cache.length] = this;
            } else {
              cache.splice(thisCutoff);
              keys.splice(thisCutoff);
            }
            keys[keys.length] = key;
            const valueCutoff = getCutoff(cache, value);
            if (valueCutoff !== 0) {
              return hasCircularReplacer ? circularReplacer.call(
                this,
                key,
                value,
                getReferenceKey(keys, valueCutoff)
              ) : `[ref=${getReferenceKey(keys, valueCutoff)}]`;
            }
          } else {
            cache[0] = value;
            keys[0] = key;
          }
        }
        return hasReplacer ? replacer.call(this, key, value) : value;
      };
    }
    function serialize(value, replacer, indent, circularReplacer) {
      return JSON.stringify(
        value,
        createReplacer((key, value_) => {
          const value2 = typeof value_ === "bigint" ? `#bigint.${value_.toString()}` : value_;
          return _optionalChain([replacer, "optionalCall", (_2) => _2(key, value2)]) || value2;
        }, circularReplacer),
        _nullishCoalesce(indent, () => void 0)
      );
    }
    var _middleware = (init_middleware(), __toCommonJS(middleware_exports));
    var _vanilla = (init_vanilla(), __toCommonJS(vanilla_exports));
    var noopStorage = {
      getItem: (_key) => "",
      setItem: (_key, _value) => null,
      removeItem: (_key) => null
    };
    function createStorage({
      deserialize: deserialize2 = deserialize,
      key: prefix = "wagmi",
      serialize: serialize2 = serialize,
      storage
    }) {
      return {
        ...storage,
        getItem: (key, defaultState = null) => {
          const value = storage.getItem(`${prefix}.${key}`);
          try {
            return value ? deserialize2(value) : defaultState;
          } catch (error) {
            console.warn(error);
            return defaultState;
          }
        },
        setItem: (key, value) => {
          if (value === null) {
            storage.removeItem(`${prefix}.${key}`);
          } else {
            try {
              storage.setItem(`${prefix}.${key}`, serialize2(value));
            } catch (err) {
              console.error(err);
            }
          }
        },
        removeItem: (key) => storage.removeItem(`${prefix}.${key}`)
      };
    }
    var storeKey = "store";
    var _isAutoConnecting;
    var _lastUsedConnector;
    var _addEffects;
    var addEffects_fn;
    var Config = class {
      constructor({
        autoConnect = false,
        connectors = [new (0, _chunkBVC4KGLQjs.InjectedConnector)()],
        publicClient,
        storage = createStorage({
          storage: typeof window !== "undefined" ? window.localStorage : noopStorage
        }),
        logger = {
          warn: console.warn
        },
        webSocketPublicClient
      }) {
        _chunkMQXBDTVKjs.__privateAdd.call(void 0, this, _addEffects);
        this.publicClients = /* @__PURE__ */ new Map();
        this.webSocketPublicClients = /* @__PURE__ */ new Map();
        _chunkMQXBDTVKjs.__privateAdd.call(void 0, this, _isAutoConnecting, void 0);
        _chunkMQXBDTVKjs.__privateAdd.call(void 0, this, _lastUsedConnector, void 0);
        this.args = {
          autoConnect,
          connectors,
          logger,
          publicClient,
          storage,
          webSocketPublicClient
        };
        let status = "disconnected";
        let chainId;
        if (autoConnect) {
          try {
            const rawState = storage.getItem(storeKey);
            const data = _optionalChain([rawState, "optionalAccess", (_3) => _3.state, "optionalAccess", (_4) => _4.data]);
            status = _optionalChain([data, "optionalAccess", (_5) => _5.account]) ? "reconnecting" : "connecting";
            chainId = _optionalChain([data, "optionalAccess", (_6) => _6.chain, "optionalAccess", (_7) => _7.id]);
          } catch (_error) {
          }
        }
        const connectors_ = typeof connectors === "function" ? connectors() : connectors;
        connectors_.forEach((connector) => connector.setStorage(storage));
        this.store = _vanilla.createStore.call(
          void 0,
          _middleware.subscribeWithSelector.call(
            void 0,
            _middleware.persist.call(
              void 0,
              () => ({
                connectors: connectors_,
                publicClient: this.getPublicClient({ chainId }),
                status,
                webSocketPublicClient: this.getWebSocketPublicClient({ chainId })
              }),
              {
                name: storeKey,
                storage,
                partialize: (state) => ({
                  ...autoConnect && {
                    data: {
                      account: _optionalChain([state, "optionalAccess", (_8) => _8.data, "optionalAccess", (_9) => _9.account]),
                      chain: _optionalChain([state, "optionalAccess", (_10) => _10.data, "optionalAccess", (_11) => _11.chain])
                    }
                  },
                  chains: _optionalChain([state, "optionalAccess", (_12) => _12.chains])
                }),
                version: 2
              }
            )
          )
        );
        this.storage = storage;
        _chunkMQXBDTVKjs.__privateSet.call(void 0, this, _lastUsedConnector, _optionalChain([storage, "optionalAccess", (_13) => _13.getItem, "call", (_14) => _14("wallet")]));
        _chunkMQXBDTVKjs.__privateMethod.call(void 0, this, _addEffects, addEffects_fn).call(this);
        if (autoConnect && typeof window !== "undefined")
          setTimeout(async () => await this.autoConnect(), 0);
      }
      get chains() {
        return this.store.getState().chains;
      }
      get connectors() {
        return this.store.getState().connectors;
      }
      get connector() {
        return this.store.getState().connector;
      }
      get data() {
        return this.store.getState().data;
      }
      get error() {
        return this.store.getState().error;
      }
      get lastUsedChainId() {
        return _optionalChain([this, "access", (_15) => _15.data, "optionalAccess", (_16) => _16.chain, "optionalAccess", (_17) => _17.id]);
      }
      get publicClient() {
        return this.store.getState().publicClient;
      }
      get status() {
        return this.store.getState().status;
      }
      get subscribe() {
        return this.store.subscribe;
      }
      get webSocketPublicClient() {
        return this.store.getState().webSocketPublicClient;
      }
      setState(updater) {
        const newState = typeof updater === "function" ? updater(this.store.getState()) : updater;
        this.store.setState(newState, true);
      }
      clearState() {
        this.setState((x) => ({
          ...x,
          chains: void 0,
          connector: void 0,
          data: void 0,
          error: void 0,
          status: "disconnected"
        }));
      }
      async destroy() {
        if (this.connector)
          await _optionalChain([this, "access", (_18) => _18.connector, "access", (_19) => _19.disconnect, "optionalCall", (_20) => _20()]);
        _chunkMQXBDTVKjs.__privateSet.call(void 0, this, _isAutoConnecting, false);
        this.clearState();
        this.store.destroy();
      }
      async autoConnect() {
        if (_chunkMQXBDTVKjs.__privateGet.call(void 0, this, _isAutoConnecting))
          return;
        _chunkMQXBDTVKjs.__privateSet.call(void 0, this, _isAutoConnecting, true);
        this.setState((x) => ({
          ...x,
          status: _optionalChain([x, "access", (_21) => _21.data, "optionalAccess", (_22) => _22.account]) ? "reconnecting" : "connecting"
        }));
        const sorted = _chunkMQXBDTVKjs.__privateGet.call(void 0, this, _lastUsedConnector) ? [...this.connectors].sort(
          (x) => x.id === _chunkMQXBDTVKjs.__privateGet.call(void 0, this, _lastUsedConnector) ? -1 : 1
        ) : this.connectors;
        let connected = false;
        for (const connector of sorted) {
          if (!connector.ready || !connector.isAuthorized)
            continue;
          const isAuthorized = await connector.isAuthorized();
          if (!isAuthorized)
            continue;
          const data = await connector.connect();
          this.setState((x) => ({
            ...x,
            connector,
            chains: _optionalChain([connector, "optionalAccess", (_23) => _23.chains]),
            data,
            status: "connected"
          }));
          connected = true;
          break;
        }
        if (!connected)
          this.setState((x) => ({
            ...x,
            data: void 0,
            status: "disconnected"
          }));
        _chunkMQXBDTVKjs.__privateSet.call(void 0, this, _isAutoConnecting, false);
        return this.data;
      }
      setConnectors(connectors) {
        this.args = {
          ...this.args,
          connectors
        };
        const connectors_ = typeof connectors === "function" ? connectors() : connectors;
        connectors_.forEach((connector) => connector.setStorage(this.args.storage));
        this.setState((x) => ({
          ...x,
          connectors: connectors_
        }));
      }
      getPublicClient({ chainId } = {}) {
        let publicClient_ = this.publicClients.get(-1);
        if (publicClient_ && _optionalChain([publicClient_, "optionalAccess", (_24) => _24.chain, "access", (_25) => _25.id]) === chainId)
          return publicClient_;
        publicClient_ = this.publicClients.get(_nullishCoalesce(chainId, () => -1));
        if (publicClient_)
          return publicClient_;
        const { publicClient } = this.args;
        publicClient_ = typeof publicClient === "function" ? publicClient({ chainId }) : publicClient;
        this.publicClients.set(_nullishCoalesce(chainId, () => -1), publicClient_);
        return publicClient_;
      }
      setPublicClient(publicClient) {
        const chainId = _optionalChain([this, "access", (_26) => _26.data, "optionalAccess", (_27) => _27.chain, "optionalAccess", (_28) => _28.id]);
        this.args = {
          ...this.args,
          publicClient
        };
        this.publicClients.clear();
        this.setState((x) => ({
          ...x,
          publicClient: this.getPublicClient({ chainId })
        }));
      }
      getWebSocketPublicClient({ chainId } = {}) {
        let webSocketPublicClient_ = this.webSocketPublicClients.get(-1);
        if (webSocketPublicClient_ && _optionalChain([webSocketPublicClient_, "optionalAccess", (_29) => _29.chain, "access", (_30) => _30.id]) === chainId)
          return webSocketPublicClient_;
        webSocketPublicClient_ = this.webSocketPublicClients.get(_nullishCoalesce(chainId, () => -1));
        if (webSocketPublicClient_)
          return webSocketPublicClient_;
        const { webSocketPublicClient } = this.args;
        webSocketPublicClient_ = typeof webSocketPublicClient === "function" ? webSocketPublicClient({ chainId }) : webSocketPublicClient;
        if (webSocketPublicClient_)
          this.webSocketPublicClients.set(_nullishCoalesce(chainId, () => -1), webSocketPublicClient_);
        return webSocketPublicClient_;
      }
      setWebSocketPublicClient(webSocketPublicClient) {
        const chainId = _optionalChain([this, "access", (_31) => _31.data, "optionalAccess", (_32) => _32.chain, "optionalAccess", (_33) => _33.id]);
        this.args = {
          ...this.args,
          webSocketPublicClient
        };
        this.webSocketPublicClients.clear();
        this.setState((x) => ({
          ...x,
          webSocketPublicClient: this.getWebSocketPublicClient({
            chainId
          })
        }));
      }
      setLastUsedConnector(lastUsedConnector = null) {
        _optionalChain([this, "access", (_34) => _34.storage, "optionalAccess", (_35) => _35.setItem, "call", (_36) => _36("wallet", lastUsedConnector)]);
      }
    };
    _isAutoConnecting = /* @__PURE__ */ new WeakMap();
    _lastUsedConnector = /* @__PURE__ */ new WeakMap();
    _addEffects = /* @__PURE__ */ new WeakSet();
    addEffects_fn = function() {
      const onChange = (data) => {
        this.setState((x) => ({
          ...x,
          data: { ...x.data, ...data }
        }));
      };
      const onDisconnect = () => {
        this.clearState();
      };
      const onError = (error) => {
        this.setState((x) => ({ ...x, error }));
      };
      this.store.subscribe(
        ({ connector }) => connector,
        (connector, prevConnector) => {
          _optionalChain([prevConnector, "optionalAccess", (_37) => _37.off, "optionalCall", (_38) => _38("change", onChange)]);
          _optionalChain([prevConnector, "optionalAccess", (_39) => _39.off, "optionalCall", (_40) => _40("disconnect", onDisconnect)]);
          _optionalChain([prevConnector, "optionalAccess", (_41) => _41.off, "optionalCall", (_42) => _42("error", onError)]);
          if (!connector)
            return;
          _optionalChain([connector, "access", (_43) => _43.on, "optionalCall", (_44) => _44("change", onChange)]);
          _optionalChain([connector, "access", (_45) => _45.on, "optionalCall", (_46) => _46("disconnect", onDisconnect)]);
          _optionalChain([connector, "access", (_47) => _47.on, "optionalCall", (_48) => _48("error", onError)]);
        }
      );
      const { publicClient, webSocketPublicClient } = this.args;
      const subscribePublicClient = typeof publicClient === "function";
      const subscribeWebSocketPublicClient = typeof webSocketPublicClient === "function";
      if (subscribePublicClient || subscribeWebSocketPublicClient)
        this.store.subscribe(
          ({ data }) => _optionalChain([data, "optionalAccess", (_49) => _49.chain, "optionalAccess", (_50) => _50.id]),
          (chainId) => {
            this.setState((x) => ({
              ...x,
              publicClient: this.getPublicClient({ chainId }),
              webSocketPublicClient: this.getWebSocketPublicClient({
                chainId
              })
            }));
          }
        );
    };
    var config;
    function createConfig(args) {
      const config_ = new Config(args);
      config = config_;
      return config_;
    }
    function getConfig() {
      if (!config) {
        throw new Error(
          "No wagmi config found. Ensure you have set up a config: https://wagmi.sh/react/config"
        );
      }
      return config;
    }
    async function connect({ chainId, connector }) {
      const config2 = getConfig();
      const activeConnector = config2.connector;
      if (activeConnector && connector.id === activeConnector.id)
        throw new ConnectorAlreadyConnectedError();
      try {
        config2.setState((x) => ({ ...x, status: "connecting" }));
        const data = await connector.connect({ chainId });
        config2.setLastUsedConnector(connector.id);
        config2.setState((x) => ({
          ...x,
          connector,
          chains: _optionalChain([connector, "optionalAccess", (_51) => _51.chains]),
          data,
          status: "connected"
        }));
        config2.storage.setItem("connected", true);
        return { ...data, connector };
      } catch (err) {
        config2.setState((x) => {
          return {
            ...x,
            status: x.connector ? "connected" : "disconnected"
          };
        });
        throw err;
      }
    }
    async function disconnect() {
      const config2 = getConfig();
      if (config2.connector)
        await config2.connector.disconnect();
      config2.clearState();
      config2.storage.removeItem("connected");
    }
    var erc20ABI = [
      {
        type: "event",
        name: "Approval",
        inputs: [
          {
            indexed: true,
            name: "owner",
            type: "address"
          },
          {
            indexed: true,
            name: "spender",
            type: "address"
          },
          {
            indexed: false,
            name: "value",
            type: "uint256"
          }
        ]
      },
      {
        type: "event",
        name: "Transfer",
        inputs: [
          {
            indexed: true,
            name: "from",
            type: "address"
          },
          {
            indexed: true,
            name: "to",
            type: "address"
          },
          {
            indexed: false,
            name: "value",
            type: "uint256"
          }
        ]
      },
      {
        type: "function",
        name: "allowance",
        stateMutability: "view",
        inputs: [
          {
            name: "owner",
            type: "address"
          },
          {
            name: "spender",
            type: "address"
          }
        ],
        outputs: [
          {
            name: "",
            type: "uint256"
          }
        ]
      },
      {
        type: "function",
        name: "approve",
        stateMutability: "nonpayable",
        inputs: [
          {
            name: "spender",
            type: "address"
          },
          {
            name: "amount",
            type: "uint256"
          }
        ],
        outputs: [
          {
            name: "",
            type: "bool"
          }
        ]
      },
      {
        type: "function",
        name: "balanceOf",
        stateMutability: "view",
        inputs: [
          {
            name: "account",
            type: "address"
          }
        ],
        outputs: [
          {
            name: "",
            type: "uint256"
          }
        ]
      },
      {
        type: "function",
        name: "decimals",
        stateMutability: "view",
        inputs: [],
        outputs: [
          {
            name: "",
            type: "uint8"
          }
        ]
      },
      {
        type: "function",
        name: "name",
        stateMutability: "view",
        inputs: [],
        outputs: [
          {
            name: "",
            type: "string"
          }
        ]
      },
      {
        type: "function",
        name: "symbol",
        stateMutability: "view",
        inputs: [],
        outputs: [
          {
            name: "",
            type: "string"
          }
        ]
      },
      {
        type: "function",
        name: "totalSupply",
        stateMutability: "view",
        inputs: [],
        outputs: [
          {
            name: "",
            type: "uint256"
          }
        ]
      },
      {
        type: "function",
        name: "transfer",
        stateMutability: "nonpayable",
        inputs: [
          {
            name: "recipient",
            type: "address"
          },
          {
            name: "amount",
            type: "uint256"
          }
        ],
        outputs: [
          {
            name: "",
            type: "bool"
          }
        ]
      },
      {
        type: "function",
        name: "transferFrom",
        stateMutability: "nonpayable",
        inputs: [
          {
            name: "sender",
            type: "address"
          },
          {
            name: "recipient",
            type: "address"
          },
          {
            name: "amount",
            type: "uint256"
          }
        ],
        outputs: [
          {
            name: "",
            type: "bool"
          }
        ]
      }
    ];
    var erc20ABI_bytes32 = [
      {
        type: "event",
        name: "Approval",
        inputs: [
          {
            indexed: true,
            name: "owner",
            type: "address"
          },
          {
            indexed: true,
            name: "spender",
            type: "address"
          },
          {
            indexed: false,
            name: "value",
            type: "uint256"
          }
        ]
      },
      {
        type: "event",
        name: "Transfer",
        inputs: [
          {
            indexed: true,
            name: "from",
            type: "address"
          },
          {
            indexed: true,
            name: "to",
            type: "address"
          },
          {
            indexed: false,
            name: "value",
            type: "uint256"
          }
        ]
      },
      {
        type: "function",
        name: "allowance",
        stateMutability: "view",
        inputs: [
          {
            name: "owner",
            type: "address"
          },
          {
            name: "spender",
            type: "address"
          }
        ],
        outputs: [
          {
            name: "",
            type: "uint256"
          }
        ]
      },
      {
        type: "function",
        name: "approve",
        stateMutability: "nonpayable",
        inputs: [
          {
            name: "spender",
            type: "address"
          },
          {
            name: "amount",
            type: "uint256"
          }
        ],
        outputs: [
          {
            name: "",
            type: "bool"
          }
        ]
      },
      {
        type: "function",
        name: "balanceOf",
        stateMutability: "view",
        inputs: [
          {
            name: "account",
            type: "address"
          }
        ],
        outputs: [
          {
            name: "",
            type: "uint256"
          }
        ]
      },
      {
        type: "function",
        name: "decimals",
        stateMutability: "view",
        inputs: [],
        outputs: [
          {
            name: "",
            type: "uint8"
          }
        ]
      },
      {
        type: "function",
        name: "name",
        stateMutability: "view",
        inputs: [],
        outputs: [
          {
            name: "",
            type: "bytes32"
          }
        ]
      },
      {
        type: "function",
        name: "symbol",
        stateMutability: "view",
        inputs: [],
        outputs: [
          {
            name: "",
            type: "bytes32"
          }
        ]
      },
      {
        type: "function",
        name: "totalSupply",
        stateMutability: "view",
        inputs: [],
        outputs: [
          {
            name: "",
            type: "uint256"
          }
        ]
      },
      {
        type: "function",
        name: "transfer",
        stateMutability: "nonpayable",
        inputs: [
          {
            name: "recipient",
            type: "address"
          },
          {
            name: "amount",
            type: "uint256"
          }
        ],
        outputs: [
          {
            name: "",
            type: "bool"
          }
        ]
      },
      {
        type: "function",
        name: "transferFrom",
        stateMutability: "nonpayable",
        inputs: [
          {
            name: "sender",
            type: "address"
          },
          {
            name: "recipient",
            type: "address"
          },
          {
            name: "amount",
            type: "uint256"
          }
        ],
        outputs: [
          {
            name: "",
            type: "bool"
          }
        ]
      }
    ];
    var erc721ABI = [
      {
        type: "event",
        name: "Approval",
        inputs: [
          {
            indexed: true,
            name: "owner",
            type: "address"
          },
          {
            indexed: true,
            name: "spender",
            type: "address"
          },
          {
            indexed: true,
            name: "tokenId",
            type: "uint256"
          }
        ]
      },
      {
        type: "event",
        name: "ApprovalForAll",
        inputs: [
          {
            indexed: true,
            name: "owner",
            type: "address"
          },
          {
            indexed: true,
            name: "operator",
            type: "address"
          },
          {
            indexed: false,
            name: "approved",
            type: "bool"
          }
        ]
      },
      {
        type: "event",
        name: "Transfer",
        inputs: [
          {
            indexed: true,
            name: "from",
            type: "address"
          },
          {
            indexed: true,
            name: "to",
            type: "address"
          },
          {
            indexed: true,
            name: "tokenId",
            type: "uint256"
          }
        ]
      },
      {
        type: "function",
        name: "approve",
        stateMutability: "payable",
        inputs: [
          {
            name: "spender",
            type: "address"
          },
          {
            name: "tokenId",
            type: "uint256"
          }
        ],
        outputs: []
      },
      {
        type: "function",
        name: "balanceOf",
        stateMutability: "view",
        inputs: [
          {
            name: "account",
            type: "address"
          }
        ],
        outputs: [
          {
            name: "",
            type: "uint256"
          }
        ]
      },
      {
        type: "function",
        name: "getApproved",
        stateMutability: "view",
        inputs: [
          {
            name: "tokenId",
            type: "uint256"
          }
        ],
        outputs: [
          {
            name: "",
            type: "address"
          }
        ]
      },
      {
        type: "function",
        name: "isApprovedForAll",
        stateMutability: "view",
        inputs: [
          {
            name: "owner",
            type: "address"
          },
          {
            name: "operator",
            type: "address"
          }
        ],
        outputs: [
          {
            name: "",
            type: "bool"
          }
        ]
      },
      {
        type: "function",
        name: "name",
        stateMutability: "view",
        inputs: [],
        outputs: [
          {
            name: "",
            type: "string"
          }
        ]
      },
      {
        type: "function",
        name: "ownerOf",
        stateMutability: "view",
        inputs: [
          {
            name: "tokenId",
            type: "uint256"
          }
        ],
        outputs: [
          {
            name: "owner",
            type: "address"
          }
        ]
      },
      {
        type: "function",
        name: "safeTransferFrom",
        stateMutability: "payable",
        inputs: [
          {
            name: "from",
            type: "address"
          },
          {
            name: "to",
            type: "address"
          },
          {
            name: "tokenId",
            type: "uint256"
          }
        ],
        outputs: []
      },
      {
        type: "function",
        name: "safeTransferFrom",
        stateMutability: "nonpayable",
        inputs: [
          {
            name: "from",
            type: "address"
          },
          {
            name: "to",
            type: "address"
          },
          {
            name: "id",
            type: "uint256"
          },
          {
            name: "data",
            type: "bytes"
          }
        ],
        outputs: []
      },
      {
        type: "function",
        name: "setApprovalForAll",
        stateMutability: "nonpayable",
        inputs: [
          {
            name: "operator",
            type: "address"
          },
          {
            name: "approved",
            type: "bool"
          }
        ],
        outputs: []
      },
      {
        type: "function",
        name: "symbol",
        stateMutability: "view",
        inputs: [],
        outputs: [
          {
            name: "",
            type: "string"
          }
        ]
      },
      {
        type: "function",
        name: "tokenByIndex",
        stateMutability: "view",
        inputs: [
          {
            name: "index",
            type: "uint256"
          }
        ],
        outputs: [
          {
            name: "",
            type: "uint256"
          }
        ]
      },
      {
        type: "function",
        name: "tokenByIndex",
        stateMutability: "view",
        inputs: [
          {
            name: "owner",
            type: "address"
          },
          {
            name: "index",
            type: "uint256"
          }
        ],
        outputs: [
          {
            name: "tokenId",
            type: "uint256"
          }
        ]
      },
      {
        type: "function",
        name: "tokenURI",
        stateMutability: "view",
        inputs: [
          {
            name: "tokenId",
            type: "uint256"
          }
        ],
        outputs: [
          {
            name: "",
            type: "string"
          }
        ]
      },
      {
        type: "function",
        name: "totalSupply",
        stateMutability: "view",
        inputs: [],
        outputs: [
          {
            name: "",
            type: "uint256"
          }
        ]
      },
      {
        type: "function",
        name: "transferFrom",
        stateMutability: "payable",
        inputs: [
          {
            name: "sender",
            type: "address"
          },
          {
            name: "recipient",
            type: "address"
          },
          {
            name: "tokeId",
            type: "uint256"
          }
        ],
        outputs: []
      }
    ];
    var erc4626ABI = [
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            name: "owner",
            type: "address"
          },
          {
            indexed: true,
            name: "spender",
            type: "address"
          },
          {
            indexed: false,
            name: "value",
            type: "uint256"
          }
        ],
        name: "Approval",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            name: "sender",
            type: "address"
          },
          {
            indexed: true,
            name: "receiver",
            type: "address"
          },
          {
            indexed: false,
            name: "assets",
            type: "uint256"
          },
          {
            indexed: false,
            name: "shares",
            type: "uint256"
          }
        ],
        name: "Deposit",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            name: "from",
            type: "address"
          },
          {
            indexed: true,
            name: "to",
            type: "address"
          },
          {
            indexed: false,
            name: "value",
            type: "uint256"
          }
        ],
        name: "Transfer",
        type: "event"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            name: "sender",
            type: "address"
          },
          {
            indexed: true,
            name: "receiver",
            type: "address"
          },
          {
            indexed: true,
            name: "owner",
            type: "address"
          },
          {
            indexed: false,
            name: "assets",
            type: "uint256"
          },
          {
            indexed: false,
            name: "shares",
            type: "uint256"
          }
        ],
        name: "Withdraw",
        type: "event"
      },
      {
        inputs: [
          {
            name: "owner",
            type: "address"
          },
          {
            name: "spender",
            type: "address"
          }
        ],
        name: "allowance",
        outputs: [
          {
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            name: "spender",
            type: "address"
          },
          {
            name: "amount",
            type: "uint256"
          }
        ],
        name: "approve",
        outputs: [
          {
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "asset",
        outputs: [
          {
            name: "assetTokenAddress",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            name: "account",
            type: "address"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            name: "shares",
            type: "uint256"
          }
        ],
        name: "convertToAssets",
        outputs: [
          {
            name: "assets",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            name: "assets",
            type: "uint256"
          }
        ],
        name: "convertToShares",
        outputs: [
          {
            name: "shares",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            name: "assets",
            type: "uint256"
          },
          {
            name: "receiver",
            type: "address"
          }
        ],
        name: "deposit",
        outputs: [
          {
            name: "shares",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            name: "caller",
            type: "address"
          }
        ],
        name: "maxDeposit",
        outputs: [
          {
            name: "maxAssets",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            name: "caller",
            type: "address"
          }
        ],
        name: "maxMint",
        outputs: [
          {
            name: "maxShares",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            name: "owner",
            type: "address"
          }
        ],
        name: "maxRedeem",
        outputs: [
          {
            name: "maxShares",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            name: "owner",
            type: "address"
          }
        ],
        name: "maxWithdraw",
        outputs: [
          {
            name: "maxAssets",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            name: "shares",
            type: "uint256"
          },
          {
            name: "receiver",
            type: "address"
          }
        ],
        name: "mint",
        outputs: [
          {
            name: "assets",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            name: "assets",
            type: "uint256"
          }
        ],
        name: "previewDeposit",
        outputs: [
          {
            name: "shares",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            name: "shares",
            type: "uint256"
          }
        ],
        name: "previewMint",
        outputs: [
          {
            name: "assets",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            name: "shares",
            type: "uint256"
          }
        ],
        name: "previewRedeem",
        outputs: [
          {
            name: "assets",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            name: "assets",
            type: "uint256"
          }
        ],
        name: "previewWithdraw",
        outputs: [
          {
            name: "shares",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            name: "shares",
            type: "uint256"
          },
          {
            name: "receiver",
            type: "address"
          },
          {
            name: "owner",
            type: "address"
          }
        ],
        name: "redeem",
        outputs: [
          {
            name: "assets",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "totalAssets",
        outputs: [
          {
            name: "totalManagedAssets",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "totalSupply",
        outputs: [
          {
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            name: "to",
            type: "address"
          },
          {
            name: "amount",
            type: "uint256"
          }
        ],
        name: "transfer",
        outputs: [
          {
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            name: "from",
            type: "address"
          },
          {
            name: "to",
            type: "address"
          },
          {
            name: "amount",
            type: "uint256"
          }
        ],
        name: "transferFrom",
        outputs: [
          {
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            name: "assets",
            type: "uint256"
          },
          {
            name: "receiver",
            type: "address"
          },
          {
            name: "owner",
            type: "address"
          }
        ],
        name: "withdraw",
        outputs: [
          {
            name: "shares",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      }
    ];
    async function fetchToken({
      address,
      chainId,
      formatUnits: unit = 18
    }) {
      async function fetchToken_({ abi }) {
        const erc20Config = { address, abi, chainId };
        const [decimals, name, symbol, totalSupply] = await readContracts({
          allowFailure: false,
          contracts: [
            { ...erc20Config, functionName: "decimals" },
            { ...erc20Config, functionName: "name" },
            { ...erc20Config, functionName: "symbol" },
            { ...erc20Config, functionName: "totalSupply" }
          ]
        });
        return {
          address,
          decimals,
          name,
          symbol,
          totalSupply: {
            formatted: _viem.formatUnits.call(void 0, totalSupply, getUnit(unit)),
            value: totalSupply
          }
        };
      }
      try {
        return await fetchToken_({ abi: erc20ABI });
      } catch (err) {
        if (err instanceof _viem.ContractFunctionExecutionError) {
          const { name, symbol, ...rest } = await fetchToken_({
            abi: erc20ABI_bytes32
          });
          return {
            name: _viem.hexToString.call(void 0, _viem.trim.call(void 0, name, { dir: "right" })),
            symbol: _viem.hexToString.call(void 0, _viem.trim.call(void 0, symbol, { dir: "right" })),
            ...rest
          };
        }
        throw err;
      }
    }
    function getPublicClient({ chainId } = {}) {
      const config2 = getConfig();
      if (chainId)
        return config2.getPublicClient({ chainId }) || config2.publicClient;
      return config2.publicClient;
    }
    async function getWalletClient({
      chainId
    } = {}) {
      const config2 = getConfig();
      const walletClient = await _optionalChain([config2, "access", (_52) => _52.connector, "optionalAccess", (_53) => _53.getWalletClient, "optionalCall", (_54) => _54({ chainId })]) || null;
      return walletClient;
    }
    function getWebSocketPublicClient({
      chainId
    } = {}) {
      const config2 = getConfig();
      if (chainId)
        return config2.getWebSocketPublicClient({ chainId }) || config2.webSocketPublicClient;
      return config2.webSocketPublicClient;
    }
    function watchPublicClient(args, callback) {
      const config2 = getConfig();
      const handleChange = async () => callback(getPublicClient(args));
      const unsubscribe = config2.subscribe(
        ({ publicClient }) => publicClient,
        handleChange
      );
      return unsubscribe;
    }
    var _shallow = (init_shallow(), __toCommonJS(shallow_exports));
    function watchWalletClient({ chainId }, callback) {
      const config2 = getConfig();
      const handleChange = async ({ chainId: chainId_ }) => {
        if (chainId && chainId_ && chainId !== chainId_)
          return;
        const walletClient = await getWalletClient({ chainId });
        if (!getConfig().connector)
          return callback(null);
        return callback(walletClient);
      };
      const unsubscribe = config2.subscribe(
        ({ data, connector }) => ({
          account: _optionalChain([data, "optionalAccess", (_55) => _55.account]),
          chainId: _optionalChain([data, "optionalAccess", (_56) => _56.chain, "optionalAccess", (_57) => _57.id]),
          connector
        }),
        handleChange,
        {
          equalityFn: _shallow.shallow
        }
      );
      return unsubscribe;
    }
    function watchWebSocketPublicClient(args, callback) {
      const config2 = getConfig();
      const handleChange = async () => callback(getWebSocketPublicClient(args));
      const unsubscribe = config2.subscribe(
        ({ webSocketPublicClient }) => webSocketPublicClient,
        handleChange
      );
      return unsubscribe;
    }
    async function prepareWriteContract({
      abi,
      address,
      args,
      chainId,
      functionName,
      walletClient: walletClient_,
      ...config2
    }) {
      const publicClient = getPublicClient({ chainId });
      const walletClient = await _asyncNullishCoalesce(walletClient_, async () => await getWalletClient({ chainId }));
      if (!walletClient)
        throw new (0, _connectors.ConnectorNotFoundError)();
      if (chainId)
        assertActiveChain({ chainId });
      const {
        account,
        accessList,
        blockNumber,
        blockTag,
        gas,
        gasPrice,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        value
      } = getCallParameters(config2);
      const { result, request } = await publicClient.simulateContract({
        abi,
        address,
        functionName,
        args,
        account: account || walletClient.account,
        accessList,
        blockNumber,
        blockTag,
        gas,
        gasPrice,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        value
      });
      const minimizedAbi = abi.filter(
        (abiItem) => "name" in abiItem && abiItem.name === functionName
      );
      return {
        mode: "prepared",
        request: {
          ...request,
          abi: minimizedAbi,
          chainId
        },
        result
      };
    }
    function getContract({
      address,
      abi,
      chainId,
      walletClient
    }) {
      const publicClient = getPublicClient({ chainId });
      return _viem.getContract.call(void 0, {
        address,
        abi,
        publicClient,
        walletClient
      });
    }
    async function multicall({
      chainId,
      contracts,
      blockNumber,
      blockTag,
      ...args
    }) {
      const publicClient = getPublicClient({ chainId });
      if (!publicClient.chains)
        throw new ConfigChainsNotFound();
      if (chainId && publicClient.chain.id !== chainId)
        throw new ChainNotConfiguredError({ chainId });
      return publicClient.multicall({
        allowFailure: _nullishCoalesce(args.allowFailure, () => true),
        blockNumber,
        blockTag,
        contracts
      });
    }
    async function readContract({
      address,
      account,
      chainId,
      abi,
      args,
      functionName,
      blockNumber,
      blockTag
    }) {
      const publicClient = getPublicClient({ chainId });
      return publicClient.readContract({
        abi,
        address,
        account,
        functionName,
        args,
        blockNumber,
        blockTag
      });
    }
    async function readContracts({
      contracts,
      blockNumber,
      blockTag,
      ...args
    }) {
      const { allowFailure = true } = args;
      try {
        const publicClient = getPublicClient();
        const contractsByChainId = contracts.reduce((contracts2, contract, index) => {
          const chainId = _nullishCoalesce(contract.chainId, () => publicClient.chain.id);
          return {
            ...contracts2,
            [chainId]: [...contracts2[chainId] || [], { contract, index }]
          };
        }, {});
        const promises = () => Object.entries(contractsByChainId).map(
          ([chainId, contracts2]) => multicall({
            allowFailure,
            chainId: parseInt(chainId),
            contracts: contracts2.map(
              ({ contract }) => contract
            ),
            blockNumber,
            blockTag
          })
        );
        const multicallResults = (await Promise.all(promises())).flat();
        const resultIndexes = Object.values(contractsByChainId).flatMap(
          (contracts2) => contracts2.map(({ index }) => index)
        );
        return multicallResults.reduce((results, result, index) => {
          if (results)
            results[resultIndexes[index]] = result;
          return results;
        }, []);
      } catch (err) {
        if (err instanceof _viem.ContractFunctionExecutionError)
          throw err;
        const promises = () => contracts.map(
          (contract) => readContract({ ...contract, blockNumber, blockTag })
        );
        if (allowFailure)
          return (await Promise.allSettled(promises())).map((result) => {
            if (result.status === "fulfilled")
              return { result: result.value, status: "success" };
            return { error: result.reason, result: void 0, status: "failure" };
          });
        return await Promise.all(promises());
      }
    }
    function watchContractEvent({
      address,
      abi,
      chainId,
      eventName
    }, callback) {
      let unwatch;
      const watchEvent = async () => {
        if (unwatch)
          unwatch();
        const publicClient = getWebSocketPublicClient({ chainId }) || getPublicClient({ chainId });
        unwatch = publicClient.watchContractEvent({
          address,
          abi,
          eventName,
          onLogs: callback
        });
      };
      watchEvent();
      const config2 = getConfig();
      const unsubscribe = config2.subscribe(
        ({ publicClient, webSocketPublicClient }) => ({
          publicClient,
          webSocketPublicClient
        }),
        watchEvent,
        { equalityFn: _shallow.shallow }
      );
      return () => {
        _optionalChain([unwatch, "optionalCall", (_58) => _58()]);
        unsubscribe();
      };
    }
    function watchBlockNumber(args, callback) {
      let unwatch;
      const createListener = (publicClient) => {
        if (unwatch)
          unwatch();
        unwatch = publicClient.watchBlockNumber({
          onBlockNumber: callback,
          emitOnBegin: true,
          poll: true
        });
      };
      const publicClient_ = _nullishCoalesce(getWebSocketPublicClient({ chainId: args.chainId }), () => getPublicClient({ chainId: args.chainId }));
      if (args.listen)
        createListener(publicClient_);
      const config2 = getConfig();
      const unsubscribe = config2.subscribe(
        ({ publicClient, webSocketPublicClient }) => ({
          publicClient,
          webSocketPublicClient
        }),
        async ({ publicClient, webSocketPublicClient }) => {
          const publicClient_2 = _nullishCoalesce(webSocketPublicClient, () => publicClient);
          if (args.listen && !args.chainId && publicClient_2) {
            createListener(publicClient_2);
          }
        },
        {
          equalityFn: _shallow.shallow
        }
      );
      return () => {
        unsubscribe();
        _optionalChain([unwatch, "optionalCall", (_59) => _59()]);
      };
    }
    function watchMulticall(args, callback) {
      const config2 = getConfig();
      const handleChange = async () => callback(await multicall(args));
      const unwatch = args.listenToBlock ? watchBlockNumber({ listen: true }, handleChange) : void 0;
      const unsubscribe = config2.subscribe(
        ({ publicClient }) => publicClient,
        handleChange
      );
      return () => {
        unsubscribe();
        _optionalChain([unwatch, "optionalCall", (_60) => _60()]);
      };
    }
    function watchReadContract(args, callback) {
      const config2 = getConfig();
      const handleChange = async () => callback(await readContract(args));
      const unwatch = args.listenToBlock ? watchBlockNumber({ listen: true }, handleChange) : void 0;
      const unsubscribe = config2.subscribe(
        ({ publicClient }) => publicClient,
        handleChange
      );
      return () => {
        unsubscribe();
        _optionalChain([unwatch, "optionalCall", (_61) => _61()]);
      };
    }
    function watchReadContracts(args, callback) {
      const config2 = getConfig();
      const handleChange = async () => callback(await readContracts(args));
      const unwatch = args.listenToBlock ? watchBlockNumber({ listen: true }, handleChange) : void 0;
      const unsubscribe = config2.subscribe(
        ({ publicClient }) => publicClient,
        handleChange
      );
      return () => {
        unsubscribe();
        _optionalChain([unwatch, "optionalCall", (_62) => _62()]);
      };
    }
    async function writeContract(config2) {
      const walletClient = await getWalletClient({ chainId: config2.chainId });
      if (!walletClient)
        throw new (0, _connectors.ConnectorNotFoundError)();
      if (config2.chainId)
        assertActiveChain({ chainId: config2.chainId });
      let request;
      if (config2.mode === "prepared") {
        request = config2.request;
      } else {
        const { chainId: _, mode: __, ...args } = config2;
        const res = await prepareWriteContract(args);
        request = res.request;
      }
      const hash = await walletClient.writeContract({
        ...request,
        chain: null
      });
      return { hash };
    }
    async function fetchBalance({
      address,
      chainId,
      formatUnits: unit,
      token
    }) {
      const config2 = getConfig();
      const publicClient = getPublicClient({ chainId });
      if (token) {
        const fetchContractBalance = async ({ abi }) => {
          const erc20Config = { abi, address: token, chainId };
          const [value2, decimals, symbol] = await readContracts({
            allowFailure: false,
            contracts: [
              {
                ...erc20Config,
                functionName: "balanceOf",
                args: [address]
              },
              { ...erc20Config, functionName: "decimals" },
              { ...erc20Config, functionName: "symbol" }
            ]
          });
          return {
            decimals,
            formatted: _viem.formatUnits.call(void 0, _nullishCoalesce(value2, () => "0"), getUnit(_nullishCoalesce(unit, () => decimals))),
            symbol,
            value: value2
          };
        };
        try {
          return await fetchContractBalance({ abi: erc20ABI });
        } catch (err) {
          if (err instanceof _viem.ContractFunctionExecutionError) {
            const { symbol, ...rest } = await fetchContractBalance({
              abi: erc20ABI_bytes32
            });
            return {
              symbol: _viem.hexToString.call(void 0, _viem.trim.call(void 0, symbol, { dir: "right" })),
              ...rest
            };
          }
          throw err;
        }
      }
      const chains = [
        ...config2.publicClient.chains || [],
        ..._nullishCoalesce(config2.chains, () => [])
      ];
      const value = await publicClient.getBalance({ address });
      const chain = chains.find((x) => x.id === publicClient.chain.id);
      return {
        decimals: _nullishCoalesce(_optionalChain([chain, "optionalAccess", (_63) => _63.nativeCurrency, "access", (_64) => _64.decimals]), () => 18),
        formatted: _viem.formatUnits.call(void 0, _nullishCoalesce(value, () => "0"), getUnit(_nullishCoalesce(unit, () => 18))),
        symbol: _nullishCoalesce(_optionalChain([chain, "optionalAccess", (_65) => _65.nativeCurrency, "access", (_66) => _66.symbol]), () => "ETH"),
        value
      };
    }
    function getAccount() {
      const { data, connector, status } = getConfig();
      switch (status) {
        case "connected":
          return {
            address: _optionalChain([data, "optionalAccess", (_67) => _67.account]),
            connector,
            isConnected: true,
            isConnecting: false,
            isDisconnected: false,
            isReconnecting: false,
            status
          };
        case "reconnecting":
          return {
            address: _optionalChain([data, "optionalAccess", (_68) => _68.account]),
            connector,
            isConnected: !!_optionalChain([data, "optionalAccess", (_69) => _69.account]),
            isConnecting: false,
            isDisconnected: false,
            isReconnecting: true,
            status
          };
        case "connecting":
          return {
            address: _optionalChain([data, "optionalAccess", (_70) => _70.account]),
            connector,
            isConnected: false,
            isConnecting: true,
            isDisconnected: false,
            isReconnecting: false,
            status
          };
        case "disconnected":
          return {
            address: void 0,
            connector: void 0,
            isConnected: false,
            isConnecting: false,
            isDisconnected: true,
            isReconnecting: false,
            status
          };
      }
    }
    function getNetwork() {
      const config2 = getConfig();
      const chainId = _optionalChain([config2, "access", (_71) => _71.data, "optionalAccess", (_72) => _72.chain, "optionalAccess", (_73) => _73.id]);
      const activeChains = _nullishCoalesce(config2.chains, () => []);
      const activeChain = _nullishCoalesce([
        ..._optionalChain([config2, "access", (_74) => _74.publicClient, "optionalAccess", (_75) => _75.chains]) || [],
        ...activeChains
      ].find((x) => x.id === chainId), () => ({
        id: chainId,
        name: `Chain ${chainId}`,
        network: `${chainId}`,
        nativeCurrency: { name: "Ether", decimals: 18, symbol: "ETH" },
        rpcUrls: {
          default: { http: [""] },
          public: { http: [""] }
        }
      }));
      return {
        chain: chainId ? {
          ...activeChain,
          ..._optionalChain([config2, "access", (_76) => _76.data, "optionalAccess", (_77) => _77.chain]),
          id: chainId
        } : void 0,
        chains: activeChains
      };
    }
    async function signMessage(args) {
      const walletClient = await getWalletClient();
      if (!walletClient)
        throw new (0, _connectors.ConnectorNotFoundError)();
      return await walletClient.signMessage({
        message: args.message
      });
    }
    async function signTypedData({
      domain,
      message,
      primaryType,
      types
    }) {
      const walletClient = await getWalletClient();
      if (!walletClient)
        throw new (0, _connectors.ConnectorNotFoundError)();
      const { chainId } = domain;
      if (chainId)
        assertActiveChain({ chainId });
      return walletClient.signTypedData({
        message,
        primaryType,
        types,
        domain
      });
    }
    async function switchNetwork({
      chainId
    }) {
      const { connector } = getConfig();
      if (!connector)
        throw new (0, _connectors.ConnectorNotFoundError)();
      if (!connector.switchChain)
        throw new SwitchChainNotSupportedError({
          connector
        });
      return connector.switchChain(chainId);
    }
    function watchAccount(callback, { selector = (x) => x } = {}) {
      const config2 = getConfig();
      const handleChange = () => callback(getAccount());
      const unsubscribe = config2.subscribe(
        ({ data, connector, status }) => selector({
          address: _optionalChain([data, "optionalAccess", (_78) => _78.account]),
          connector,
          status
        }),
        handleChange,
        {
          equalityFn: _shallow.shallow
        }
      );
      return unsubscribe;
    }
    function watchNetwork(callback, { selector = (x) => x } = {}) {
      const config2 = getConfig();
      const handleChange = () => callback(getNetwork());
      const unsubscribe = config2.subscribe(
        ({ data, chains }) => selector({ chainId: _optionalChain([data, "optionalAccess", (_79) => _79.chain, "optionalAccess", (_80) => _80.id]), chains }),
        handleChange,
        {
          equalityFn: _shallow.shallow
        }
      );
      return unsubscribe;
    }
    var _ens = require_ens2();
    async function fetchEnsAddress({
      chainId,
      name
    }) {
      const publicClient = getPublicClient({ chainId });
      const address = await publicClient.getEnsAddress({
        name: _ens.normalize.call(void 0, name)
      });
      try {
        if (address === "0x0000000000000000000000000000000000000000")
          return null;
        return address ? _viem.getAddress.call(void 0, address) : null;
      } catch (_error) {
        return null;
      }
    }
    async function fetchEnsAvatar({
      name,
      chainId
    }) {
      const publicClient = getPublicClient({ chainId });
      const avatar = await publicClient.getEnsAvatar({ name: _ens.normalize.call(void 0, name) });
      return avatar;
    }
    async function fetchEnsName({
      address,
      chainId
    }) {
      const publicClient = getPublicClient({ chainId });
      return publicClient.getEnsName({
        address: _viem.getAddress.call(void 0, address)
      });
    }
    async function fetchEnsResolver({
      chainId,
      name
    }) {
      const publicClient = getPublicClient({ chainId });
      const resolver = await publicClient.getEnsResolver({ name: _ens.normalize.call(void 0, name) });
      return resolver;
    }
    async function fetchBlockNumber({
      chainId
    } = {}) {
      const publicClient = getPublicClient({ chainId });
      const blockNumber = await publicClient.getBlockNumber();
      return blockNumber;
    }
    async function fetchFeeData({
      chainId,
      formatUnits: units = "gwei"
    } = {}) {
      const publicClient = getPublicClient({ chainId });
      const block = await publicClient.getBlock();
      let gasPrice = null;
      try {
        gasPrice = await publicClient.getGasPrice();
      } catch (e) {
      }
      let lastBaseFeePerGas = null;
      let maxFeePerGas = null;
      let maxPriorityFeePerGas = null;
      if (_optionalChain([block, "optionalAccess", (_81) => _81.baseFeePerGas])) {
        lastBaseFeePerGas = block.baseFeePerGas;
        maxPriorityFeePerGas = _viem.parseGwei.call(void 0, "1");
        maxFeePerGas = block.baseFeePerGas * 2n + maxPriorityFeePerGas;
      }
      const unit = getUnit(units);
      const formatted = {
        gasPrice: gasPrice ? _viem.formatUnits.call(void 0, gasPrice, unit) : null,
        maxFeePerGas: maxFeePerGas ? _viem.formatUnits.call(void 0, maxFeePerGas, unit) : null,
        maxPriorityFeePerGas: maxPriorityFeePerGas ? _viem.formatUnits.call(void 0, maxPriorityFeePerGas, unit) : null
      };
      return {
        lastBaseFeePerGas,
        gasPrice,
        maxFeePerGas,
        maxPriorityFeePerGas,
        formatted
      };
    }
    async function fetchTransaction({
      chainId,
      hash
    }) {
      const publicClient = getPublicClient({ chainId });
      return publicClient.getTransaction({ hash });
    }
    async function prepareSendTransaction({
      accessList,
      account,
      chainId,
      data,
      gas: gas_,
      gasPrice,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to: to_,
      value,
      walletClient: walletClient_
    }) {
      const publicClient = getPublicClient({ chainId });
      const walletClient = await _asyncNullishCoalesce(walletClient_, async () => await getWalletClient({ chainId }));
      if (!walletClient)
        throw new (0, _connectors.ConnectorNotFoundError)();
      if (chainId)
        assertActiveChain({ chainId });
      const to = (to_ && !_viem.isAddress.call(void 0, to_) ? await fetchEnsAddress({ name: to_ }) : to_) || void 0;
      if (to && !_viem.isAddress.call(void 0, to))
        throw new Error("Invalid address");
      const gas = typeof gas_ === "undefined" ? await publicClient.estimateGas({
        accessList,
        account: walletClient.account,
        data,
        gas: _nullishCoalesce(gas_, () => void 0),
        gasPrice,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        to,
        value
      }) : gas_ || void 0;
      return {
        accessList,
        account,
        data,
        gas,
        gasPrice,
        maxFeePerGas,
        maxPriorityFeePerGas,
        mode: "prepared",
        nonce,
        to,
        value,
        ...chainId ? { chainId } : {}
      };
    }
    async function sendTransaction({
      accessList,
      account,
      chainId,
      data,
      gas,
      gasPrice,
      maxFeePerGas,
      maxPriorityFeePerGas,
      mode,
      nonce,
      to,
      value
    }) {
      const walletClient = await getWalletClient({ chainId });
      if (!walletClient)
        throw new (0, _connectors.ConnectorNotFoundError)();
      if (chainId)
        assertActiveChain({ chainId });
      let args;
      if (mode === "prepared") {
        args = {
          account,
          accessList,
          chain: null,
          data,
          gas,
          gasPrice,
          maxFeePerGas,
          maxPriorityFeePerGas,
          nonce,
          to,
          value
        };
      } else {
        args = await prepareSendTransaction({
          accessList,
          account,
          chainId,
          data,
          gas: gas || null,
          gasPrice,
          maxFeePerGas,
          maxPriorityFeePerGas,
          nonce,
          to,
          value
        });
      }
      const hash = await walletClient.sendTransaction({ ...args, chain: null });
      return { hash };
    }
    async function waitForTransaction({
      chainId,
      confirmations = 1,
      hash,
      onReplaced,
      timeout = 0
    }) {
      const publicClient = getPublicClient({ chainId });
      const receipt = await publicClient.waitForTransactionReceipt({
        hash,
        confirmations,
        onReplaced,
        timeout
      });
      if (receipt.status === "reverted") {
        const txn = await publicClient.getTransaction({
          hash: receipt.transactionHash
        });
        const code = await publicClient.call({
          ...txn,
          gasPrice: txn.type !== "eip1559" ? txn.gasPrice : void 0,
          maxFeePerGas: txn.type === "eip1559" ? txn.maxFeePerGas : void 0,
          maxPriorityFeePerGas: txn.type === "eip1559" ? txn.maxPriorityFeePerGas : void 0
        });
        const reason = _viem.hexToString.call(void 0, `0x${code.substring(138)}`);
        throw new Error(reason);
      }
      return receipt;
    }
    function watchPendingTransactions(args, callback) {
      let unwatch;
      const createListener = (publicClient) => {
        if (unwatch)
          unwatch();
        unwatch = publicClient.watchPendingTransactions({
          onTransactions: callback,
          poll: true
        });
      };
      const publicClient_ = _nullishCoalesce(getWebSocketPublicClient({ chainId: args.chainId }), () => getPublicClient({ chainId: args.chainId }));
      createListener(publicClient_);
      const config2 = getConfig();
      const unsubscribe = config2.subscribe(
        ({ publicClient, webSocketPublicClient }) => ({
          publicClient,
          webSocketPublicClient
        }),
        async ({ publicClient, webSocketPublicClient }) => {
          const publicClient_2 = _nullishCoalesce(webSocketPublicClient, () => publicClient);
          if (!args.chainId && publicClient_2) {
            createListener(publicClient_2);
          }
        },
        {
          equalityFn: _shallow.shallow
        }
      );
      return () => {
        unsubscribe();
        _optionalChain([unwatch, "optionalCall", (_82) => _82()]);
      };
    }
    function assertActiveChain({ chainId }) {
      const { chain: activeChain, chains } = getNetwork();
      const activeChainId = _optionalChain([activeChain, "optionalAccess", (_83) => _83.id]);
      if (activeChainId && chainId !== activeChainId) {
        throw new ChainMismatchError({
          activeChain: _nullishCoalesce(_optionalChain([chains, "access", (_84) => _84.find, "call", (_85) => _85((x) => x.id === activeChainId), "optionalAccess", (_86) => _86.name]), () => `Chain ${activeChainId}`),
          targetChain: _nullishCoalesce(_optionalChain([chains, "access", (_87) => _87.find, "call", (_88) => _88((x) => x.id === chainId), "optionalAccess", (_89) => _89.name]), () => `Chain ${chainId}`)
        });
      }
    }
    exports.configureChains = configureChains;
    exports.ChainMismatchError = ChainMismatchError;
    exports.ChainNotConfiguredError = ChainNotConfiguredError;
    exports.ConnectorAlreadyConnectedError = ConnectorAlreadyConnectedError;
    exports.ConfigChainsNotFound = ConfigChainsNotFound;
    exports.SwitchChainNotSupportedError = SwitchChainNotSupportedError;
    exports.ConnectorNotFoundError = _connectors.ConnectorNotFoundError;
    exports.deepEqual = deepEqual;
    exports.deserialize = deserialize;
    exports.getCallParameters = getCallParameters;
    exports.getSendTransactionParameters = getSendTransactionParameters;
    exports.getUnit = getUnit;
    exports.serialize = serialize;
    exports.noopStorage = noopStorage;
    exports.createStorage = createStorage;
    exports.Config = Config;
    exports.createConfig = createConfig;
    exports.getConfig = getConfig;
    exports.connect = connect;
    exports.disconnect = disconnect;
    exports.erc20ABI = erc20ABI;
    exports.erc721ABI = erc721ABI;
    exports.erc4626ABI = erc4626ABI;
    exports.fetchToken = fetchToken;
    exports.getPublicClient = getPublicClient;
    exports.getWalletClient = getWalletClient;
    exports.getWebSocketPublicClient = getWebSocketPublicClient;
    exports.watchPublicClient = watchPublicClient;
    exports.watchWalletClient = watchWalletClient;
    exports.watchWebSocketPublicClient = watchWebSocketPublicClient;
    exports.prepareWriteContract = prepareWriteContract;
    exports.getContract = getContract;
    exports.multicall = multicall;
    exports.readContract = readContract;
    exports.readContracts = readContracts;
    exports.watchContractEvent = watchContractEvent;
    exports.watchBlockNumber = watchBlockNumber;
    exports.watchMulticall = watchMulticall;
    exports.watchReadContract = watchReadContract;
    exports.watchReadContracts = watchReadContracts;
    exports.writeContract = writeContract;
    exports.fetchBalance = fetchBalance;
    exports.getAccount = getAccount;
    exports.getNetwork = getNetwork;
    exports.signMessage = signMessage;
    exports.signTypedData = signTypedData;
    exports.switchNetwork = switchNetwork;
    exports.watchAccount = watchAccount;
    exports.watchNetwork = watchNetwork;
    exports.fetchEnsAddress = fetchEnsAddress;
    exports.fetchEnsAvatar = fetchEnsAvatar;
    exports.fetchEnsName = fetchEnsName;
    exports.fetchEnsResolver = fetchEnsResolver;
    exports.fetchBlockNumber = fetchBlockNumber;
    exports.fetchFeeData = fetchFeeData;
    exports.fetchTransaction = fetchTransaction;
    exports.prepareSendTransaction = prepareSendTransaction;
    exports.sendTransaction = sendTransaction;
    exports.waitForTransaction = waitForTransaction;
    exports.watchPendingTransactions = watchPendingTransactions;
  }
});

// node_modules/@wagmi/core/dist/chunk-EQOEZP46.js
var require_chunk_EQOEZP46 = __commonJS({
  "node_modules/@wagmi/core/dist/chunk-EQOEZP46.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _injected = require_injected();
    exports.InjectedConnector = _injected.InjectedConnector;
  }
});

// node_modules/@wagmi/core/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/@wagmi/core/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _chunk4E64EZ7Vjs = require_chunk_4E64EZ7V();
    var _chunkLAFZBYO7js = require_chunk_LAFZBYO7();
    var _chunkBVC4KGLQjs = require_chunk_BVC4KGLQ();
    var _chunkEQOEZP46js = require_chunk_EQOEZP46();
    require_chunk_MQXBDTVK();
    exports.ChainMismatchError = _chunkLAFZBYO7js.ChainMismatchError;
    exports.ChainNotConfiguredError = _chunkLAFZBYO7js.ChainNotConfiguredError;
    exports.Config = _chunkLAFZBYO7js.Config;
    exports.ConfigChainsNotFound = _chunkLAFZBYO7js.ConfigChainsNotFound;
    exports.Connector = _chunkBVC4KGLQjs.Connector;
    exports.ConnectorAlreadyConnectedError = _chunkLAFZBYO7js.ConnectorAlreadyConnectedError;
    exports.ConnectorNotFoundError = _chunkLAFZBYO7js.ConnectorNotFoundError;
    exports.InjectedConnector = _chunkEQOEZP46js.InjectedConnector;
    exports.SwitchChainNotSupportedError = _chunkLAFZBYO7js.SwitchChainNotSupportedError;
    exports.configureChains = _chunkLAFZBYO7js.configureChains;
    exports.connect = _chunkLAFZBYO7js.connect;
    exports.createConfig = _chunkLAFZBYO7js.createConfig;
    exports.createStorage = _chunkLAFZBYO7js.createStorage;
    exports.deepEqual = _chunkLAFZBYO7js.deepEqual;
    exports.deserialize = _chunkLAFZBYO7js.deserialize;
    exports.disconnect = _chunkLAFZBYO7js.disconnect;
    exports.erc20ABI = _chunkLAFZBYO7js.erc20ABI;
    exports.erc4626ABI = _chunkLAFZBYO7js.erc4626ABI;
    exports.erc721ABI = _chunkLAFZBYO7js.erc721ABI;
    exports.fetchBalance = _chunkLAFZBYO7js.fetchBalance;
    exports.fetchBlockNumber = _chunkLAFZBYO7js.fetchBlockNumber;
    exports.fetchEnsAddress = _chunkLAFZBYO7js.fetchEnsAddress;
    exports.fetchEnsAvatar = _chunkLAFZBYO7js.fetchEnsAvatar;
    exports.fetchEnsName = _chunkLAFZBYO7js.fetchEnsName;
    exports.fetchEnsResolver = _chunkLAFZBYO7js.fetchEnsResolver;
    exports.fetchFeeData = _chunkLAFZBYO7js.fetchFeeData;
    exports.fetchToken = _chunkLAFZBYO7js.fetchToken;
    exports.fetchTransaction = _chunkLAFZBYO7js.fetchTransaction;
    exports.getAccount = _chunkLAFZBYO7js.getAccount;
    exports.getConfig = _chunkLAFZBYO7js.getConfig;
    exports.getContract = _chunkLAFZBYO7js.getContract;
    exports.getNetwork = _chunkLAFZBYO7js.getNetwork;
    exports.getPublicClient = _chunkLAFZBYO7js.getPublicClient;
    exports.getUnit = _chunkLAFZBYO7js.getUnit;
    exports.getWalletClient = _chunkLAFZBYO7js.getWalletClient;
    exports.getWebSocketPublicClient = _chunkLAFZBYO7js.getWebSocketPublicClient;
    exports.mainnet = _chunk4E64EZ7Vjs.mainnet;
    exports.multicall = _chunkLAFZBYO7js.multicall;
    exports.noopStorage = _chunkLAFZBYO7js.noopStorage;
    exports.prepareSendTransaction = _chunkLAFZBYO7js.prepareSendTransaction;
    exports.prepareWriteContract = _chunkLAFZBYO7js.prepareWriteContract;
    exports.readContract = _chunkLAFZBYO7js.readContract;
    exports.readContracts = _chunkLAFZBYO7js.readContracts;
    exports.sendTransaction = _chunkLAFZBYO7js.sendTransaction;
    exports.sepolia = _chunk4E64EZ7Vjs.sepolia;
    exports.serialize = _chunkLAFZBYO7js.serialize;
    exports.signMessage = _chunkLAFZBYO7js.signMessage;
    exports.signTypedData = _chunkLAFZBYO7js.signTypedData;
    exports.switchNetwork = _chunkLAFZBYO7js.switchNetwork;
    exports.waitForTransaction = _chunkLAFZBYO7js.waitForTransaction;
    exports.watchAccount = _chunkLAFZBYO7js.watchAccount;
    exports.watchBlockNumber = _chunkLAFZBYO7js.watchBlockNumber;
    exports.watchContractEvent = _chunkLAFZBYO7js.watchContractEvent;
    exports.watchMulticall = _chunkLAFZBYO7js.watchMulticall;
    exports.watchNetwork = _chunkLAFZBYO7js.watchNetwork;
    exports.watchPendingTransactions = _chunkLAFZBYO7js.watchPendingTransactions;
    exports.watchPublicClient = _chunkLAFZBYO7js.watchPublicClient;
    exports.watchReadContract = _chunkLAFZBYO7js.watchReadContract;
    exports.watchReadContracts = _chunkLAFZBYO7js.watchReadContracts;
    exports.watchWalletClient = _chunkLAFZBYO7js.watchWalletClient;
    exports.watchWebSocketPublicClient = _chunkLAFZBYO7js.watchWebSocketPublicClient;
    exports.writeContract = _chunkLAFZBYO7js.writeContract;
  }
});

// node_modules/@wagmi/core/dist/internal/index.js
var require_internal = __commonJS({
  "node_modules/@wagmi/core/dist/internal/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _chunkLAFZBYO7js = require_chunk_LAFZBYO7();
    require_chunk_BVC4KGLQ();
    require_chunk_MQXBDTVK();
    exports.getCallParameters = _chunkLAFZBYO7js.getCallParameters;
    exports.getSendTransactionParameters = _chunkLAFZBYO7js.getSendTransactionParameters;
  }
});

// node_modules/wagmi/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/wagmi/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              newObj[key] = obj[key];
            }
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    function _nullishCoalesce(lhs, rhsFn) {
      if (lhs != null) {
        return lhs;
      } else {
        return rhsFn();
      }
    }
    async function _asyncNullishCoalesce(lhs, rhsFn) {
      if (lhs != null) {
        return lhs;
      } else {
        return await rhsFn();
      }
    }
    function _optionalChain(ops) {
      let lastAccessLHS = void 0;
      let value = ops[0];
      let i = 1;
      while (i < ops.length) {
        const op = ops[i];
        const fn = ops[i + 1];
        i += 2;
        if ((op === "optionalAccess" || op === "optionalCall") && value == null) {
          return void 0;
        }
        if (op === "access" || op === "optionalAccess") {
          lastAccessLHS = value;
          value = fn(value);
        } else if (op === "call" || op === "optionalCall") {
          value = fn((...args) => value.call(lastAccessLHS, ...args));
          lastAccessLHS = void 0;
        }
      }
      return value;
    }
    var _querysyncstoragepersister = require_lib();
    var _reactquery = require_lib3();
    var _reactquerypersistclient = require_lib5();
    var _core = require_dist3();
    function createConfig({
      queryClient = new (0, _reactquery.QueryClient)({
        defaultOptions: {
          queries: {
            cacheTime: 1e3 * 60 * 60 * 24,
            networkMode: "offlineFirst",
            refetchOnWindowFocus: false,
            retry: 0
          },
          mutations: {
            networkMode: "offlineFirst"
          }
        }
      }),
      storage = _core.createStorage.call(void 0, {
        storage: typeof window !== "undefined" && window.localStorage ? window.localStorage : _core.noopStorage
      }),
      persister = typeof window !== "undefined" ? _querysyncstoragepersister.createSyncStoragePersister.call(void 0, {
        key: "cache",
        storage,
        serialize: (x) => x,
        deserialize: (x) => x
      }) : void 0,
      ...args
    }) {
      const config = _core.createConfig.call(void 0, {
        ...args,
        storage
      });
      if (persister)
        _reactquerypersistclient.persistQueryClient.call(void 0, {
          queryClient,
          persister,
          dehydrateOptions: {
            shouldDehydrateQuery: (query) => query.cacheTime !== 0 && query.queryKey[0].persist !== false
          }
        });
      return Object.assign(config, { queryClient });
    }
    var _react = require_react();
    var React = _interopRequireWildcard(_react);
    var React9 = _interopRequireWildcard(_react);
    var React2 = _interopRequireWildcard(_react);
    var React3 = _interopRequireWildcard(_react);
    var React4 = _interopRequireWildcard(_react);
    var React7 = _interopRequireWildcard(_react);
    var React5 = _interopRequireWildcard(_react);
    var React6 = _interopRequireWildcard(_react);
    var React8 = _interopRequireWildcard(_react);
    var React10 = _interopRequireWildcard(_react);
    var React11 = _interopRequireWildcard(_react);
    var React12 = _interopRequireWildcard(_react);
    var React13 = _interopRequireWildcard(_react);
    var React14 = _interopRequireWildcard(_react);
    var React15 = _interopRequireWildcard(_react);
    var React16 = _interopRequireWildcard(_react);
    var React17 = _interopRequireWildcard(_react);
    var React18 = _interopRequireWildcard(_react);
    var React19 = _interopRequireWildcard(_react);
    var React20 = _interopRequireWildcard(_react);
    var React21 = _interopRequireWildcard(_react);
    var Context = React.createContext(void 0);
    var queryClientContext = React.createContext(
      void 0
    );
    function WagmiConfig({
      children,
      config
    }) {
      return React.createElement(Context.Provider, {
        children: React.createElement(_reactquery.QueryClientProvider, {
          children,
          client: config.queryClient,
          context: queryClientContext
        }),
        value: config
      });
    }
    function useConfig() {
      const config = React.useContext(Context);
      if (!config)
        throw new Error(
          [
            "`useConfig` must be used within `WagmiConfig`.\n",
            "Read more: https://wagmi.sh/react/WagmiConfig"
          ].join("\n")
        );
      return config;
    }
    var _indexjs = require_shim();
    var pkg = _interopRequireWildcard(_indexjs);
    var useSyncExternalStore2 = pkg.useSyncExternalStore;
    function isQueryKey(value) {
      return Array.isArray(value);
    }
    function isPlainObject(o) {
      if (!hasObjectPrototype(o)) {
        return false;
      }
      const ctor = o.constructor;
      if (typeof ctor === "undefined") {
        return true;
      }
      const prot = ctor.prototype;
      if (!hasObjectPrototype(prot)) {
        return false;
      }
      if (!prot.hasOwnProperty("isPrototypeOf")) {
        return false;
      }
      return true;
    }
    function hasObjectPrototype(o) {
      return Object.prototype.toString.call(o) === "[object Object]";
    }
    function parseQueryArgs(arg1, arg2, arg3) {
      if (!isQueryKey(arg1)) {
        return arg1;
      }
      if (typeof arg2 === "function") {
        return { ...arg3, queryKey: arg1, queryFn: arg2 };
      }
      return { ...arg2, queryKey: arg1 };
    }
    function queryKeyHashFn(queryKey17) {
      return JSON.stringify(
        queryKey17,
        (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {
          result[key] = val[key];
          return result;
        }, {}) : typeof val === "bigint" ? val.toString() : val
      );
    }
    function shouldThrowError(_useErrorBoundary, params) {
      if (typeof _useErrorBoundary === "function") {
        return _useErrorBoundary(...params);
      }
      return !!_useErrorBoundary;
    }
    function trackResult(result, observer) {
      const trackedResult = {};
      Object.keys(result).forEach((key) => {
        Object.defineProperty(trackedResult, key, {
          configurable: false,
          enumerable: true,
          get: () => {
            observer.trackedProps.add(key);
            return result[key];
          }
        });
      });
      return trackedResult;
    }
    function useBaseQuery(options, Observer) {
      const queryClient = _reactquery.useQueryClient.call(void 0, { context: options.context });
      const isRestoring = _reactquery.useIsRestoring.call(void 0);
      const errorResetBoundary = _reactquery.useQueryErrorResetBoundary.call(void 0);
      const defaultedOptions = queryClient.defaultQueryOptions({
        ...options,
        queryKeyHashFn
      });
      defaultedOptions._optimisticResults = isRestoring ? "isRestoring" : "optimistic";
      if (defaultedOptions.onError) {
        defaultedOptions.onError = _reactquery.notifyManager.batchCalls(
          defaultedOptions.onError
        );
      }
      if (defaultedOptions.onSuccess) {
        defaultedOptions.onSuccess = _reactquery.notifyManager.batchCalls(
          defaultedOptions.onSuccess
        );
      }
      if (defaultedOptions.onSettled) {
        defaultedOptions.onSettled = _reactquery.notifyManager.batchCalls(
          defaultedOptions.onSettled
        );
      }
      if (defaultedOptions.suspense) {
        if (typeof defaultedOptions.staleTime !== "number") {
          defaultedOptions.staleTime = 1e3;
        }
      }
      if (defaultedOptions.suspense || defaultedOptions.useErrorBoundary) {
        if (!errorResetBoundary.isReset()) {
          defaultedOptions.retryOnMount = false;
        }
      }
      const [observer] = React2.useState(
        () => new Observer(
          queryClient,
          defaultedOptions
        )
      );
      const result = observer.getOptimisticResult(defaultedOptions);
      useSyncExternalStore2(
        React2.useCallback(
          (onStoreChange) => isRestoring ? () => void 0 : observer.subscribe(_reactquery.notifyManager.batchCalls(onStoreChange)),
          [observer, isRestoring]
        ),
        () => observer.getCurrentResult(),
        () => observer.getCurrentResult()
      );
      React2.useEffect(() => {
        errorResetBoundary.clearReset();
      }, [errorResetBoundary]);
      React2.useEffect(() => {
        observer.setOptions(defaultedOptions, { listeners: false });
      }, [defaultedOptions, observer]);
      if (defaultedOptions.suspense && result.isLoading && result.isFetching && !isRestoring) {
        throw observer.fetchOptimistic(defaultedOptions).then(({ data }) => {
          _optionalChain([defaultedOptions, "access", (_2) => _2.onSuccess, "optionalCall", (_3) => _3(data)]);
          _optionalChain([defaultedOptions, "access", (_4) => _4.onSettled, "optionalCall", (_5) => _5(data, null)]);
        }).catch((error) => {
          errorResetBoundary.clearReset();
          _optionalChain([defaultedOptions, "access", (_6) => _6.onError, "optionalCall", (_7) => _7(error)]);
          _optionalChain([defaultedOptions, "access", (_8) => _8.onSettled, "optionalCall", (_9) => _9(void 0, error)]);
        });
      }
      if (result.isError && !errorResetBoundary.isReset() && !result.isFetching && shouldThrowError(defaultedOptions.useErrorBoundary, [
        result.error,
        observer.getCurrentQuery()
      ])) {
        throw result.error;
      }
      const status = result.status === "loading" && result.fetchStatus === "idle" ? "idle" : result.status;
      const isIdle = status === "idle";
      const isLoading = status === "loading" && result.fetchStatus === "fetching";
      return {
        ...result,
        defaultedOptions,
        isIdle,
        isLoading,
        observer,
        status
      };
    }
    function useInfiniteQuery(arg1, arg2, arg3) {
      const parsedOptions = parseQueryArgs(arg1, arg2, arg3);
      const baseQuery = useBaseQuery(
        { context: queryClientContext, ...parsedOptions },
        _reactquery.InfiniteQueryObserver
      );
      const result = {
        data: baseQuery.data,
        error: baseQuery.error,
        fetchNextPage: baseQuery.fetchNextPage,
        fetchStatus: baseQuery.fetchStatus,
        hasNextPage: baseQuery.hasNextPage,
        isError: baseQuery.isError,
        isFetched: baseQuery.isFetched,
        isFetchedAfterMount: baseQuery.isFetchedAfterMount,
        isFetching: baseQuery.isFetching,
        isFetchingNextPage: baseQuery.isFetchingNextPage,
        isIdle: baseQuery.isIdle,
        isLoading: baseQuery.isLoading,
        isRefetching: baseQuery.isRefetching,
        isSuccess: baseQuery.isSuccess,
        refetch: baseQuery.refetch,
        status: baseQuery.status,
        internal: {
          dataUpdatedAt: baseQuery.dataUpdatedAt,
          errorUpdatedAt: baseQuery.errorUpdatedAt,
          failureCount: baseQuery.failureCount,
          isFetchedAfterMount: baseQuery.isFetchedAfterMount,
          isLoadingError: baseQuery.isLoadingError,
          isPaused: baseQuery.isPaused,
          isPlaceholderData: baseQuery.isPlaceholderData,
          isPreviousData: baseQuery.isPreviousData,
          isRefetchError: baseQuery.isRefetchError,
          isStale: baseQuery.isStale,
          remove: baseQuery.remove
        }
      };
      return !baseQuery.defaultedOptions.notifyOnChangeProps ? trackResult(result, baseQuery.observer) : result;
    }
    function useMutation(arg1, arg2, arg3) {
      const options = _reactquery.parseMutationArgs.call(void 0, arg1, arg2, arg3);
      return _reactquery.useMutation.call(void 0, { context: queryClientContext, ...options });
    }
    function useQuery(arg1, arg2, arg3) {
      const parsedOptions = parseQueryArgs(arg1, arg2, arg3);
      const baseQuery = useBaseQuery({ context: queryClientContext, ...parsedOptions }, _reactquery.QueryObserver);
      const result = {
        data: baseQuery.data,
        error: baseQuery.error,
        fetchStatus: baseQuery.fetchStatus,
        isError: baseQuery.isError,
        isFetched: baseQuery.isFetched,
        isFetchedAfterMount: baseQuery.isFetchedAfterMount,
        isFetching: baseQuery.isFetching,
        isIdle: baseQuery.isIdle,
        isLoading: baseQuery.isLoading,
        isRefetching: baseQuery.isRefetching,
        isSuccess: baseQuery.isSuccess,
        refetch: baseQuery.refetch,
        status: baseQuery.status,
        internal: {
          dataUpdatedAt: baseQuery.dataUpdatedAt,
          errorUpdatedAt: baseQuery.errorUpdatedAt,
          failureCount: baseQuery.failureCount,
          isFetchedAfterMount: baseQuery.isFetchedAfterMount,
          isLoadingError: baseQuery.isLoadingError,
          isPaused: baseQuery.isPaused,
          isPlaceholderData: baseQuery.isPlaceholderData,
          isPreviousData: baseQuery.isPreviousData,
          isRefetchError: baseQuery.isRefetchError,
          isStale: baseQuery.isStale,
          remove: baseQuery.remove
        }
      };
      return !baseQuery.defaultedOptions.notifyOnChangeProps ? trackResult(result, baseQuery.observer) : result;
    }
    var useQueryClient2 = () => _reactquery.useQueryClient.call(void 0, { context: queryClientContext });
    var _withselectorjs = require_with_selector();
    function usePublicClient({
      chainId
    } = {}) {
      return _withselectorjs.useSyncExternalStoreWithSelector.call(
        void 0,
        (cb) => _core.watchPublicClient.call(void 0, { chainId }, cb),
        () => _core.getPublicClient.call(void 0, { chainId }),
        () => _core.getPublicClient.call(void 0, { chainId }),
        (x) => x,
        (a, b) => a.uid === b.uid
      );
    }
    function queryKey({ chainId }) {
      return [{ entity: "walletClient", chainId, persist: false }];
    }
    function queryFn({
      queryKey: [{ chainId }]
    }) {
      return _core.getWalletClient.call(void 0, { chainId });
    }
    function useWalletClient({
      chainId: chainId_,
      suspense,
      onError,
      onSettled,
      onSuccess
    } = {}) {
      const { connector } = useAccount();
      const chainId = useChainId({ chainId: chainId_ });
      const walletClientQuery = useQuery(queryKey({ chainId }), queryFn, {
        cacheTime: 0,
        enabled: Boolean(connector),
        staleTime: Infinity,
        suspense,
        onError,
        onSettled,
        onSuccess
      });
      const queryClient = useQueryClient2();
      React3.useEffect(() => {
        const unwatch = _core.watchWalletClient.call(void 0, { chainId }, (walletClient) => {
          if (walletClient)
            queryClient.invalidateQueries(queryKey({ chainId }));
          else
            queryClient.removeQueries(queryKey({ chainId }));
        });
        return unwatch;
      }, [queryClient, chainId]);
      return walletClientQuery;
    }
    function useWebSocketPublicClient({ chainId } = {}) {
      return _withselectorjs.useSyncExternalStoreWithSelector.call(
        void 0,
        (cb) => _core.watchWebSocketPublicClient.call(void 0, { chainId }, cb),
        () => _core.getWebSocketPublicClient.call(void 0, { chainId }),
        () => _core.getWebSocketPublicClient.call(void 0, { chainId }),
        (x) => x,
        (a, b) => _optionalChain([a, "optionalAccess", (_10) => _10.uid]) === _optionalChain([b, "optionalAccess", (_11) => _11.uid])
      );
    }
    function useChainId({ chainId } = {}) {
      const publicClient = usePublicClient({ chainId });
      return publicClient.chain.id;
    }
    function useForceUpdate() {
      const [, forceUpdate] = React4.useReducer((x) => x + 1, 0);
      return forceUpdate;
    }
    function queryKey2({ chainId, scopeKey }) {
      return [{ entity: "blockNumber", chainId, scopeKey }];
    }
    function queryFn2({
      queryKey: [{ chainId }]
    }) {
      return _core.fetchBlockNumber.call(void 0, { chainId });
    }
    function useBlockNumber({
      cacheTime = 0,
      chainId: chainId_,
      enabled = true,
      scopeKey,
      staleTime,
      suspense,
      watch = false,
      onBlock,
      onError,
      onSettled,
      onSuccess
    } = {}) {
      const chainId = useChainId({ chainId: chainId_ });
      const publicClient = usePublicClient({ chainId });
      const webSocketPublicClient = useWebSocketPublicClient({ chainId });
      const queryClient = useQueryClient2();
      React5.useEffect(() => {
        if (!enabled)
          return;
        if (!watch && !onBlock)
          return;
        const publicClient_ = _nullishCoalesce(webSocketPublicClient, () => publicClient);
        const unwatch = publicClient_.watchBlockNumber({
          onBlockNumber: (blockNumber) => {
            if (watch)
              queryClient.setQueryData(queryKey2({ chainId, scopeKey }), blockNumber);
            if (onBlock)
              onBlock(blockNumber);
          },
          emitOnBegin: true
        });
        return unwatch;
      }, [
        chainId,
        scopeKey,
        onBlock,
        publicClient,
        queryClient,
        watch,
        webSocketPublicClient,
        enabled
      ]);
      return useQuery(queryKey2({ scopeKey, chainId }), queryFn2, {
        cacheTime,
        enabled,
        staleTime,
        suspense,
        onError,
        onSettled,
        onSuccess
      });
    }
    function queryKey3({
      chainId,
      formatUnits,
      scopeKey
    }) {
      return [{ entity: "feeData", chainId, formatUnits, scopeKey }];
    }
    function queryFn3({
      queryKey: [{ chainId, formatUnits }]
    }) {
      return _core.fetchFeeData.call(void 0, { chainId, formatUnits });
    }
    function useFeeData({
      cacheTime,
      chainId: chainId_,
      enabled = true,
      formatUnits = "gwei",
      scopeKey,
      staleTime,
      suspense,
      watch,
      onError,
      onSettled,
      onSuccess
    } = {}) {
      const chainId = useChainId({ chainId: chainId_ });
      const queryKey_ = React6.useMemo(
        () => queryKey3({
          chainId,
          formatUnits,
          scopeKey
        }),
        [chainId, formatUnits, scopeKey]
      );
      const feeDataQuery = useQuery(queryKey_, queryFn3, {
        cacheTime,
        enabled,
        staleTime,
        suspense,
        onError,
        onSettled,
        onSuccess
      });
      useInvalidateOnBlock({
        chainId,
        enabled: Boolean(enabled && watch),
        queryKey: queryKey_
      });
      return feeDataQuery;
    }
    function useInvalidateOnBlock({
      chainId,
      enabled,
      queryKey: queryKey17
    }) {
      const queryClient = useQueryClient2();
      const onBlock = React7.useCallback(
        () => queryClient.invalidateQueries({ queryKey: queryKey17 }, { cancelRefetch: false }),
        [queryClient, queryKey17]
      );
      useBlockNumber({
        chainId,
        enabled,
        onBlock: enabled ? onBlock : void 0,
        scopeKey: enabled ? void 0 : "idle"
      });
    }
    var isPlainObject2 = (obj) => typeof obj === "object" && !Array.isArray(obj);
    function useSyncExternalStoreWithTracked(subscribe, getSnapshot, getServerSnapshot = getSnapshot, isEqual = _core.deepEqual) {
      const trackedKeys = React8.useRef([]);
      const result = _withselectorjs.useSyncExternalStoreWithSelector.call(
        void 0,
        subscribe,
        getSnapshot,
        getServerSnapshot,
        (x) => x,
        (a, b) => {
          if (isPlainObject2(a) && isPlainObject2(b) && trackedKeys.current.length) {
            for (const key of trackedKeys.current) {
              const equal = isEqual(
                a[key],
                b[key]
              );
              if (!equal)
                return false;
            }
            return true;
          }
          return isEqual(a, b);
        }
      );
      if (isPlainObject2(result)) {
        const trackedResult = { ...result };
        Object.defineProperties(
          trackedResult,
          Object.entries(trackedResult).reduce(
            (res, [key, value]) => {
              return {
                ...res,
                [key]: {
                  configurable: false,
                  enumerable: true,
                  get: () => {
                    if (!trackedKeys.current.includes(key)) {
                      trackedKeys.current.push(key);
                    }
                    return value;
                  }
                }
              };
            },
            {}
          )
        );
        return trackedResult;
      }
      return result;
    }
    function useAccount({ onConnect, onDisconnect } = {}) {
      const config = useConfig();
      const watchAccount_ = React9.useCallback(
        (callback) => _core.watchAccount.call(void 0, callback),
        [config]
      );
      const account = useSyncExternalStoreWithTracked(watchAccount_, _core.getAccount);
      const previousAccountRef = React9.useRef();
      const previousAccount = previousAccountRef.current;
      React9.useEffect(() => {
        if (_optionalChain([previousAccount, "optionalAccess", (_12) => _12.status]) !== "connected" && account.status === "connected") {
          _optionalChain([onConnect, "optionalCall", (_13) => _13({
            address: account.address,
            connector: account.connector,
            isReconnected: _optionalChain([previousAccount, "optionalAccess", (_14) => _14.status]) === "reconnecting" || _optionalChain([previousAccount, "optionalAccess", (_15) => _15.status]) === void 0
          })]);
        }
        if (_optionalChain([previousAccount, "optionalAccess", (_16) => _16.status]) === "connected" && account.status === "disconnected") {
          _optionalChain([onDisconnect, "optionalCall", (_17) => _17()]);
        }
        previousAccountRef.current = account;
      }, [onConnect, onDisconnect, previousAccount, account]);
      return account;
    }
    function queryKey4({
      address,
      chainId,
      formatUnits,
      scopeKey,
      token
    }) {
      return [
        {
          entity: "balance",
          address,
          chainId,
          formatUnits,
          scopeKey,
          token
        }
      ];
    }
    function queryFn4({
      queryKey: [{ address, chainId, formatUnits, token }]
    }) {
      if (!address)
        throw new Error("address is required");
      return _core.fetchBalance.call(void 0, { address, chainId, formatUnits, token });
    }
    function useBalance({
      address,
      cacheTime,
      chainId: chainId_,
      enabled = true,
      formatUnits,
      scopeKey,
      staleTime,
      suspense,
      token,
      watch,
      onError,
      onSettled,
      onSuccess
    } = {}) {
      const chainId = useChainId({ chainId: chainId_ });
      const queryKey_ = React10.useMemo(
        () => queryKey4({ address, chainId, formatUnits, scopeKey, token }),
        [address, chainId, formatUnits, scopeKey, token]
      );
      const balanceQuery = useQuery(queryKey_, queryFn4, {
        cacheTime,
        enabled: Boolean(enabled && address),
        staleTime,
        suspense,
        onError,
        onSettled,
        onSuccess
      });
      useInvalidateOnBlock({
        chainId,
        enabled: Boolean(enabled && watch && address),
        queryKey: queryKey_
      });
      return balanceQuery;
    }
    var mutationKey = (args) => [{ entity: "connect", ...args }];
    var mutationFn = (args) => {
      const { connector, chainId } = args;
      if (!connector)
        throw new Error("connector is required");
      return _core.connect.call(void 0, { connector, chainId });
    };
    function useConnect({
      chainId,
      connector,
      onError,
      onMutate,
      onSettled,
      onSuccess
    } = {}) {
      const config = useConfig();
      const {
        data,
        error,
        isError,
        isIdle,
        isLoading,
        isSuccess,
        mutate,
        mutateAsync,
        reset,
        status,
        variables
      } = useMutation(mutationKey({ connector, chainId }), mutationFn, {
        onError,
        onMutate,
        onSettled,
        onSuccess
      });
      const connect2 = React11.useCallback(
        (args) => {
          return mutate({
            chainId: _nullishCoalesce(_optionalChain([args, "optionalAccess", (_18) => _18.chainId]), () => chainId),
            connector: _nullishCoalesce(_optionalChain([args, "optionalAccess", (_19) => _19.connector]), () => connector)
          });
        },
        [chainId, connector, mutate]
      );
      const connectAsync = React11.useCallback(
        (args) => {
          return mutateAsync({
            chainId: _nullishCoalesce(_optionalChain([args, "optionalAccess", (_20) => _20.chainId]), () => chainId),
            connector: _nullishCoalesce(_optionalChain([args, "optionalAccess", (_21) => _21.connector]), () => connector)
          });
        },
        [chainId, connector, mutateAsync]
      );
      return {
        connect: connect2,
        connectAsync,
        connectors: config.connectors,
        data,
        error,
        isError,
        isIdle,
        isLoading,
        isSuccess,
        pendingConnector: _optionalChain([variables, "optionalAccess", (_22) => _22.connector]),
        reset,
        status,
        variables
      };
    }
    var mutationKey2 = [{ entity: "disconnect" }];
    var mutationFn2 = () => _core.disconnect.call(void 0);
    function useDisconnect({
      onError,
      onMutate,
      onSettled,
      onSuccess
    } = {}) {
      const {
        error,
        isError,
        isIdle,
        isLoading,
        isSuccess,
        mutate: disconnect2,
        mutateAsync: disconnectAsync,
        reset,
        status
      } = useMutation(mutationKey2, mutationFn2, {
        ...onError ? {
          onError(error2, _variables, context) {
            onError(error2, context);
          }
        } : {},
        onMutate,
        ...onSettled ? {
          onSettled(_data, error2, _variables, context) {
            onSettled(error2, context);
          }
        } : {},
        ...onSuccess ? {
          onSuccess(_data, _variables, context) {
            onSuccess(context);
          }
        } : {}
      });
      return {
        disconnect: disconnect2,
        disconnectAsync,
        error,
        isError,
        isIdle,
        isLoading,
        isSuccess,
        reset,
        status
      };
    }
    function useNetwork() {
      const config = useConfig();
      const watchNetwork_ = _react.useCallback.call(
        void 0,
        (callback) => _core.watchNetwork.call(void 0, callback),
        [config]
      );
      return useSyncExternalStoreWithTracked(watchNetwork_, _core.getNetwork);
    }
    var mutationKey3 = (args) => [{ entity: "signMessage", ...args }];
    var mutationFn3 = (args) => {
      const { message } = args;
      if (!message)
        throw new Error("message is required");
      return _core.signMessage.call(void 0, { message });
    };
    function useSignMessage({
      message,
      onError,
      onMutate,
      onSettled,
      onSuccess
    } = {}) {
      const {
        data,
        error,
        isError,
        isIdle,
        isLoading,
        isSuccess,
        mutate,
        mutateAsync,
        reset,
        status,
        variables
      } = useMutation(mutationKey3({ message }), mutationFn3, {
        onError,
        onMutate,
        onSettled,
        onSuccess
      });
      const signMessage2 = React12.useCallback(
        (args) => mutate(args || { message }),
        [message, mutate]
      );
      const signMessageAsync = React12.useCallback(
        (args) => mutateAsync(args || { message }),
        [message, mutateAsync]
      );
      return {
        data,
        error,
        isError,
        isIdle,
        isLoading,
        isSuccess,
        reset,
        signMessage: signMessage2,
        signMessageAsync,
        status,
        variables
      };
    }
    function mutationKey4({ domain, types, message, primaryType }) {
      return [
        { entity: "signTypedData", domain, types, message, primaryType }
      ];
    }
    function mutationFn4(args) {
      const { domain, types, primaryType, message } = args;
      if (!domain)
        throw new Error("domain is required");
      if (!types)
        throw new Error("types is required");
      if (!primaryType)
        throw new Error("primaryType is required");
      if (!message)
        throw new Error("message is required");
      return _core.signTypedData.call(void 0, {
        domain,
        message,
        primaryType,
        types
      });
    }
    function useSignTypedData({
      domain,
      types,
      message,
      primaryType,
      onError,
      onMutate,
      onSettled,
      onSuccess
    } = {}) {
      const {
        data,
        error,
        isError,
        isIdle,
        isLoading,
        isSuccess,
        mutate,
        mutateAsync,
        reset,
        status,
        variables
      } = useMutation(
        mutationKey4({
          domain,
          message,
          primaryType,
          types
        }),
        mutationFn4,
        {
          onError,
          onMutate,
          onSettled,
          onSuccess
        }
      );
      const signTypedData2 = React13.useCallback(
        (args) => mutate({
          domain: _nullishCoalesce(_optionalChain([args, "optionalAccess", (_23) => _23.domain]), () => domain),
          types: _nullishCoalesce(_optionalChain([args, "optionalAccess", (_24) => _24.types]), () => types),
          message: _nullishCoalesce(_optionalChain([args, "optionalAccess", (_25) => _25.message]), () => message),
          primaryType: _nullishCoalesce(_optionalChain([args, "optionalAccess", (_26) => _26.primaryType]), () => primaryType)
        }),
        [domain, types, primaryType, message, mutate]
      );
      const signTypedDataAsync = React13.useCallback(
        (args) => mutateAsync({
          domain: _nullishCoalesce(_optionalChain([args, "optionalAccess", (_27) => _27.domain]), () => domain),
          types: _nullishCoalesce(_optionalChain([args, "optionalAccess", (_28) => _28.types]), () => types),
          message: _nullishCoalesce(_optionalChain([args, "optionalAccess", (_29) => _29.message]), () => message),
          primaryType: _nullishCoalesce(_optionalChain([args, "optionalAccess", (_30) => _30.primaryType]), () => primaryType)
        }),
        [domain, types, primaryType, message, mutateAsync]
      );
      return {
        data,
        error,
        isError,
        isIdle,
        isLoading,
        isSuccess,
        reset,
        signTypedData: signTypedData2,
        signTypedDataAsync,
        status,
        variables
      };
    }
    var mutationKey5 = (args) => [{ entity: "switchNetwork", ...args }];
    var mutationFn5 = (args) => {
      const { chainId } = args;
      if (!chainId)
        throw new Error("chainId is required");
      return _core.switchNetwork.call(void 0, { chainId });
    };
    function useSwitchNetwork({
      chainId,
      throwForSwitchChainNotSupported,
      onError,
      onMutate,
      onSettled,
      onSuccess
    } = {}) {
      const config = useConfig();
      const forceUpdate = useForceUpdate();
      const {
        data,
        error,
        isError,
        isIdle,
        isLoading,
        isSuccess,
        mutate,
        mutateAsync,
        reset,
        status,
        variables
      } = useMutation(mutationKey5({ chainId }), mutationFn5, {
        onError,
        onMutate,
        onSettled,
        onSuccess
      });
      const switchNetwork_ = React14.useCallback(
        (chainId_) => mutate({ chainId: _nullishCoalesce(chainId_, () => chainId) }),
        [chainId, mutate]
      );
      const switchNetworkAsync_ = React14.useCallback(
        (chainId_) => mutateAsync({ chainId: _nullishCoalesce(chainId_, () => chainId) }),
        [chainId, mutateAsync]
      );
      React14.useEffect(() => {
        const unwatch = config.subscribe(
          ({ chains, connector }) => ({
            chains,
            connector
          }),
          forceUpdate
        );
        return unwatch;
      }, [config, forceUpdate]);
      let switchNetwork2;
      let switchNetworkAsync;
      const supportsSwitchChain = !!_optionalChain([config, "access", (_31) => _31.connector, "optionalAccess", (_32) => _32.switchChain]);
      if (throwForSwitchChainNotSupported || supportsSwitchChain) {
        switchNetwork2 = switchNetwork_;
        switchNetworkAsync = switchNetworkAsync_;
      }
      return {
        chains: _nullishCoalesce(config.chains, () => []),
        data,
        error,
        isError,
        isIdle,
        isLoading,
        isSuccess,
        pendingChainId: _optionalChain([variables, "optionalAccess", (_33) => _33.chainId]),
        reset,
        status,
        switchNetwork: switchNetwork2,
        switchNetworkAsync,
        variables
      };
    }
    function useContractEvent({
      address,
      chainId,
      abi,
      listener,
      eventName
    } = {}) {
      const publicClient = usePublicClient({ chainId });
      const webSocketPublicClient = useWebSocketPublicClient({ chainId });
      const unwatch = React15.useRef();
      React15.useEffect(() => {
        if (!abi || !address || !eventName)
          return;
        const publicClient_ = webSocketPublicClient || publicClient;
        unwatch.current = publicClient_.watchContractEvent({
          abi,
          address,
          eventName,
          onLogs: listener
        });
        return unwatch.current;
      }, [abi, address, eventName, publicClient.uid, _optionalChain([webSocketPublicClient, "optionalAccess", (_34) => _34.uid])]);
      return unwatch.current;
    }
    function queryKey5({
      allowFailure,
      blockNumber,
      blockTag,
      cacheKey,
      scopeKey
    }) {
      return [
        {
          entity: "readContractsInfinite",
          allowFailure,
          blockNumber,
          blockTag,
          cacheKey,
          scopeKey
        }
      ];
    }
    function queryFn5({
      contracts
    }) {
      return ({
        queryKey: [{ allowFailure, blockNumber, blockTag }],
        pageParam
      }) => {
        return _core.readContracts.call(void 0, {
          allowFailure,
          blockNumber,
          blockTag,
          contracts: contracts(pageParam || void 0)
        });
      };
    }
    function useContractInfiniteReads({
      allowFailure,
      blockNumber,
      blockTag,
      cacheKey,
      cacheTime,
      contracts,
      enabled: enabled_ = true,
      getNextPageParam,
      isDataEqual,
      keepPreviousData,
      onError,
      onSettled,
      onSuccess,
      scopeKey,
      select,
      staleTime,
      structuralSharing = (oldData, newData) => _core.deepEqual.call(void 0, oldData, newData) ? oldData : _reactquery.replaceEqualDeep.call(void 0, oldData, newData),
      suspense
    }) {
      const queryKey_ = React16.useMemo(
        () => queryKey5({ allowFailure, blockNumber, blockTag, cacheKey, scopeKey }),
        [allowFailure, blockNumber, blockTag, cacheKey, scopeKey]
      );
      const enabled = React16.useMemo(() => {
        const enabled2 = Boolean(enabled_ && contracts);
        return enabled2;
      }, [contracts, enabled_]);
      return useInfiniteQuery(queryKey_, queryFn5({ contracts }), {
        cacheTime,
        enabled,
        getNextPageParam,
        isDataEqual,
        keepPreviousData,
        select,
        staleTime,
        structuralSharing,
        suspense,
        onError,
        onSettled,
        onSuccess
      });
    }
    function paginatedIndexesConfig(fn, {
      perPage,
      start,
      direction
    }) {
      const contracts = (page = 0) => [...Array(perPage).keys()].map((index) => {
        return direction === "increment" ? start + index + page * perPage : start - index - page * perPage;
      }).filter((index) => index >= 0).flatMap(fn);
      return {
        contracts,
        getNextPageParam(lastPage, pages) {
          return _optionalChain([lastPage, "optionalAccess", (_35) => _35.length]) === perPage ? pages.length : void 0;
        }
      };
    }
    function queryKey6({
      account,
      address,
      args,
      blockNumber,
      blockTag,
      chainId,
      functionName,
      scopeKey
    }) {
      return [
        {
          entity: "readContract",
          account,
          address,
          args,
          blockNumber,
          blockTag,
          chainId,
          functionName,
          scopeKey
        }
      ];
    }
    function queryFn6({ abi }) {
      return async ({
        queryKey: [
          { account, address, args, blockNumber, blockTag, chainId, functionName }
        ]
      }) => {
        if (!abi)
          throw new Error("abi is required");
        if (!address)
          throw new Error("address is required");
        return await _asyncNullishCoalesce(await _core.readContract.call(void 0, {
          account,
          address,
          args,
          blockNumber,
          blockTag,
          chainId,
          abi,
          functionName
        }), async () => null);
      };
    }
    function useContractRead({
      abi,
      address,
      account,
      args,
      blockNumber: blockNumberOverride,
      blockTag,
      cacheOnBlock = false,
      cacheTime,
      chainId: chainId_,
      enabled: enabled_ = true,
      functionName,
      isDataEqual,
      keepPreviousData,
      onError,
      onSettled,
      onSuccess,
      scopeKey,
      select,
      staleTime,
      structuralSharing = (oldData, newData) => _core.deepEqual.call(void 0, oldData, newData) ? oldData : _reactquery.replaceEqualDeep.call(void 0, oldData, newData),
      suspense,
      watch
    } = {}) {
      const chainId = useChainId({ chainId: chainId_ });
      const { data: blockNumber_ } = useBlockNumber({
        chainId,
        enabled: watch || cacheOnBlock,
        scopeKey: watch || cacheOnBlock ? void 0 : "idle",
        watch
      });
      const blockNumber = _nullishCoalesce(blockNumberOverride, () => blockNumber_);
      const queryKey_ = React17.useMemo(
        () => queryKey6({
          account,
          address,
          args,
          blockNumber: cacheOnBlock ? blockNumber : void 0,
          blockTag,
          chainId,
          functionName,
          scopeKey
        }),
        [
          account,
          address,
          args,
          blockNumber,
          blockTag,
          cacheOnBlock,
          chainId,
          functionName,
          scopeKey
        ]
      );
      const enabled = React17.useMemo(() => {
        let enabled2 = Boolean(enabled_ && abi && address && functionName);
        if (cacheOnBlock)
          enabled2 = Boolean(enabled2 && blockNumber);
        return enabled2;
      }, [abi, address, blockNumber, cacheOnBlock, enabled_, functionName]);
      useInvalidateOnBlock({
        chainId,
        enabled: Boolean(enabled && watch && !cacheOnBlock),
        queryKey: queryKey_
      });
      return useQuery(
        queryKey_,
        queryFn6({
          abi
        }),
        {
          cacheTime,
          enabled,
          isDataEqual,
          keepPreviousData,
          select,
          staleTime,
          structuralSharing,
          suspense,
          onError,
          onSettled,
          onSuccess
        }
      );
    }
    function queryKey7({
      allowFailure,
      blockNumber,
      blockTag,
      chainId,
      contracts,
      scopeKey
    }) {
      return [
        {
          entity: "readContracts",
          allowFailure,
          blockNumber,
          blockTag,
          chainId,
          scopeKey,
          contracts: _nullishCoalesce(contracts, () => []).map(({ address, args, chainId: chainId2, functionName }) => ({
            address,
            args,
            chainId: chainId2,
            functionName
          }))
        }
      ];
    }
    function queryFn7({ abis }) {
      return ({
        queryKey: [{ allowFailure, blockNumber, blockTag, contracts: contracts_ }]
      }) => {
        const contracts = contracts_.map((contract, i) => ({
          ...contract,
          abi: abis[i]
        }));
        return _core.readContracts.call(void 0, {
          allowFailure,
          contracts,
          blockNumber,
          blockTag
        });
      };
    }
    function useContractReads({
      allowFailure: allowFailure_,
      blockNumber: blockNumberOverride,
      blockTag,
      cacheOnBlock = false,
      cacheTime,
      contracts,
      enabled: enabled_ = true,
      isDataEqual,
      keepPreviousData,
      onError,
      onSettled,
      onSuccess,
      scopeKey,
      select,
      staleTime,
      structuralSharing = (oldData, newData) => _core.deepEqual.call(void 0, oldData, newData) ? oldData : _reactquery.replaceEqualDeep.call(void 0, oldData, newData),
      suspense,
      watch
    } = {}) {
      const allowFailure = _nullishCoalesce(allowFailure_, () => true);
      const { data: blockNumber_ } = useBlockNumber({
        enabled: watch || cacheOnBlock,
        watch
      });
      const chainId = useChainId();
      const blockNumber = _nullishCoalesce(blockNumberOverride, () => blockNumber_);
      const queryKey_ = React18.useMemo(
        () => queryKey7({
          allowFailure,
          blockNumber: cacheOnBlock ? blockNumber : void 0,
          blockTag,
          chainId,
          contracts,
          scopeKey
        }),
        [
          allowFailure,
          blockNumber,
          blockTag,
          cacheOnBlock,
          chainId,
          scopeKey,
          contracts
        ]
      );
      const enabled = React18.useMemo(() => {
        let enabled2 = Boolean(
          enabled_ && _optionalChain([contracts, "optionalAccess", (_36) => _36.every, "call", (_37) => _37(
            (x) => x.abi && x.address && x.functionName
          )])
        );
        if (cacheOnBlock)
          enabled2 = Boolean(enabled2 && blockNumber);
        return enabled2;
      }, [blockNumber, cacheOnBlock, contracts, enabled_]);
      useInvalidateOnBlock({
        enabled: Boolean(enabled && watch && !cacheOnBlock),
        queryKey: queryKey_
      });
      const abis = _nullishCoalesce(contracts, () => []).map(
        ({ abi }) => abi
      );
      return useQuery(queryKey_, queryFn7({ abis }), {
        cacheTime,
        enabled,
        isDataEqual,
        keepPreviousData,
        staleTime,
        select,
        structuralSharing,
        suspense,
        onError,
        onSettled,
        onSuccess
      });
    }
    var _internal = require_internal();
    function mutationKey6({
      address,
      abi,
      functionName,
      ...config
    }) {
      const {
        args,
        accessList,
        account,
        gas,
        gasPrice,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        request,
        value
      } = config;
      return [
        {
          entity: "writeContract",
          address,
          args,
          abi,
          accessList,
          account,
          functionName,
          gas,
          gasPrice,
          maxFeePerGas,
          maxPriorityFeePerGas,
          nonce,
          request,
          value
        }
      ];
    }
    function mutationFn6(config) {
      if (config.mode === "prepared") {
        if (!config.request)
          throw new Error("request is required");
        return _core.writeContract.call(void 0, {
          mode: "prepared",
          request: config.request
        });
      }
      if (!config.address)
        throw new Error("address is required");
      if (!config.abi)
        throw new Error("abi is required");
      if (!config.functionName)
        throw new Error("functionName is required");
      return _core.writeContract.call(void 0, {
        address: config.address,
        args: config.args,
        chainId: config.chainId,
        abi: config.abi,
        functionName: config.functionName,
        accessList: config.accessList,
        account: config.account,
        gas: config.gas,
        gasPrice: config.gasPrice,
        maxFeePerGas: config.maxFeePerGas,
        maxPriorityFeePerGas: config.maxPriorityFeePerGas,
        nonce: config.nonce,
        value: config.value
      });
    }
    function useContractWrite(config) {
      const { address, abi, args, chainId, functionName, mode, request } = config;
      const {
        accessList,
        account,
        gas,
        gasPrice,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        value
      } = _internal.getSendTransactionParameters.call(void 0, config);
      const {
        data,
        error,
        isError,
        isIdle,
        isLoading,
        isSuccess,
        mutate,
        mutateAsync,
        reset,
        status,
        variables
      } = useMutation(
        mutationKey6({
          address,
          abi,
          functionName,
          chainId,
          mode,
          args,
          accessList,
          account,
          gas,
          gasPrice,
          maxFeePerGas,
          maxPriorityFeePerGas,
          nonce,
          request,
          value
        }),
        mutationFn6,
        {
          onError: config.onError,
          onMutate: config.onMutate,
          onSettled: config.onSettled,
          onSuccess: config.onSuccess
        }
      );
      const write = React19.useMemo(() => {
        if (config.mode === "prepared") {
          if (!request)
            return void 0;
          return () => mutate({
            mode: "prepared",
            request: config.request,
            chainId: config.chainId
          });
        }
        return (overrideConfig) => mutate({
          address,
          args,
          abi,
          functionName,
          chainId,
          accessList,
          account,
          gas,
          gasPrice,
          maxFeePerGas,
          maxPriorityFeePerGas,
          nonce,
          value,
          ...overrideConfig
        });
      }, [
        accessList,
        account,
        abi,
        address,
        args,
        chainId,
        config.chainId,
        config.mode,
        config.request,
        functionName,
        gas,
        gasPrice,
        maxFeePerGas,
        maxPriorityFeePerGas,
        mutate,
        nonce,
        request,
        value
      ]);
      const writeAsync = React19.useMemo(() => {
        if (config.mode === "prepared") {
          if (!request)
            return void 0;
          return () => mutateAsync({
            mode: "prepared",
            request: config.request
          });
        }
        return (overrideConfig) => mutateAsync({
          address,
          args,
          abi,
          chainId,
          functionName,
          accessList,
          account,
          gas,
          gasPrice,
          maxFeePerGas,
          maxPriorityFeePerGas,
          nonce,
          value,
          ...overrideConfig
        });
      }, [
        accessList,
        account,
        abi,
        address,
        args,
        chainId,
        config.mode,
        config.request,
        functionName,
        gas,
        gasPrice,
        maxFeePerGas,
        maxPriorityFeePerGas,
        mutateAsync,
        nonce,
        request,
        value
      ]);
      return {
        data,
        error,
        isError,
        isIdle,
        isLoading,
        isSuccess,
        reset,
        status,
        variables,
        write,
        writeAsync
      };
    }
    function queryKey8({
      accessList,
      account,
      activeChainId,
      args,
      address,
      blockNumber,
      blockTag,
      chainId,
      functionName,
      gas,
      gasPrice,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      scopeKey,
      walletClientAddress,
      value
    }) {
      return [
        {
          entity: "prepareContractTransaction",
          accessList,
          account,
          activeChainId,
          address,
          args,
          blockNumber,
          blockTag,
          chainId,
          functionName,
          gas,
          gasPrice,
          maxFeePerGas,
          maxPriorityFeePerGas,
          nonce,
          scopeKey,
          walletClientAddress,
          value
        }
      ];
    }
    function queryFn8({
      abi,
      walletClient
    }) {
      return ({
        queryKey: [
          {
            accessList,
            account,
            args,
            address,
            blockNumber,
            blockTag,
            chainId,
            functionName,
            gas,
            gasPrice,
            maxFeePerGas,
            maxPriorityFeePerGas,
            nonce,
            value
          }
        ]
      }) => {
        if (!abi)
          throw new Error("abi is required");
        if (!address)
          throw new Error("address is required");
        if (!functionName)
          throw new Error("functionName is required");
        return _core.prepareWriteContract.call(void 0, {
          abi,
          accessList,
          account,
          args,
          address,
          blockNumber,
          blockTag,
          chainId,
          functionName,
          gas,
          gasPrice,
          maxFeePerGas,
          maxPriorityFeePerGas,
          nonce,
          walletClient,
          value
        });
      };
    }
    function usePrepareContractWrite({
      address,
      abi,
      functionName,
      chainId,
      args,
      cacheTime,
      enabled = true,
      scopeKey,
      staleTime,
      suspense,
      onError,
      onSettled,
      onSuccess,
      ...config
    } = {}) {
      const { chain: activeChain } = useNetwork();
      const { data: walletClient } = useWalletClient({ chainId });
      const {
        accessList,
        account,
        blockNumber,
        blockTag,
        gas,
        gasPrice,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        value
      } = _internal.getCallParameters.call(void 0, config);
      const prepareContractWriteQuery = useQuery(
        queryKey8({
          accessList,
          account,
          activeChainId: _optionalChain([activeChain, "optionalAccess", (_38) => _38.id]),
          address,
          args,
          blockNumber,
          blockTag,
          chainId,
          functionName,
          gas,
          gasPrice,
          maxFeePerGas,
          maxPriorityFeePerGas,
          nonce,
          scopeKey,
          walletClientAddress: _optionalChain([walletClient, "optionalAccess", (_39) => _39.account, "access", (_40) => _40.address]),
          value
        }),
        queryFn8({
          abi,
          walletClient
        }),
        {
          cacheTime,
          enabled: Boolean(
            enabled && abi && address && functionName && walletClient
          ),
          staleTime,
          suspense,
          onError,
          onSettled,
          onSuccess
        }
      );
      return Object.assign(prepareContractWriteQuery, {
        config: {
          chainId,
          mode: "prepared",
          request: void 0,
          ...prepareContractWriteQuery.data
        }
      });
    }
    function queryKey9({
      address,
      chainId,
      formatUnits,
      scopeKey
    }) {
      return [{ entity: "token", address, chainId, formatUnits, scopeKey }];
    }
    function queryFn9({
      queryKey: [{ address, chainId, formatUnits }]
    }) {
      if (!address)
        throw new Error("address is required");
      return _core.fetchToken.call(void 0, { address, chainId, formatUnits });
    }
    function useToken({
      address,
      chainId: chainId_,
      formatUnits = "ether",
      cacheTime,
      enabled = true,
      scopeKey,
      staleTime = 1e3 * 60 * 60 * 24,
      suspense,
      onError,
      onSettled,
      onSuccess
    } = {}) {
      const chainId = useChainId({ chainId: chainId_ });
      return useQuery(
        queryKey9({ address, chainId, formatUnits, scopeKey }),
        queryFn9,
        {
          cacheTime,
          enabled: Boolean(enabled && address),
          staleTime,
          suspense,
          onError,
          onSettled,
          onSuccess
        }
      );
    }
    function queryKey10({ chainId, name, scopeKey }) {
      return [{ entity: "ensAddress", chainId, name, scopeKey }];
    }
    function queryFn10({
      queryKey: [{ chainId, name }]
    }) {
      if (!name)
        throw new Error("name is required");
      return _core.fetchEnsAddress.call(void 0, { chainId, name });
    }
    function useEnsAddress({
      cacheTime,
      chainId: chainId_,
      enabled = true,
      name,
      scopeKey,
      staleTime = 1e3 * 60 * 60 * 24,
      suspense,
      onError,
      onSettled,
      onSuccess
    } = {}) {
      const chainId = useChainId({ chainId: chainId_ });
      return useQuery(queryKey10({ chainId, name, scopeKey }), queryFn10, {
        cacheTime,
        enabled: Boolean(enabled && chainId && name),
        staleTime,
        suspense,
        onError,
        onSettled,
        onSuccess
      });
    }
    function queryKey11({ name, chainId, scopeKey }) {
      return [{ entity: "ensAvatar", name, chainId, scopeKey }];
    }
    function queryFn11({
      queryKey: [{ name, chainId }]
    }) {
      if (!name)
        throw new Error("name is required");
      return _core.fetchEnsAvatar.call(void 0, { name, chainId });
    }
    function useEnsAvatar({
      cacheTime,
      chainId: chainId_,
      enabled = true,
      name,
      scopeKey,
      staleTime = 1e3 * 60 * 60 * 24,
      suspense,
      onError,
      onSettled,
      onSuccess
    } = {}) {
      const chainId = useChainId({ chainId: chainId_ });
      return useQuery(queryKey11({ name, chainId, scopeKey }), queryFn11, {
        cacheTime,
        enabled: Boolean(enabled && name && chainId),
        staleTime,
        suspense,
        onError,
        onSettled,
        onSuccess
      });
    }
    function queryKey12({
      address,
      chainId,
      scopeKey
    }) {
      return [{ entity: "ensName", address, chainId, scopeKey }];
    }
    function queryFn12({
      queryKey: [{ address, chainId }]
    }) {
      if (!address)
        throw new Error("address is required");
      return _core.fetchEnsName.call(void 0, { address, chainId });
    }
    function useEnsName({
      address,
      cacheTime,
      chainId: chainId_,
      enabled = true,
      scopeKey,
      staleTime = 1e3 * 60 * 60 * 24,
      suspense,
      onError,
      onSettled,
      onSuccess
    } = {}) {
      const chainId = useChainId({ chainId: chainId_ });
      return useQuery(queryKey12({ address, chainId, scopeKey }), queryFn12, {
        cacheTime,
        enabled: Boolean(enabled && address && chainId),
        staleTime,
        suspense,
        onError,
        onSettled,
        onSuccess
      });
    }
    function queryKey13({ chainId, name, scopeKey }) {
      return [
        { entity: "ensResolver", chainId, name, scopeKey, persist: false }
      ];
    }
    function queryFn13({
      queryKey: [{ chainId, name }]
    }) {
      if (!name)
        throw new Error("name is required");
      return _core.fetchEnsResolver.call(void 0, { chainId, name });
    }
    function useEnsResolver({
      chainId: chainId_,
      name,
      enabled = true,
      scopeKey,
      suspense,
      onError,
      onSettled,
      onSuccess
    } = {}) {
      const chainId = useChainId({ chainId: chainId_ });
      return useQuery(queryKey13({ chainId, name, scopeKey }), queryFn13, {
        cacheTime: 0,
        enabled: Boolean(enabled && chainId && name),
        suspense,
        onError,
        onSettled,
        onSuccess
      });
    }
    function queryKey14({
      accessList,
      account,
      activeChainId,
      chainId,
      data,
      gas,
      gasPrice,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to,
      value,
      scopeKey,
      walletClientAddress
    }) {
      return [
        {
          entity: "prepareSendTransaction",
          activeChainId,
          accessList,
          account,
          chainId,
          data,
          gas,
          gasPrice,
          maxFeePerGas,
          maxPriorityFeePerGas,
          nonce,
          to,
          value,
          scopeKey,
          walletClientAddress
        }
      ];
    }
    function queryFn14({ walletClient }) {
      return ({
        queryKey: [
          {
            accessList,
            account,
            chainId,
            data,
            gas,
            gasPrice,
            maxFeePerGas,
            maxPriorityFeePerGas,
            nonce,
            to,
            value
          }
        ]
      }) => {
        if (!to)
          throw new Error("to is required");
        return _core.prepareSendTransaction.call(void 0, {
          accessList,
          account,
          chainId,
          data,
          gas,
          gasPrice,
          maxFeePerGas,
          maxPriorityFeePerGas,
          nonce,
          to,
          value,
          walletClient
        });
      };
    }
    function usePrepareSendTransaction({
      accessList,
      account,
      chainId,
      cacheTime,
      data,
      enabled = true,
      gas,
      gasPrice,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      scopeKey,
      staleTime,
      suspense,
      to,
      value,
      onError,
      onSettled,
      onSuccess
    } = {}) {
      const { chain: activeChain } = useNetwork();
      const { data: walletClient } = useWalletClient({ chainId });
      const prepareSendTransactionQuery = useQuery(
        queryKey14({
          accessList,
          activeChainId: _optionalChain([activeChain, "optionalAccess", (_41) => _41.id]),
          account,
          chainId,
          data,
          gas,
          gasPrice,
          maxFeePerGas,
          maxPriorityFeePerGas,
          nonce,
          scopeKey,
          to,
          value,
          walletClientAddress: _optionalChain([walletClient, "optionalAccess", (_42) => _42.account, "access", (_43) => _43.address])
        }),
        queryFn14({ walletClient }),
        {
          cacheTime,
          enabled: Boolean(enabled && walletClient && to),
          staleTime,
          suspense,
          onError,
          onSettled,
          onSuccess
        }
      );
      return Object.assign(prepareSendTransactionQuery, {
        config: {
          mode: "prepared",
          ...prepareSendTransactionQuery.isSuccess ? prepareSendTransactionQuery.data : void 0
        }
      });
    }
    var mutationKey7 = (args) => [{ entity: "sendTransaction", ...args }];
    var mutationFn7 = ({
      accessList,
      account,
      chainId,
      data,
      gas,
      gasPrice,
      maxFeePerGas,
      maxPriorityFeePerGas,
      mode,
      nonce,
      to,
      value
    }) => {
      if (!to)
        throw new Error("to is required.");
      return _core.sendTransaction.call(void 0, {
        accessList,
        account,
        chainId,
        data,
        gas,
        gasPrice,
        maxFeePerGas,
        maxPriorityFeePerGas,
        mode,
        nonce,
        to,
        value
      });
    };
    function useSendTransaction({
      accessList,
      account,
      chainId,
      data: data_,
      gas,
      gasPrice,
      maxFeePerGas,
      maxPriorityFeePerGas,
      mode,
      nonce,
      to,
      value,
      onError,
      onMutate,
      onSettled,
      onSuccess
    } = {}) {
      const {
        data,
        error,
        isError,
        isIdle,
        isLoading,
        isSuccess,
        mutate,
        mutateAsync,
        reset,
        status,
        variables
      } = useMutation(
        mutationKey7({
          accessList,
          account,
          chainId,
          data: data_,
          gas,
          gasPrice,
          maxFeePerGas,
          maxPriorityFeePerGas,
          mode,
          nonce,
          to,
          value
        }),
        mutationFn7,
        {
          onError,
          onMutate,
          onSettled,
          onSuccess
        }
      );
      const sendTransaction2 = React20.useCallback(
        (args) => mutate({
          chainId,
          mode,
          ...args || {
            accessList,
            account,
            chainId,
            data: data_,
            gas,
            gasPrice,
            maxFeePerGas,
            maxPriorityFeePerGas,
            mode,
            nonce,
            value,
            to
          }
        }),
        [
          accessList,
          account,
          chainId,
          data_,
          gas,
          gasPrice,
          maxFeePerGas,
          maxPriorityFeePerGas,
          mode,
          mutate,
          nonce,
          to,
          value
        ]
      );
      const sendTransactionAsync = React20.useCallback(
        (args) => mutateAsync({
          chainId,
          mode,
          ...args || {
            accessList,
            account,
            chainId,
            data: data_,
            gas,
            gasPrice,
            maxFeePerGas,
            maxPriorityFeePerGas,
            mode,
            nonce,
            value,
            to
          }
        }),
        [
          accessList,
          account,
          chainId,
          data_,
          gas,
          gasPrice,
          maxFeePerGas,
          maxPriorityFeePerGas,
          mode,
          mutateAsync,
          nonce,
          to,
          value
        ]
      );
      return {
        data,
        error,
        isError,
        isIdle,
        isLoading,
        isSuccess,
        reset,
        sendTransaction: mode === "prepared" && !to ? void 0 : sendTransaction2,
        sendTransactionAsync: mode === "prepared" && !to ? void 0 : sendTransactionAsync,
        status,
        variables
      };
    }
    function queryKey15({ chainId, hash, scopeKey }) {
      return [{ entity: "transaction", chainId, hash, scopeKey }];
    }
    function queryFn15({
      queryKey: [{ chainId, hash }]
    }) {
      if (!hash)
        throw new Error("hash is required");
      return _core.fetchTransaction.call(void 0, { chainId, hash });
    }
    function useTransaction({
      cacheTime = 0,
      chainId: chainId_,
      enabled = true,
      hash,
      scopeKey,
      staleTime,
      suspense,
      onError,
      onSettled,
      onSuccess
    } = {}) {
      const chainId = useChainId({ chainId: chainId_ });
      return useQuery(queryKey15({ chainId, hash, scopeKey }), queryFn15, {
        cacheTime,
        enabled: Boolean(enabled && hash),
        staleTime,
        suspense,
        onError,
        onSettled,
        onSuccess
      });
    }
    function queryKey16({
      confirmations,
      chainId,
      hash,
      scopeKey,
      timeout
    }) {
      return [
        {
          entity: "waitForTransaction",
          confirmations,
          chainId,
          hash,
          scopeKey,
          timeout
        }
      ];
    }
    function queryFn16({
      onReplaced
    }) {
      return ({
        queryKey: [{ chainId, confirmations, hash, timeout }]
      }) => {
        if (!hash)
          throw new Error("hash is required");
        return _core.waitForTransaction.call(void 0, {
          chainId,
          confirmations,
          hash,
          onReplaced,
          timeout
        });
      };
    }
    function useWaitForTransaction({
      chainId: chainId_,
      confirmations,
      hash,
      timeout,
      cacheTime,
      enabled = true,
      scopeKey,
      staleTime,
      suspense,
      onError,
      onReplaced,
      onSettled,
      onSuccess
    } = {}) {
      const chainId = useChainId({ chainId: chainId_ });
      return useQuery(
        queryKey16({ chainId, confirmations, hash, scopeKey, timeout }),
        queryFn16({ onReplaced }),
        {
          cacheTime,
          enabled: Boolean(enabled && hash),
          staleTime,
          suspense,
          onError,
          onSettled,
          onSuccess
        }
      );
    }
    function useWatchPendingTransactions({
      chainId: chainId_,
      enabled = true,
      listener
    }) {
      const chainId = useChainId({ chainId: chainId_ });
      const publicClient = usePublicClient({ chainId });
      const webSocketPublicClient = useWebSocketPublicClient({ chainId });
      React21.useEffect(() => {
        if (!enabled)
          return;
        const publicClient_ = _nullishCoalesce(webSocketPublicClient, () => publicClient);
        return publicClient_.watchPendingTransactions({
          onTransactions: listener
        });
      }, [enabled, listener, publicClient, webSocketPublicClient]);
    }
    var _chains = require_chains();
    exports.ChainMismatchError = _core.ChainMismatchError;
    exports.ChainNotConfiguredError = _core.ChainNotConfiguredError;
    exports.ConfigChainsNotFound = _core.ConfigChainsNotFound;
    exports.Connector = _core.Connector;
    exports.ConnectorAlreadyConnectedError = _core.ConnectorAlreadyConnectedError;
    exports.ConnectorNotFoundError = _core.ConnectorNotFoundError;
    exports.Context = Context;
    exports.SwitchChainNotSupportedError = _core.SwitchChainNotSupportedError;
    exports.WagmiConfig = WagmiConfig;
    exports.configureChains = _core.configureChains;
    exports.createConfig = createConfig;
    exports.createStorage = _core.createStorage;
    exports.deepEqual = _core.deepEqual;
    exports.deserialize = _core.deserialize;
    exports.erc20ABI = _core.erc20ABI;
    exports.erc4626ABI = _core.erc4626ABI;
    exports.erc721ABI = _core.erc721ABI;
    exports.mainnet = _chains.mainnet;
    exports.paginatedIndexesConfig = paginatedIndexesConfig;
    exports.readContracts = _core.readContracts;
    exports.sepolia = _chains.sepolia;
    exports.serialize = _core.serialize;
    exports.useAccount = useAccount;
    exports.useBalance = useBalance;
    exports.useBlockNumber = useBlockNumber;
    exports.useChainId = useChainId;
    exports.useConfig = useConfig;
    exports.useConnect = useConnect;
    exports.useContractEvent = useContractEvent;
    exports.useContractInfiniteReads = useContractInfiniteReads;
    exports.useContractRead = useContractRead;
    exports.useContractReads = useContractReads;
    exports.useContractWrite = useContractWrite;
    exports.useDisconnect = useDisconnect;
    exports.useEnsAddress = useEnsAddress;
    exports.useEnsAvatar = useEnsAvatar;
    exports.useEnsName = useEnsName;
    exports.useEnsResolver = useEnsResolver;
    exports.useFeeData = useFeeData;
    exports.useInfiniteQuery = useInfiniteQuery;
    exports.useMutation = useMutation;
    exports.useNetwork = useNetwork;
    exports.usePrepareContractWrite = usePrepareContractWrite;
    exports.usePrepareSendTransaction = usePrepareSendTransaction;
    exports.usePublicClient = usePublicClient;
    exports.useQuery = useQuery;
    exports.useQueryClient = useQueryClient2;
    exports.useSendTransaction = useSendTransaction;
    exports.useSignMessage = useSignMessage;
    exports.useSignTypedData = useSignTypedData;
    exports.useSwitchNetwork = useSwitchNetwork;
    exports.useToken = useToken;
    exports.useTransaction = useTransaction;
    exports.useWaitForTransaction = useWaitForTransaction;
    exports.useWalletClient = useWalletClient;
    exports.useWatchPendingTransactions = useWatchPendingTransactions;
    exports.useWebSocketPublicClient = useWebSocketPublicClient;
  }
});

export {
  require_chains,
  require_chunk_UGBGYVBH,
  require_chunk_OQILYQDO,
  require_chunk_W65LBPLT,
  browser_default,
  init_browser,
  require_cjs2 as require_cjs,
  require_chunk_2UFLHRLT,
  require_chunk_MQXBDTVK,
  require_dist3 as require_dist,
  require_dist4 as require_dist2
};
/*! Bundled license information:

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=/build/_shared/chunk-GFRV7PTJ.js.map
