import{b as fe,c as ae,d as mt,e as ue,g as Bt,h as M,i as vt,j as le,k as St,l as de,n as It}from"/build/_shared/chunk-Z6K6P77J.js";import{d as Ze}from"/build/_shared/chunk-ZSCMMWXX.js";function Ve(t,n,e,r){if(typeof t.setBigUint64=="function")return t.setBigUint64(n,e,r);let o=BigInt(32),s=BigInt(4294967295),f=Number(e>>o&s),i=Number(e&s),c=r?4:0,a=r?0:4;t.setUint32(n+c,f,r),t.setUint32(n+a,i,r)}var At=class extends St{constructor(n,e,r,o){super(),this.blockLen=n,this.outputLen=e,this.padOffset=r,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(n),this.view=Bt(this.buffer)}update(n){mt(this);let{view:e,buffer:r,blockLen:o}=this;n=vt(n);let s=n.length;for(let f=0;f<s;){let i=Math.min(o-this.pos,s-f);if(i===o){let c=Bt(n);for(;o<=s-f;f+=o)this.process(c,f);continue}r.set(n.subarray(f,f+i),this.pos),this.pos+=i,f+=i,this.pos===o&&(this.process(e,0),this.pos=0)}return this.length+=n.length,this.roundClean(),this}digestInto(n){mt(this),ue(n,this),this.finished=!0;let{buffer:e,view:r,blockLen:o,isLE:s}=this,{pos:f}=this;e[f++]=128,this.buffer.subarray(f).fill(0),this.padOffset>o-f&&(this.process(r,0),f=0);for(let u=f;u<o;u++)e[u]=0;Ve(r,o-8,BigInt(this.length*8),s),this.process(r,0);let i=Bt(n),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let a=c/4,d=this.get();if(a>d.length)throw new Error("_sha2: outputLen bigger than state");for(let u=0;u<a;u++)i.setUint32(4*u,d[u],s)}digest(){let{buffer:n,outputLen:e}=this;this.digestInto(n);let r=n.slice(0,e);return this.destroy(),r}_cloneInto(n){n||(n=new this.constructor),n.set(...this.get());let{blockLen:e,buffer:r,length:o,finished:s,destroyed:f,pos:i}=this;return n.length=o,n.pos=i,n.finished=s,n.destroyed=f,o%e&&n.buffer.set(r),n}};var $e=(t,n,e)=>t&n^~t&e,Pe=(t,n,e)=>t&n^t&e^n&e,ze=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),et=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),nt=new Uint32Array(64),zt=class extends At{constructor(){super(64,32,8,!1),this.A=et[0]|0,this.B=et[1]|0,this.C=et[2]|0,this.D=et[3]|0,this.E=et[4]|0,this.F=et[5]|0,this.G=et[6]|0,this.H=et[7]|0}get(){let{A:n,B:e,C:r,D:o,E:s,F:f,G:i,H:c}=this;return[n,e,r,o,s,f,i,c]}set(n,e,r,o,s,f,i,c){this.A=n|0,this.B=e|0,this.C=r|0,this.D=o|0,this.E=s|0,this.F=f|0,this.G=i|0,this.H=c|0}process(n,e){for(let u=0;u<16;u++,e+=4)nt[u]=n.getUint32(e,!1);for(let u=16;u<64;u++){let v=nt[u-15],E=nt[u-2],w=M(v,7)^M(v,18)^v>>>3,l=M(E,17)^M(E,19)^E>>>10;nt[u]=l+nt[u-7]+w+nt[u-16]|0}let{A:r,B:o,C:s,D:f,E:i,F:c,G:a,H:d}=this;for(let u=0;u<64;u++){let v=M(i,6)^M(i,11)^M(i,25),E=d+v+$e(i,c,a)+ze[u]+nt[u]|0,l=(M(r,2)^M(r,13)^M(r,22))+Pe(r,o,s)|0;d=a,a=c,c=i,i=f+E|0,f=s,s=o,o=r,r=E+l|0}r=r+this.A|0,o=o+this.B|0,s=s+this.C|0,f=f+this.D|0,i=i+this.E|0,c=c+this.F|0,a=a+this.G|0,d=d+this.H|0,this.set(r,o,s,f,i,c,a,d)}roundClean(){nt.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};var bt=de(()=>new zt);var Mt={};Ze(Mt,{bitGet:()=>Ge,bitLen:()=>Ye,bitMask:()=>pt,bitSet:()=>We,bytesToHex:()=>ct,bytesToNumberBE:()=>R,bytesToNumberLE:()=>qt,concatBytes:()=>V,createHmacDrbg:()=>Kt,ensureBytes:()=>C,equalBytes:()=>Me,hexToBytes:()=>ft,hexToNumber:()=>jt,numberToBytesBE:()=>Y,numberToBytesLE:()=>Nt,numberToHexUnpadded:()=>ge,numberToVarBytesBE:()=>Ke,utf8ToBytes:()=>wt,validateObject:()=>X});var me=BigInt(0),_t=BigInt(1),De=BigInt(2),Ot=t=>t instanceof Uint8Array,je=Array.from({length:256},(t,n)=>n.toString(16).padStart(2,"0"));function ct(t){if(!Ot(t))throw new Error("Uint8Array expected");let n="";for(let e=0;e<t.length;e++)n+=je[t[e]];return n}function ge(t){let n=t.toString(16);return n.length&1?`0${n}`:n}function jt(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return BigInt(t===""?"0":`0x${t}`)}function ft(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);let n=t.length;if(n%2)throw new Error("padded hex string expected, got unpadded hex of length "+n);let e=new Uint8Array(n/2);for(let r=0;r<e.length;r++){let o=r*2,s=t.slice(o,o+2),f=Number.parseInt(s,16);if(Number.isNaN(f)||f<0)throw new Error("Invalid byte sequence");e[r]=f}return e}function R(t){return jt(ct(t))}function qt(t){if(!Ot(t))throw new Error("Uint8Array expected");return jt(ct(Uint8Array.from(t).reverse()))}function Y(t,n){return ft(t.toString(16).padStart(n*2,"0"))}function Nt(t,n){return Y(t,n).reverse()}function Ke(t){return ft(ge(t))}function C(t,n,e){let r;if(typeof n=="string")try{r=ft(n)}catch(s){throw new Error(`${t} must be valid hex string, got "${n}". Cause: ${s}`)}else if(Ot(n))r=Uint8Array.from(n);else throw new Error(`${t} must be hex string or Uint8Array`);let o=r.length;if(typeof e=="number"&&o!==e)throw new Error(`${t} expected ${e} bytes, got ${o}`);return r}function V(...t){let n=new Uint8Array(t.reduce((r,o)=>r+o.length,0)),e=0;return t.forEach(r=>{if(!Ot(r))throw new Error("Uint8Array expected");n.set(r,e),e+=r.length}),n}function Me(t,n){if(t.length!==n.length)return!1;for(let e=0;e<t.length;e++)if(t[e]!==n[e])return!1;return!0}function wt(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function Ye(t){let n;for(n=0;t>me;t>>=_t,n+=1);return n}function Ge(t,n){return t>>BigInt(n)&_t}var We=(t,n,e)=>t|(e?_t:me)<<BigInt(n),pt=t=>(De<<BigInt(t-1))-_t,Dt=t=>new Uint8Array(t),he=t=>Uint8Array.from(t);function Kt(t,n,e){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof n!="number"||n<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let r=Dt(t),o=Dt(t),s=0,f=()=>{r.fill(1),o.fill(0),s=0},i=(...u)=>e(o,r,...u),c=(u=Dt())=>{o=i(he([0]),u),r=i(),u.length!==0&&(o=i(he([1]),u),r=i())},a=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let u=0,v=[];for(;u<n;){r=i();let E=r.slice();v.push(E),u+=r.length}return V(...v)};return(u,v)=>{f(),c(u);let E;for(;!(E=v(a()));)c();return f(),E}}var Xe={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||t instanceof Uint8Array,isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,n)=>n.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function X(t,n,e={}){let r=(o,s,f)=>{let i=Xe[s];if(typeof i!="function")throw new Error(`Invalid validator "${s}", expected function`);let c=t[o];if(!(f&&c===void 0)&&!i(c,t))throw new Error(`Invalid param ${String(o)}=${c} (${typeof c}), expected ${s}`)};for(let[o,s]of Object.entries(n))r(o,s,!1);for(let[o,s]of Object.entries(e))r(o,s,!0);return t}var k=BigInt(0),U=BigInt(1),at=BigInt(2),Qe=BigInt(3),Yt=BigInt(4),be=BigInt(5),we=BigInt(8),Je=BigInt(9),Fe=BigInt(16);function H(t,n){let e=t%n;return e>=k?e:n+e}function tn(t,n,e){if(e<=k||n<k)throw new Error("Expected power/modulo > 0");if(e===U)return k;let r=U;for(;n>k;)n&U&&(r=r*t%e),t=t*t%e,n>>=U;return r}function K(t,n,e){let r=t;for(;n-- >k;)r*=r,r%=e;return r}function Tt(t,n){if(t===k||n<=k)throw new Error(`invert: expected positive integers, got n=${t} mod=${n}`);let e=H(t,n),r=n,o=k,s=U,f=U,i=k;for(;e!==k;){let a=r/e,d=r%e,u=o-f*a,v=s-i*a;r=e,e=d,o=f,s=i,f=u,i=v}if(r!==U)throw new Error("invert: does not exist");return H(o,n)}function en(t){let n=(t-U)/at,e,r,o;for(e=t-U,r=0;e%at===k;e/=at,r++);for(o=at;o<t&&tn(o,n,t)!==t-U;o++);if(r===1){let f=(t+U)/Yt;return function(c,a){let d=c.pow(a,f);if(!c.eql(c.sqr(d),a))throw new Error("Cannot find square root");return d}}let s=(e+U)/at;return function(i,c){if(i.pow(c,n)===i.neg(i.ONE))throw new Error("Cannot find square root");let a=r,d=i.pow(i.mul(i.ONE,o),e),u=i.pow(c,s),v=i.pow(c,e);for(;!i.eql(v,i.ONE);){if(i.eql(v,i.ZERO))return i.ZERO;let E=1;for(let l=i.sqr(v);E<a&&!i.eql(l,i.ONE);E++)l=i.sqr(l);let w=i.pow(d,U<<BigInt(a-E-1));d=i.sqr(w),u=i.mul(u,w),v=i.mul(v,d),a=E}return u}}function nn(t){if(t%Yt===Qe){let n=(t+U)/Yt;return function(r,o){let s=r.pow(o,n);if(!r.eql(r.sqr(s),o))throw new Error("Cannot find square root");return s}}if(t%we===be){let n=(t-be)/we;return function(r,o){let s=r.mul(o,at),f=r.pow(s,n),i=r.mul(o,f),c=r.mul(r.mul(i,at),f),a=r.mul(i,r.sub(c,r.ONE));if(!r.eql(r.sqr(a),o))throw new Error("Cannot find square root");return a}}return t%Fe,en(t)}var rn=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Ut(t){let n={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=rn.reduce((r,o)=>(r[o]="function",r),n);return X(t,e)}function on(t,n,e){if(e<k)throw new Error("Expected power > 0");if(e===k)return t.ONE;if(e===U)return n;let r=t.ONE,o=n;for(;e>k;)e&U&&(r=t.mul(r,o)),o=t.sqr(o),e>>=U;return r}function sn(t,n){let e=new Array(n.length),r=n.reduce((s,f,i)=>t.is0(f)?s:(e[i]=s,t.mul(s,f)),t.ONE),o=t.inv(r);return n.reduceRight((s,f,i)=>t.is0(f)?s:(e[i]=t.mul(s,e[i]),t.mul(s,f)),o),e}function Gt(t,n){let e=n!==void 0?n:t.toString(2).length,r=Math.ceil(e/8);return{nBitLength:e,nByteLength:r}}function pe(t,n,e=!1,r={}){if(t<=k)throw new Error(`Expected Field ORDER > 0, got ${t}`);let{nBitLength:o,nByteLength:s}=Gt(t,n);if(s>2048)throw new Error("Field lengths over 2048 bytes are not supported");let f=nn(t),i=Object.freeze({ORDER:t,BITS:o,BYTES:s,MASK:pt(o),ZERO:k,ONE:U,create:c=>H(c,t),isValid:c=>{if(typeof c!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);return k<=c&&c<t},is0:c=>c===k,isOdd:c=>(c&U)===U,neg:c=>H(-c,t),eql:(c,a)=>c===a,sqr:c=>H(c*c,t),add:(c,a)=>H(c+a,t),sub:(c,a)=>H(c-a,t),mul:(c,a)=>H(c*a,t),pow:(c,a)=>on(i,c,a),div:(c,a)=>H(c*Tt(a,t),t),sqrN:c=>c*c,addN:(c,a)=>c+a,subN:(c,a)=>c-a,mulN:(c,a)=>c*a,inv:c=>Tt(c,t),sqrt:r.sqrt||(c=>f(i,c)),invertBatch:c=>sn(i,c),cmov:(c,a,d)=>d?a:c,toBytes:c=>e?Nt(c,s):Y(c,s),fromBytes:c=>{if(c.length!==s)throw new Error(`Fp.fromBytes: expected ${s}, got ${c.length}`);return e?qt(c):R(c)}});return Object.freeze(i)}function ye(t){if(typeof t!="bigint")throw new Error("field order must be bigint");let n=t.toString(2).length;return Math.ceil(n/8)}function Wt(t){let n=ye(t);return n+Math.ceil(n/2)}function xe(t,n,e=!1){let r=t.length,o=ye(n),s=Wt(n);if(r<16||r<s||r>1024)throw new Error(`expected ${s}-1024 bytes of input, got ${r}`);let f=e?R(t):qt(t),i=H(f,n-U)+U;return e?Nt(i,o):Y(i,o)}var fn=BigInt(0),Xt=BigInt(1);function Ee(t,n){let e=(o,s)=>{let f=s.negate();return o?f:s},r=o=>{let s=Math.ceil(n/o)+1,f=2**(o-1);return{windows:s,windowSize:f}};return{constTimeNegate:e,unsafeLadder(o,s){let f=t.ZERO,i=o;for(;s>fn;)s&Xt&&(f=f.add(i)),i=i.double(),s>>=Xt;return f},precomputeWindow(o,s){let{windows:f,windowSize:i}=r(s),c=[],a=o,d=a;for(let u=0;u<f;u++){d=a,c.push(d);for(let v=1;v<i;v++)d=d.add(a),c.push(d);a=d.double()}return c},wNAF(o,s,f){let{windows:i,windowSize:c}=r(o),a=t.ZERO,d=t.BASE,u=BigInt(2**o-1),v=2**o,E=BigInt(o);for(let w=0;w<i;w++){let l=w*c,m=Number(f&u);f>>=E,m>c&&(m-=v,f+=Xt);let h=l,b=l+Math.abs(m)-1,y=w%2!==0,S=m<0;m===0?d=d.add(e(y,s[h])):a=a.add(e(S,s[b]))}return{p:a,f:d}},wNAFCached(o,s,f,i){let c=o._WINDOW_SIZE||1,a=s.get(o);return a||(a=this.precomputeWindow(o,c),c!==1&&s.set(o,i(a))),this.wNAF(c,a,f)}}}function Qt(t){return Ut(t.Fp),X(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Gt(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}function an(t){let n=Qt(t);X(n,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});let{endo:e,Fp:r,a:o}=n;if(e){if(!r.eql(o,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof e!="object"||typeof e.beta!="bigint"||typeof e.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...n})}var{bytesToNumberBE:un,hexToBytes:ln}=Mt,ut={Err:class extends Error{constructor(n=""){super(n)}},_parseInt(t){let{Err:n}=ut;if(t.length<2||t[0]!==2)throw new n("Invalid signature integer tag");let e=t[1],r=t.subarray(2,e+2);if(!e||r.length!==e)throw new n("Invalid signature integer: wrong length");if(r[0]&128)throw new n("Invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new n("Invalid signature integer: unnecessary leading zero");return{d:un(r),l:t.subarray(e+2)}},toSig(t){let{Err:n}=ut,e=typeof t=="string"?ln(t):t;if(!(e instanceof Uint8Array))throw new Error("ui8a expected");let r=e.length;if(r<2||e[0]!=48)throw new n("Invalid signature tag");if(e[1]!==r-2)throw new n("Invalid signature: incorrect length");let{d:o,l:s}=ut._parseInt(e.subarray(2)),{d:f,l:i}=ut._parseInt(s);if(i.length)throw new n("Invalid signature: left bytes after parsing");return{r:o,s:f}},hexFromSig(t){let n=a=>Number.parseInt(a[0],16)&8?"00"+a:a,e=a=>{let d=a.toString(16);return d.length&1?`0${d}`:d},r=n(e(t.s)),o=n(e(t.r)),s=r.length/2,f=o.length/2,i=e(s),c=e(f);return`30${e(f+s+4)}02${c}${o}02${i}${r}`}},G=BigInt(0),L=BigInt(1),rt=BigInt(2),Lt=BigInt(3),Be=BigInt(4);function dn(t){let n=an(t),{Fp:e}=n,r=n.toBytes||((w,l,m)=>{let h=l.toAffine();return V(Uint8Array.from([4]),e.toBytes(h.x),e.toBytes(h.y))}),o=n.fromBytes||(w=>{let l=w.subarray(1),m=e.fromBytes(l.subarray(0,e.BYTES)),h=e.fromBytes(l.subarray(e.BYTES,2*e.BYTES));return{x:m,y:h}});function s(w){let{a:l,b:m}=n,h=e.sqr(w),b=e.mul(h,w);return e.add(e.add(b,e.mul(w,l)),m)}if(!e.eql(e.sqr(n.Gy),s(n.Gx)))throw new Error("bad generator point: equation left != right");function f(w){return typeof w=="bigint"&&G<w&&w<n.n}function i(w){if(!f(w))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function c(w){let{allowedPrivateKeyLengths:l,nByteLength:m,wrapPrivateKey:h,n:b}=n;if(l&&typeof w!="bigint"){if(w instanceof Uint8Array&&(w=ct(w)),typeof w!="string"||!l.includes(w.length))throw new Error("Invalid key");w=w.padStart(m*2,"0")}let y;try{y=typeof w=="bigint"?w:R(C("private key",w,m))}catch{throw new Error(`private key must be ${m} bytes, hex or bigint, not ${typeof w}`)}return h&&(y=H(y,b)),i(y),y}let a=new Map;function d(w){if(!(w instanceof u))throw new Error("ProjectivePoint expected")}class u{constructor(l,m,h){if(this.px=l,this.py=m,this.pz=h,l==null||!e.isValid(l))throw new Error("x required");if(m==null||!e.isValid(m))throw new Error("y required");if(h==null||!e.isValid(h))throw new Error("z required")}static fromAffine(l){let{x:m,y:h}=l||{};if(!l||!e.isValid(m)||!e.isValid(h))throw new Error("invalid affine point");if(l instanceof u)throw new Error("projective point not allowed");let b=y=>e.eql(y,e.ZERO);return b(m)&&b(h)?u.ZERO:new u(m,h,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(l){let m=e.invertBatch(l.map(h=>h.pz));return l.map((h,b)=>h.toAffine(m[b])).map(u.fromAffine)}static fromHex(l){let m=u.fromAffine(o(C("pointHex",l)));return m.assertValidity(),m}static fromPrivateKey(l){return u.BASE.multiply(c(l))}_setWindowSize(l){this._WINDOW_SIZE=l,a.delete(this)}assertValidity(){if(this.is0()){if(n.allowInfinityPoint&&!e.is0(this.py))return;throw new Error("bad point: ZERO")}let{x:l,y:m}=this.toAffine();if(!e.isValid(l)||!e.isValid(m))throw new Error("bad point: x or y not FE");let h=e.sqr(m),b=s(l);if(!e.eql(h,b))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){let{y:l}=this.toAffine();if(e.isOdd)return!e.isOdd(l);throw new Error("Field doesn't support isOdd")}equals(l){d(l);let{px:m,py:h,pz:b}=this,{px:y,py:S,pz:A}=l,x=e.eql(e.mul(m,A),e.mul(y,b)),B=e.eql(e.mul(h,A),e.mul(S,b));return x&&B}negate(){return new u(this.px,e.neg(this.py),this.pz)}double(){let{a:l,b:m}=n,h=e.mul(m,Lt),{px:b,py:y,pz:S}=this,A=e.ZERO,x=e.ZERO,B=e.ZERO,I=e.mul(b,b),$=e.mul(y,y),T=e.mul(S,S),O=e.mul(b,y);return O=e.add(O,O),B=e.mul(b,S),B=e.add(B,B),A=e.mul(l,B),x=e.mul(h,T),x=e.add(A,x),A=e.sub($,x),x=e.add($,x),x=e.mul(A,x),A=e.mul(O,A),B=e.mul(h,B),T=e.mul(l,T),O=e.sub(I,T),O=e.mul(l,O),O=e.add(O,B),B=e.add(I,I),I=e.add(B,I),I=e.add(I,T),I=e.mul(I,O),x=e.add(x,I),T=e.mul(y,S),T=e.add(T,T),I=e.mul(T,O),A=e.sub(A,I),B=e.mul(T,$),B=e.add(B,B),B=e.add(B,B),new u(A,x,B)}add(l){d(l);let{px:m,py:h,pz:b}=this,{px:y,py:S,pz:A}=l,x=e.ZERO,B=e.ZERO,I=e.ZERO,$=n.a,T=e.mul(n.b,Lt),O=e.mul(m,y),P=e.mul(h,S),z=e.mul(b,A),Q=e.add(m,h),g=e.add(y,S);Q=e.mul(Q,g),g=e.add(O,P),Q=e.sub(Q,g),g=e.add(m,b);let p=e.add(y,A);return g=e.mul(g,p),p=e.add(O,z),g=e.sub(g,p),p=e.add(h,b),x=e.add(S,A),p=e.mul(p,x),x=e.add(P,z),p=e.sub(p,x),I=e.mul($,g),x=e.mul(T,z),I=e.add(x,I),x=e.sub(P,I),I=e.add(P,I),B=e.mul(x,I),P=e.add(O,O),P=e.add(P,O),z=e.mul($,z),g=e.mul(T,g),P=e.add(P,z),z=e.sub(O,z),z=e.mul($,z),g=e.add(g,z),O=e.mul(P,g),B=e.add(B,O),O=e.mul(p,g),x=e.mul(Q,x),x=e.sub(x,O),O=e.mul(Q,P),I=e.mul(p,I),I=e.add(I,O),new u(x,B,I)}subtract(l){return this.add(l.negate())}is0(){return this.equals(u.ZERO)}wNAF(l){return E.wNAFCached(this,a,l,m=>{let h=e.invertBatch(m.map(b=>b.pz));return m.map((b,y)=>b.toAffine(h[y])).map(u.fromAffine)})}multiplyUnsafe(l){let m=u.ZERO;if(l===G)return m;if(i(l),l===L)return this;let{endo:h}=n;if(!h)return E.unsafeLadder(this,l);let{k1neg:b,k1:y,k2neg:S,k2:A}=h.splitScalar(l),x=m,B=m,I=this;for(;y>G||A>G;)y&L&&(x=x.add(I)),A&L&&(B=B.add(I)),I=I.double(),y>>=L,A>>=L;return b&&(x=x.negate()),S&&(B=B.negate()),B=new u(e.mul(B.px,h.beta),B.py,B.pz),x.add(B)}multiply(l){i(l);let m=l,h,b,{endo:y}=n;if(y){let{k1neg:S,k1:A,k2neg:x,k2:B}=y.splitScalar(m),{p:I,f:$}=this.wNAF(A),{p:T,f:O}=this.wNAF(B);I=E.constTimeNegate(S,I),T=E.constTimeNegate(x,T),T=new u(e.mul(T.px,y.beta),T.py,T.pz),h=I.add(T),b=$.add(O)}else{let{p:S,f:A}=this.wNAF(m);h=S,b=A}return u.normalizeZ([h,b])[0]}multiplyAndAddUnsafe(l,m,h){let b=u.BASE,y=(A,x)=>x===G||x===L||!A.equals(b)?A.multiplyUnsafe(x):A.multiply(x),S=y(this,m).add(y(l,h));return S.is0()?void 0:S}toAffine(l){let{px:m,py:h,pz:b}=this,y=this.is0();l==null&&(l=y?e.ONE:e.inv(b));let S=e.mul(m,l),A=e.mul(h,l),x=e.mul(b,l);if(y)return{x:e.ZERO,y:e.ZERO};if(!e.eql(x,e.ONE))throw new Error("invZ was invalid");return{x:S,y:A}}isTorsionFree(){let{h:l,isTorsionFree:m}=n;if(l===L)return!0;if(m)return m(u,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){let{h:l,clearCofactor:m}=n;return l===L?this:m?m(u,this):this.multiplyUnsafe(n.h)}toRawBytes(l=!0){return this.assertValidity(),r(u,this,l)}toHex(l=!0){return ct(this.toRawBytes(l))}}u.BASE=new u(n.Gx,n.Gy,e.ONE),u.ZERO=new u(e.ZERO,e.ONE,e.ZERO);let v=n.nBitLength,E=Ee(u,n.endo?Math.ceil(v/2):v);return{CURVE:n,ProjectivePoint:u,normPrivateKeyToScalar:c,weierstrassEquation:s,isWithinCurveOrder:f}}function hn(t){let n=Qt(t);return X(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}function ve(t){let n=hn(t),{Fp:e,n:r}=n,o=e.BYTES+1,s=2*e.BYTES+1;function f(g){return G<g&&g<e.ORDER}function i(g){return H(g,r)}function c(g){return Tt(g,r)}let{ProjectivePoint:a,normPrivateKeyToScalar:d,weierstrassEquation:u,isWithinCurveOrder:v}=dn({...n,toBytes(g,p,_){let N=p.toAffine(),q=e.toBytes(N.x),Z=V;return _?Z(Uint8Array.from([p.hasEvenY()?2:3]),q):Z(Uint8Array.from([4]),q,e.toBytes(N.y))},fromBytes(g){let p=g.length,_=g[0],N=g.subarray(1);if(p===o&&(_===2||_===3)){let q=R(N);if(!f(q))throw new Error("Point is not on curve");let Z=u(q),D=e.sqrt(Z),j=(D&L)===L;return(_&1)===1!==j&&(D=e.neg(D)),{x:q,y:D}}else if(p===s&&_===4){let q=e.fromBytes(N.subarray(0,e.BYTES)),Z=e.fromBytes(N.subarray(e.BYTES,2*e.BYTES));return{x:q,y:Z}}else throw new Error(`Point of length ${p} was invalid. Expected ${o} compressed bytes or ${s} uncompressed bytes`)}}),E=g=>ct(Y(g,n.nByteLength));function w(g){let p=r>>L;return g>p}function l(g){return w(g)?i(-g):g}let m=(g,p,_)=>R(g.slice(p,_));class h{constructor(p,_,N){this.r=p,this.s=_,this.recovery=N,this.assertValidity()}static fromCompact(p){let _=n.nByteLength;return p=C("compactSignature",p,_*2),new h(m(p,0,_),m(p,_,2*_))}static fromDER(p){let{r:_,s:N}=ut.toSig(C("DER",p));return new h(_,N)}assertValidity(){if(!v(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!v(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(p){return new h(this.r,this.s,p)}recoverPublicKey(p){let{r:_,s:N,recovery:q}=this,Z=B(C("msgHash",p));if(q==null||![0,1,2,3].includes(q))throw new Error("recovery id invalid");let D=q===2||q===3?_+n.n:_;if(D>=e.ORDER)throw new Error("recovery id 2 or 3 invalid");let j=q&1?"03":"02",J=a.fromHex(j+E(D)),F=c(D),lt=i(-Z*F),gt=i(N*F),tt=a.BASE.multiplyAndAddUnsafe(J,lt,gt);if(!tt)throw new Error("point at infinify");return tt.assertValidity(),tt}hasHighS(){return w(this.s)}normalizeS(){return this.hasHighS()?new h(this.r,i(-this.s),this.recovery):this}toDERRawBytes(){return ft(this.toDERHex())}toDERHex(){return ut.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return ft(this.toCompactHex())}toCompactHex(){return E(this.r)+E(this.s)}}let b={isValidPrivateKey(g){try{return d(g),!0}catch{return!1}},normPrivateKeyToScalar:d,randomPrivateKey:()=>{let g=Wt(n.n);return xe(n.randomBytes(g),n.n)},precompute(g=8,p=a.BASE){return p._setWindowSize(g),p.multiply(BigInt(3)),p}};function y(g,p=!0){return a.fromPrivateKey(g).toRawBytes(p)}function S(g){let p=g instanceof Uint8Array,_=typeof g=="string",N=(p||_)&&g.length;return p?N===o||N===s:_?N===2*o||N===2*s:g instanceof a}function A(g,p,_=!0){if(S(g))throw new Error("first arg must be private key");if(!S(p))throw new Error("second arg must be public key");return a.fromHex(p).multiply(d(g)).toRawBytes(_)}let x=n.bits2int||function(g){let p=R(g),_=g.length*8-n.nBitLength;return _>0?p>>BigInt(_):p},B=n.bits2int_modN||function(g){return i(x(g))},I=pt(n.nBitLength);function $(g){if(typeof g!="bigint")throw new Error("bigint expected");if(!(G<=g&&g<I))throw new Error(`bigint expected < 2^${n.nBitLength}`);return Y(g,n.nByteLength)}function T(g,p,_=O){if(["recovered","canonical"].some(it=>it in _))throw new Error("sign() legacy options not supported");let{hash:N,randomBytes:q}=n,{lowS:Z,prehash:D,extraEntropy:j}=_;Z==null&&(Z=!0),g=C("msgHash",g),D&&(g=C("prehashed msgHash",N(g)));let J=B(g),F=d(p),lt=[$(F),$(J)];if(j!=null){let it=j===!0?q(e.BYTES):j;lt.push(C("extraEntropy",it))}let gt=V(...lt),tt=J;function Pt(it){let dt=x(it);if(!v(dt))return;let se=c(dt),W=a.BASE.multiply(dt).toAffine(),ht=i(W.x);if(ht===G)return;let Et=i(se*i(tt+ht*F));if(Et===G)return;let ie=(W.x===ht?0:2)|Number(W.y&L),ce=Et;return Z&&w(Et)&&(ce=l(Et),ie^=1),new h(ht,ce,ie)}return{seed:gt,k2sig:Pt}}let O={lowS:n.lowS,prehash:!1},P={lowS:n.lowS,prehash:!1};function z(g,p,_=O){let{seed:N,k2sig:q}=T(g,p,_),Z=n;return Kt(Z.hash.outputLen,Z.nByteLength,Z.hmac)(N,q)}a.BASE._setWindowSize(8);function Q(g,p,_,N=P){let q=g;if(p=C("msgHash",p),_=C("publicKey",_),"strict"in N)throw new Error("options.strict was renamed to lowS");let{lowS:Z,prehash:D}=N,j,J;try{if(typeof q=="string"||q instanceof Uint8Array)try{j=h.fromDER(q)}catch(W){if(!(W instanceof ut.Err))throw W;j=h.fromCompact(q)}else if(typeof q=="object"&&typeof q.r=="bigint"&&typeof q.s=="bigint"){let{r:W,s:ht}=q;j=new h(W,ht)}else throw new Error("PARSE");J=a.fromHex(_)}catch(W){if(W.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(Z&&j.hasHighS())return!1;D&&(p=n.hash(p));let{r:F,s:lt}=j,gt=B(p),tt=c(lt),Pt=i(gt*tt),it=i(F*tt),dt=a.BASE.multiplyAndAddUnsafe(J,Pt,it)?.toAffine();return dt?i(dt.x)===F:!1}return{CURVE:n,getPublicKey:y,getSharedSecret:A,sign:z,verify:Q,ProjectivePoint:a,Signature:h,utils:b}}function mn(t,n){let e=t.ORDER,r=G;for(let w=e-L;w%rt===G;w/=rt)r+=L;let o=r,s=rt<<o-L-L,f=s*rt,i=(e-L)/f,c=(i-L)/rt,a=f-L,d=s,u=t.pow(n,i),v=t.pow(n,(i+L)/rt),E=(w,l)=>{let m=u,h=t.pow(l,a),b=t.sqr(h);b=t.mul(b,l);let y=t.mul(w,b);y=t.pow(y,c),y=t.mul(y,h),h=t.mul(y,l),b=t.mul(y,w);let S=t.mul(b,h);y=t.pow(S,d);let A=t.eql(y,t.ONE);h=t.mul(b,v),y=t.mul(S,m),b=t.cmov(h,b,A),S=t.cmov(y,S,A);for(let x=o;x>L;x--){let B=x-rt;B=rt<<B-L;let I=t.pow(S,B),$=t.eql(I,t.ONE);h=t.mul(b,m),m=t.mul(m,m),I=t.mul(S,m),b=t.cmov(h,b,$),S=t.cmov(I,S,$)}return{isValid:A,value:b}};if(t.ORDER%Be===Lt){let w=(t.ORDER-Lt)/Be,l=t.sqrt(t.neg(n));E=(m,h)=>{let b=t.sqr(h),y=t.mul(m,h);b=t.mul(b,y);let S=t.pow(b,w);S=t.mul(S,y);let A=t.mul(S,l),x=t.mul(t.sqr(S),h),B=t.eql(x,m),I=t.cmov(A,S,B);return{isValid:B,value:I}}}return E}function Se(t,n){if(Ut(t),!t.isValid(n.A)||!t.isValid(n.B)||!t.isValid(n.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");let e=mn(t,n.Z);if(!t.isOdd)throw new Error("Fp.isOdd is not implemented!");return r=>{let o,s,f,i,c,a,d,u;o=t.sqr(r),o=t.mul(o,n.Z),s=t.sqr(o),s=t.add(s,o),f=t.add(s,t.ONE),f=t.mul(f,n.B),i=t.cmov(n.Z,t.neg(s),!t.eql(s,t.ZERO)),i=t.mul(i,n.A),s=t.sqr(f),a=t.sqr(i),c=t.mul(a,n.A),s=t.add(s,c),s=t.mul(s,f),a=t.mul(a,i),c=t.mul(a,n.B),s=t.add(s,c),d=t.mul(o,f);let{isValid:v,value:E}=e(s,a);u=t.mul(o,r),u=t.mul(u,E),d=t.cmov(d,f,v),u=t.cmov(u,E,v);let w=t.isOdd(r)===t.isOdd(u);return u=t.cmov(t.neg(u),u,w),d=t.div(d,i),{x:d,y:u}}}function gn(t){if(t instanceof Uint8Array)return t;if(typeof t=="string")return wt(t);throw new Error("DST must be Uint8Array or string")}var bn=R;function ot(t,n){if(t<0||t>=1<<8*n)throw new Error(`bad I2OSP call: value=${t} length=${n}`);let e=Array.from({length:n}).fill(0);for(let r=n-1;r>=0;r--)e[r]=t&255,t>>>=8;return new Uint8Array(e)}function wn(t,n){let e=new Uint8Array(t.length);for(let r=0;r<t.length;r++)e[r]=t[r]^n[r];return e}function yt(t){if(!(t instanceof Uint8Array))throw new Error("Uint8Array expected")}function Jt(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function pn(t,n,e,r){yt(t),yt(n),Jt(e),n.length>255&&(n=r(V(wt("H2C-OVERSIZE-DST-"),n)));let{outputLen:o,blockLen:s}=r,f=Math.ceil(e/o);if(f>255)throw new Error("Invalid xmd length");let i=V(n,ot(n.length,1)),c=ot(0,s),a=ot(e,2),d=new Array(f),u=r(V(c,t,a,ot(0,1),i));d[0]=r(V(u,ot(1,1),i));for(let E=1;E<=f;E++){let w=[wn(u,d[E-1]),ot(E+1,1),i];d[E]=r(V(...w))}return V(...d).slice(0,e)}function yn(t,n,e,r,o){if(yt(t),yt(n),Jt(e),n.length>255){let s=Math.ceil(2*r/8);n=o.create({dkLen:s}).update(wt("H2C-OVERSIZE-DST-")).update(n).digest()}if(e>65535||n.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return o.create({dkLen:e}).update(t).update(ot(e,2)).update(n).update(ot(n.length,1)).digest()}function Ie(t,n,e){X(e,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});let{p:r,k:o,m:s,hash:f,expand:i,DST:c}=e;yt(t),Jt(n);let a=gn(c),d=r.toString(2).length,u=Math.ceil((d+o)/8),v=n*s*u,E;if(i==="xmd")E=pn(t,a,v,f);else if(i==="xof")E=yn(t,a,v,o,f);else if(i==="_internal_pass")E=t;else throw new Error('expand must be "xmd" or "xof"');let w=new Array(n);for(let l=0;l<n;l++){let m=new Array(s);for(let h=0;h<s;h++){let b=u*(h+l*s),y=E.subarray(b,b+u);m[h]=H(bn(y),r)}w[l]=m}return w}function Ae(t,n){let e=n.map(r=>Array.from(r).reverse());return(r,o)=>{let[s,f,i,c]=e.map(a=>a.reduce((d,u)=>t.add(t.mul(d,r),u)));return r=t.div(s,f),o=t.mul(o,t.div(i,c)),{x:r,y:o}}}function _e(t,n,e){if(typeof n!="function")throw new Error("mapToCurve() must be defined");return{hashToCurve(r,o){let s=Ie(r,2,{...e,DST:e.DST,...o}),f=t.fromAffine(n(s[0])),i=t.fromAffine(n(s[1])),c=f.add(i).clearCofactor();return c.assertValidity(),c},encodeToCurve(r,o){let s=Ie(r,1,{...e,DST:e.encodeDST,...o}),f=t.fromAffine(n(s[0])).clearCofactor();return f.assertValidity(),f}}}var Ht=class extends St{constructor(n,e){super(),this.finished=!1,this.destroyed=!1,ae(n);let r=vt(e);if(this.iHash=n.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;let o=this.blockLen,s=new Uint8Array(o);s.set(r.length>o?n.create().update(r).digest():r);for(let f=0;f<s.length;f++)s[f]^=54;this.iHash.update(s),this.oHash=n.create();for(let f=0;f<s.length;f++)s[f]^=106;this.oHash.update(s),s.fill(0)}update(n){return mt(this),this.iHash.update(n),this}digestInto(n){mt(this),fe(n,this.outputLen),this.finished=!0,this.iHash.digestInto(n),this.oHash.update(n),this.oHash.digestInto(n),this.destroy()}digest(){let n=new Uint8Array(this.oHash.outputLen);return this.digestInto(n),n}_cloneInto(n){n||(n=Object.create(Object.getPrototypeOf(this),{}));let{oHash:e,iHash:r,finished:o,destroyed:s,blockLen:f,outputLen:i}=this;return n=n,n.finished=o,n.destroyed=s,n.blockLen=f,n.outputLen=i,n.oHash=e._cloneInto(n.oHash),n.iHash=r._cloneInto(n.iHash),n}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}},Ft=(t,n,e)=>new Ht(t,n).update(e).digest();Ft.create=(t,n)=>new Ht(t,n);function xn(t){return{hash:t,hmac:(n,...e)=>Ft(t,n,le(...e)),randomBytes:It}}function Oe(t,n){let e=r=>ve({...t,...xn(r)});return Object.freeze({...e(n),create:e})}var Zt=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Rt=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Te=BigInt(1),Ct=BigInt(2),qe=(t,n)=>(t+n/Ct)/n;function Ue(t){let n=Zt,e=BigInt(3),r=BigInt(6),o=BigInt(11),s=BigInt(22),f=BigInt(23),i=BigInt(44),c=BigInt(88),a=t*t*t%n,d=a*a*t%n,u=K(d,e,n)*d%n,v=K(u,e,n)*d%n,E=K(v,Ct,n)*a%n,w=K(E,o,n)*E%n,l=K(w,s,n)*w%n,m=K(l,i,n)*l%n,h=K(m,c,n)*m%n,b=K(h,i,n)*l%n,y=K(b,e,n)*d%n,S=K(y,f,n)*w%n,A=K(S,r,n)*a%n,x=K(A,Ct,n);if(!st.eql(st.sqr(x),t))throw new Error("Cannot find square root");return x}var st=pe(Zt,void 0,void 0,{sqrt:Ue}),Vt=Oe({a:BigInt(0),b:BigInt(7),Fp:st,n:Rt,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{let n=Rt,e=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-Te*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=e,f=BigInt("0x100000000000000000000000000000000"),i=qe(s*t,n),c=qe(-r*t,n),a=H(t-i*e-c*o,n),d=H(-i*r-c*s,n),u=a>f,v=d>f;if(u&&(a=n-a),v&&(d=n-d),a>f||d>f)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:u,k1:a,k2neg:v,k2:d}}}},bt),$t=BigInt(0),Le=t=>typeof t=="bigint"&&$t<t&&t<Zt,En=t=>typeof t=="bigint"&&$t<t&&t<Rt,Ne={};function kt(t,...n){let e=Ne[t];if(e===void 0){let r=bt(Uint8Array.from(t,o=>o.charCodeAt(0)));e=V(r,r),Ne[t]=e}return bt(V(e,...n))}var re=t=>t.toRawBytes(!0).slice(1),ee=t=>Y(t,32),te=t=>H(t,Zt),xt=t=>H(t,Rt),oe=Vt.ProjectivePoint,Bn=(t,n,e)=>oe.BASE.multiplyAndAddUnsafe(t,n,e);function ne(t){let n=Vt.utils.normPrivateKeyToScalar(t),e=oe.fromPrivateKey(n);return{scalar:e.hasEvenY()?n:xt(-n),bytes:re(e)}}function He(t){if(!Le(t))throw new Error("bad x: need 0 < x < p");let n=te(t*t),e=te(n*t+BigInt(7)),r=Ue(e);r%Ct!==$t&&(r=te(-r));let o=new oe(t,r,Te);return o.assertValidity(),o}function Re(...t){return xt(R(kt("BIP0340/challenge",...t)))}function vn(t){return ne(t).bytes}function Sn(t,n,e=It(32)){let r=C("message",t),{bytes:o,scalar:s}=ne(n),f=C("auxRand",e,32),i=ee(s^R(kt("BIP0340/aux",f))),c=kt("BIP0340/nonce",i,o,r),a=xt(R(c));if(a===$t)throw new Error("sign failed: k is zero");let{bytes:d,scalar:u}=ne(a),v=Re(d,o,r),E=new Uint8Array(64);if(E.set(d,0),E.set(ee(xt(u+v*s)),32),!Ce(E,r,o))throw new Error("sign: Invalid signature produced");return E}function Ce(t,n,e){let r=C("signature",t,64),o=C("message",n),s=C("publicKey",e,32);try{let f=He(R(s)),i=R(r.subarray(0,32));if(!Le(i))return!1;let c=R(r.subarray(32,64));if(!En(c))return!1;let a=Re(ee(i),re(f),o),d=Bn(f,c,xt(-a));return!(!d||!d.hasEvenY()||d.toAffine().x!==i)}catch{return!1}}var or=(()=>({getPublicKey:vn,sign:Sn,verify:Ce,utils:{randomPrivateKey:Vt.utils.randomPrivateKey,lift_x:He,pointToBytes:re,numberToBytesBE:Y,bytesToNumberBE:R,taggedHash:kt,mod:H}}))(),In=(()=>Ae(st,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(t=>t.map(n=>BigInt(n)))))(),An=(()=>Se(st,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:st.create(BigInt("-11"))}))(),ke=(()=>_e(Vt.ProjectivePoint,t=>{let{x:n,y:e}=An(st.create(t[0]));return In(n,e)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:st.ORDER,m:1,k:128,expand:"xmd",hash:bt}))(),sr=(()=>ke.hashToCurve)(),ir=(()=>ke.encodeToCurve)();export{ir as encodeToCurve,sr as hashToCurve,or as schnorr,Vt as secp256k1};
/*! Bundled license information:

@noble/curves/esm/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
